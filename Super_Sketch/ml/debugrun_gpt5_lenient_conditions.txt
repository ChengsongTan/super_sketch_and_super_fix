=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
user method didnt solve goal 
METHOD Future: result = fail 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 SWMR_def devcache1_ISDIData_invariant_aux1 devcache2_copy_perform1_invariant
    i0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 InvalidStore'_CSTATE_sameside MESI_State.distinct(105,15)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(125,35) SharedStore'_CSTATE_sameside) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(3,97)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,187)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i23 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11,143) i106) 
zipperposition found a proof... 
METHOD Future: starting 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(11,143)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant4 hstate_invariants(24,4) i106)

Isar proof:
proof -
  have f1: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f2: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f5: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f6: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f7: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f8: "∀m t ma. CSTATE m ( t [ 0 s= ma]) 1 ∨ ¬ CSTATE m t 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f9: "Invalid ≠ ISAD"
    using MESI_State.distinct(143) by moura
  have f10: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have "∀m t ma. ma = m ∨ ¬ CSTATE ma ( t [ 0 s= m]) 0"
    using f6 f3 by metis
  then have "HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ (∃m. m ≠ Invalid ∧ CSTATE m T 0)"
    using f10 f9 f8 f7 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume aa1: "∃m. m ≠ Invalid ∧ CSTATE m T 0"
    { have "¬ CSTATE Invalid T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ (HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∧ (HSTATE SAD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1)"
    by metis
next 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(15) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,11,3) i106
    remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(11,143,15) i106) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,3)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(101,11,35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i106) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,261)) 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(15,261) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
      using CSTATE_inequality_invariant by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ IMAD"
      using MESI_State.distinct(15) by moura
    have ff4: "ISAD ≠ IMAD"
      using MESI_State.distinct(261) by moura
    have "∀m t ma. m = ma ∨ ¬ CSTATE ma ( t [ 0 s= m]) 0"
      using ff2 ff1 by metis
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ CSTATE ISAD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
      using ff4 ff3 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ ¬ nextGOPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ ¬ nextGOPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0"
    by moura
  then show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (CSTATE ISAD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ nextGOPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (CSTATE ISAD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ nextGOPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
SH Future: starting 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) InvalidStore'_CSTATE_otherside InvalidStore'_HSTATE MESI_State.distinct(15)
    SMADSnpInv_C_msg_not_half i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(35) SMADSnpInv_C_msg_not_half SharedStore'_CSTATE_otherside
    SharedStore'_HSTATE i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) InvalidLoad'_CSTATE_otherside InvalidLoad'_HSTATE MESI_State.distinct(11)
    SMADSnpInv_C_msg_not_half i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_not_def InvalidStore'_CSTATE_sameside InvalidStore'_nextReqIs_invariant1
    MESI_State.distinct(15) i26) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
METHOD Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 MESI_State.distinct(35) SharedStore'_CSTATE_otherside SharedStore'_CSTATE_sameside
    SharedStore'_HSTATE i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_state_def InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE InvalidLoad'_nextReqIs_otherside i22 i47) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this: apply (smt (verit) HSTATE_general_rule_10_0 i107)

Isar proof:
proof -
  have f1: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM (T [ -=i 0]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) = HSTATE veriT_vr224 veriT_vr225)"
    by auto
  have f3: "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∧ ¬ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ (∀veriT_vr224 veriT_vr225. ¬ HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∨ HSTATE veriT_vr224 veriT_vr225)"
    by auto
  then have "(∃h t. HSTATE h (t [ -=i 0]) ≠ HSTATE h t) ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  then have f4: "¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T"
    by (metis HSTATE_general_rule_10_0)
  have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    by metis
  moreover
  { assume aa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0"
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0"
      by auto
    then have ff2: "HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0"
      using aa1 by metis
    have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ HSTATE ModifiedM (T [ -=i 0])"
      by auto
    then have "HSTATE ModifiedM (T [ -=i 0])"
      using ff2 by metis }
  moreover
  { assume aa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1"
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1"
      by auto
    then have ff2: "HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1"
      using aa1 by metis
    have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ HSTATE ModifiedM (T [ -=i 0])"
      by auto
    then have "HSTATE ModifiedM (T [ -=i 0])"
      using ff2 by metis }
  ultimately have "HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    by metis
  moreover
  { assume "HSTATE ModifiedM (T [ -=i 0])"
    then have ff1: "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T) ∧ HSTATE ModifiedM (T [ -=i 0])"
      using f4 by metis
    have "HSTATE ModifiedM (T [ -=i 0]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ HSTATE ModifiedM T"
      by auto
    then have "HSTATE ModifiedM T"
      using ff1 by metis
    then have ff2: "¬ CSTATE Shared T 0 ∧ ¬ CSTATE Shared T 1"
      by (metis i107)
    have "(CSTATE Shared T 0 ∨ CSTATE Shared T 1) ∨ ¬ CSTATE Shared T 0"
      by auto
    then have "¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1)"
      using ff2 by metis }
  ultimately have f5: "¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    by metis
  have f6: "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1)) = (CSTATE Shared T 0 ∧ nextLoad T 0 ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1))"
    by auto
  have f7: "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1)) ≠ ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1)) ∨ (CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1)) = ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 1))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    using f5 f6 f7 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 C_msg_not_def C_msg_state_def InvalidStore'_CSTATE_otherside
    InvalidStore'_nextReqIs_invariant1 MESI_State.distinct(11) i26 i47) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant C_msg_state_def InvalidLoad'_CSTATE_otherside
    InvalidLoad'_nextReqIs_otherside MESI_State.distinct(11) SMADSnpInv_C_msg_not_half i47) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
SH Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different2 C_msg_state_def C_state_not_def InvalidStore'_nextReqIs_invariant_not_RdOwn
    InvalidX_HSTATE1 MESI_State.distinct(263,283) ReqType.distinct(1) i101 i31 i417 i47 i488 i68
    nextHTDDataPending_various_forms2 nextReqIs_not_various_forms1 nextReqIs_otherside_rule_2_0
    reqs2_empty_not_nextReqIs_general_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 = HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]))"
    by auto
  have f3: "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∧ ¬ HSTATE veriT_vr242 veriT_vr243) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. ¬ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∨ HSTATE veriT_vr242 veriT_vr243)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 = nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25)"
    by auto
  have f7: "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∧ ¬ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ ¬ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25)"
    by auto
  then have f8: "(∃r t n. RdOwn ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) n) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(1))
  have f11: "RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis InvalidStore'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ [] = reqs1 T ∧ nextReqIs RdShared T 0"
    by auto
  have f13: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  have f14: "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  then have f15: "[] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    using f12 f13 f14 by (metis nextReqIs_not_various_forms1)
  have f16: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f17: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 = nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  have f18: "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∧ ¬ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. ¬ nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∨ nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  then have "(∃r t ra m. nextReqIs r ( t [ 0 +=rdreq ra] [ 0 s= m]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    using f16 f17 f18 by metis
  then have f19: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_otherside_rule_2_0)
  have f20: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1"
    by auto
  have f21: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 = ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1)))"
    by auto
  have f22: "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∧ CSTATE veriT_vr507 veriT_vr509 1 ∧ nextReqIs RdShared veriT_vr509 1) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. ¬ C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∨ ¬ CSTATE veriT_vr507 veriT_vr509 1 ∨ ¬ nextReqIs RdShared veriT_vr509 1)"
    by auto
  then have f23: "(∃m r t. C_state_not m r t ≠ ((CSTATE m t 0 ⟶ ¬ nextReqIs RdShared t 0) ∧ (CSTATE m t 1 ⟶ ¬ nextReqIs RdShared t 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f20 f21 f22 by metis
  have f24: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1"
    by auto
  have f25: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 = ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1)))"
    by auto
  have f26: "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∧ nextReqIs veriT_vr501 veriT_vr503 1 ∧ ¬ CSTATE veriT_vr502 veriT_vr503 1) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    by auto
  have "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. ¬ C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∨ ¬ nextReqIs veriT_vr501 veriT_vr503 1 ∨ CSTATE veriT_vr502 veriT_vr503 1)"
    by auto
  then have f27: "(∃r m t. C_msg_state r m t ≠ ((nextReqIs r t 0 ⟶ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ CSTATE m t 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f24 f25 f26 by metis
  have f28: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ [] = reqs2 T ∧ nextReqIs RdShared T 1"
    by auto
  have f29: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  have f30: "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  then have f31: "[] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    using f28 f29 f30 by (metis reqs2_empty_not_nextReqIs_general_invariant)
  have f32: "¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f23 by (metis C_state_not_def)
  have f33: "¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f27 by (metis C_msg_state_def)
  have f34: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ nextHTDDataPending T 1 ∧ [] = htddatas2 T"
    by auto
  have f35: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ (∀veriT_vr1055. nextHTDDataPending veriT_vr1055 1 = ([] ≠ htddatas2 veriT_vr1055))"
    by auto
  have f36: "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ∧ [] = htddatas2 veriT_vr1055) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by auto
  have "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ (∀veriT_vr1055. ¬ nextHTDDataPending veriT_vr1055 1 ∨ [] ≠ htddatas2 veriT_vr1055)"
    by auto
  then have "(∃t. nextHTDDataPending t 1 ≠ ([] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    using f34 f35 f36 by metis
  then have f37: "¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by (metis nextHTDDataPending_various_forms2)
  have f38: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1"
    by auto
  have f39: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have f40: "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by auto
  have f41: "(∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. ¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185 ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    using f38 f39 f40 by metis
  then have f42: "¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by (metis CSTATE_different2)
  have f43: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1"
    by auto
  have f44: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    using f43 f44 f41 by metis
  then have f45: "¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by (metis CSTATE_different2)
  have "CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "¬ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1"
    using f45 by (metis MESI_State.distinct(283))
  moreover
  { assume aa1: "¬ CSTATE SMA T 1"
    have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
      by auto
    then have "CSTATE IMA T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      using aa1 by metis
    moreover
    { assume aaa1: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
        by auto
      then have fff2: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1"
        using aaa1 by metis
      have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by auto
      then have "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ CSTATE MIA T 1 ∨ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        using fff2 by metis
      moreover
      { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        then have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
          by (metis i417)
        then have "HSTATE ModifiedM T ⟶ (¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          by metis
        moreover
        { assume aaaaa1: "(¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0"
            using aaaaa1 by metis
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
            by auto
          then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
            using fffff2 by metis }
        moreover
        { assume aaaaa1: "¬ HSTATE ModifiedM T"
          have "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            using aaaaa1 f9 by metis
          have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            by auto
          then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
            using fffff2 by metis }
        ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
          by metis }
      moreover
      { assume "CSTATE Modified T 1"
        then have "[] = reqs2 T"
          by (metis i488) }
      moreover
      { assume "CSTATE MIA T 1"
        then have ffff1: "(¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∧ CSTATE MIA T 1"
          using f32 by metis
        have "C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1 ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by (metis i31) }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T ∨ nextHTDDataPending T 1"
        by metis
      moreover
      { assume "nextHTDDataPending T 1"
        then have ffff1: "(¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∧ nextHTDDataPending T 1"
          using f37 by metis
        have "nextHTDDataPending T 1 ∧ [] = htddatas2 T ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
          by auto
        then have "[] ≠ htddatas2 T"
          using ffff1 by metis
        then have "[] = reqs2 T"
          by (metis i101) }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T"
        by metis
      moreover
      { assume "[] = reqs2 T"
        then have ffff1: "([] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∧ [] = reqs2 T"
          using f31 by metis
        have "[] = reqs2 T ∧ nextReqIs RdShared T 1 ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
        by metis }
    moreover
    { assume "CSTATE IMA T 1"
      then have fff1: "(¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∧ CSTATE IMA T 1"
        using f42 by metis
      have "CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
        by auto
      then have "¬ CSTATE ISAD T 1"
        using fff1 by (metis MESI_State.distinct(263)) }
    ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by metis }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have ff1: "(¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∧ ¬ CSTATE ISAD T 1"
      using f33 by metis
    have "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1 ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
      by auto
    then have "¬ nextReqIs RdShared T 1"
      using ff1 by (metis i47) }
  ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have ff1: "(¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
      using f19 by metis
    have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff1 by metis
    have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff2 by metis }
  ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
      using aa1 by metis
    then have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have fff2: "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using aaa1 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using fff2 by metis
      then have "nextReqIs RdShared T 0"
        using f11 f10 by metis
      then have fff3: "([] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∧ nextReqIs RdShared T 0"
        using f15 by metis
      have "[] = reqs1 T ∧ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
        by auto
      then have "[] ≠ reqs1 T"
        using fff3 by metis
      then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
        by (metis i68) }
    ultimately have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis }
  ultimately have f46: "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  have f47: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = (CSTATE Invalid T 0 ∧ nextStore T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  have f48: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ≠ ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ((¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by auto
  have "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  then show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    using f46 f47 f48 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f2: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f3: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f4: "dthdatas1 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f5: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f6: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f7: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f8: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f9: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    using f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
e found a proof... 
e: Try this:
  apply (metis CSTATE_disj1 C_msg_not_def C_msg_state_def C_state_not_def InvalidStore'_nextReqIs_invariant1
    MESI_State.distinct(11,263,265,281,283,285) hstate_invariants(24,4) i144 i189 i22 i23 i25 i26 i31 i353 i417 i449
    i450 i47 i702 nextReqIs_otherside_rule_2_0 nextSnpRespIs_general_rule_9_0)

Isar proof:
proof -
  obtain bb :: bool where
    f1: "bb = ((CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1)"
    by moura
  then have f2: "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ bb"
    by (metis i417)
  have f3: "¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE MIA T 1"
    by (metis C_state_not_def i31)
  have f4: "CSTATE ISAD T 1 ∨ ¬ nextReqIs RdShared T 1"
    by (metis C_msg_state_def i47)
  have f5: "¬ CSTATE IMAD T 1 ∨ ¬ nextReqIs RdShared T 1"
    by (metis C_msg_not_def i25)
  have "CSTATE SMAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
    by (metis MESI_State.distinct(281))
  moreover
  { assume "¬ CSTATE SMAD T 1"
    then have "¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMD T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
      by (metis MESI_State.distinct(265))
    moreover
    { assume "¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMD T 1"
      then have "¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
        by (metis MESI_State.distinct(285))
      moreover
      { assume "¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1"
        then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ ¬ CSTATE SMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE IMA T 1"
          by metis
        moreover
        { assume "¬ CSTATE SMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE IMA T 1"
          then have "bb ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1 ∧ bb"
            by metis
          moreover
          { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1 ∧ bb"
            then have "CSTATE IMAD T 1"
              using f1 by metis
            then have "¬ nextReqIs RdShared T 1"
              using f5 by metis }
          ultimately have "¬ bb ∨ ¬ nextReqIs RdShared T 1"
            by metis }
        moreover
        { assume "CSTATE SMA T 1"
          then have "¬ nextHTDDataPending T 1"
            by (metis i353) }
        moreover
        { assume "CSTATE IMA T 1"
          then have "¬ nextHTDDataPending T 1"
            by (metis i353) }
        ultimately have "¬ nextHTDDataPending T 1 ∨ ¬ bb ∨ ¬ nextReqIs RdShared T 1"
          by metis
        moreover
        { assume "¬ nextHTDDataPending T 1"
          then have "¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
            by (metis MESI_State.distinct(263))
          moreover
          { assume "¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1"
            then have "¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
              by (metis MESI_State.distinct(283))
            moreover
            { assume "¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1"
              then have "¬ bb"
                using f1 by metis }
            ultimately have "bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
              by metis }
          ultimately have "bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
            by metis }
        ultimately have "nextReqIs RdShared T 1 ∧ bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
          by metis
        moreover
        { assume "¬ bb"
          then have "CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
            by metis
          moreover
          { assume "CSTATE Modified T 1"
            then have "¬ HSTATE SB T ∧ ¬ HSTATE SD T ∧ ¬ HSTATE SharedM T"
              by (metis i22 i23 i702)
            then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ⟶ HSTATE MAD T"
              by (metis i144)
            moreover
            { assume "¬ nextGOPending T 1"
              then have "¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                by (metis MESI_State.distinct(11))
              moreover
              { assume "¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1"
                then have "¬ CSTATE IMD T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                  by (metis MESI_State.distinct(265))
                moreover
                { assume "¬ CSTATE IMD T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1"
                  then have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE SMD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                    by (metis MESI_State.distinct(285))
                  moreover
                  { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE SMD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ nextGOPending T 1"
                    then have "¬ CSTATE Modified T 1 ∧ ¬ bb"
                      using f1 by metis }
                  ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                    by metis }
                ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                  by metis }
              ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                by metis }
            moreover
            { assume "HSTATE MAD T"
              then have "nextSnpRespIs RspIFwdM T 0 ∧ HSTATE MAD T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIFwdM T 1 ∧ HSTATE MAD T"
                by metis
              moreover
              { assume "nextSnpRespIs RspIFwdM T 1 ∧ HSTATE MAD T"
                then have "dthdatas2 T ≠ []"
                  by (metis i450)
                then have "¬ HSTATE ModifiedM T"
                  by (metis i189) }
              moreover
              { assume "¬ nextSnpRespIs RspIFwdM T 1 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
                then have "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
                  by (metis nextSnpRespIs_general_rule_9_0)
                then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
                  by (metis nextSnpRespIs_general_rule_9_0) }
              moreover
              { assume "nextSnpRespIs RspIFwdM T 0 ∧ HSTATE MAD T"
                then have "dthdatas1 T ≠ []"
                  by (metis i449)
                then have "¬ HSTATE ModifiedM T"
                  by (metis i189) }
              ultimately have "HSTATE ModifiedM T ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
                by metis }
            ultimately have "HSTATE ModifiedM T ∧ CSTATE ISAD T 1 ⟶ ¬ CSTATE Modified T 1 ∧ ¬ bb ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
              by metis }
          ultimately have "HSTATE ModifiedM T ∧ CSTATE ISAD T 1 ⟶ ¬ CSTATE Modified T 1 ∧ ¬ bb ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
            by metis
          moreover
          { assume "¬ CSTATE Modified T 1 ∧ ¬ bb"
            then have "CSTATE MIA T 1 ∨ ¬ CSTATE MIA T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ bb"
              by metis
            moreover
            { assume "¬ CSTATE MIA T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ bb"
              then have "HSTATE ModifiedM T ⟶ ¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ ¬ bb ∧ HSTATE ModifiedM T"
                by metis
              moreover
              { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ ¬ bb ∧ HSTATE ModifiedM T"
                then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
                  using f2 by metis }
              ultimately have "HSTATE ModifiedM T ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
                by metis }
            moreover
            { assume "CSTATE MIA T 1"
              then have "¬ nextReqIs RdShared T 1"
                using f3 by metis }
            ultimately have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
              by metis }
          ultimately have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
            by metis
          moreover
          { assume "¬ HSTATE ModifiedM T"
            then have "¬ HSTATE ModifiedM (T [ 0 +=rdreq RdOwn])"
              by (metis hstate_invariants(4))
            then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
              by (metis hstate_invariants(24)) }
          ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
            by metis }
        ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
          by metis }
      ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
        by metis }
    ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
      by metis }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by metis
  moreover
  { assume "∃m. m ≠ ISAD ∧ CSTATE m T 1"
    then have "¬ CSTATE ISAD T 1"
      by (metis CSTATE_disj1) }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have "¬ nextReqIs RdShared T 1"
      using f4 by metis }
  ultimately have "nextReqIs RdShared T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have "nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 1"
      by (metis InvalidStore'_nextReqIs_invariant1)
    moreover
    { assume "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 1"
      then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
        by (metis nextReqIs_otherside_rule_2_0) }
    moreover
    { assume "nextReqIs RdShared T 0"
      then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
        by (metis C_msg_not_def i26) }
    ultimately have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis }
  ultimately show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
95.125s elapsed time, 43.438s cpu time, 4.812s GC time 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
116.580s elapsed time, 46.266s cpu time, 4.922s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(137,47) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
e found a proof... 
e: Try this:
  apply (metis CSTATE_disj1 C_msg_not_def C_msg_state_def C_state_not_def InvalidStore'_nextReqIs_invariant1
    MESI_State.distinct(11,263,265,281,283,285) hstate_invariants(24,4) i144 i189 i22 i23 i25 i26 i31 i353 i417 i449
    i450 i47 i702 nextReqIs_otherside_rule_2_0 nextSnpRespIs_general_rule_9_0)

Isar proof:
proof -
  obtain bb :: bool where
    f1: "bb = ((CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1)"
    by moura
  then have f2: "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ bb"
    by (metis i417)
  have f3: "¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE MIA T 1"
    by (metis C_state_not_def i31)
  have f4: "CSTATE ISAD T 1 ∨ ¬ nextReqIs RdShared T 1"
    by (metis C_msg_state_def i47)
  have f5: "¬ CSTATE IMAD T 1 ∨ ¬ nextReqIs RdShared T 1"
    by (metis C_msg_not_def i25)
  have "CSTATE SMAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
    by (metis MESI_State.distinct(281))
  moreover
  { assume "¬ CSTATE SMAD T 1"
    then have "¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
      by (metis MESI_State.distinct(265))
    moreover
    { assume "¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMAD T 1"
      then have "¬ CSTATE SMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMD T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
        by (metis MESI_State.distinct(285))
      moreover
      { assume "¬ CSTATE SMD T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMD T 1"
        then have "bb ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1 ∧ bb ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by metis
        moreover
        { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE SMD T 1 ∧ bb"
          then have "CSTATE IMAD T 1"
            using f1 by metis
          then have "¬ nextReqIs RdShared T 1"
            using f5 by metis }
        moreover
        { assume "CSTATE IMA T 1"
          then have "¬ nextHTDDataPending T 1"
            by (metis i353) }
        moreover
        { assume "CSTATE SMA T 1"
          then have "¬ nextHTDDataPending T 1"
            by (metis i353) }
        ultimately have "¬ nextHTDDataPending T 1 ∨ ¬ bb ∨ ¬ nextReqIs RdShared T 1"
          by metis
        moreover
        { assume "¬ nextHTDDataPending T 1"
          then have "¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
            by (metis MESI_State.distinct(263))
          moreover
          { assume "¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1"
            then have "¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
              by (metis MESI_State.distinct(283))
            moreover
            { assume "¬ CSTATE SMA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ nextHTDDataPending T 1"
              then have "¬ bb"
                using f1 by metis }
            ultimately have "bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
              by metis }
          ultimately have "bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
            by metis }
        ultimately have "nextReqIs RdShared T 1 ∧ bb ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
          by metis
        moreover
        { assume "¬ bb"
          then have "CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
            by metis
          moreover
          { assume "CSTATE Modified T 1"
            then have "¬ HSTATE SB T ∧ ¬ HSTATE SD T ∧ ¬ HSTATE SharedM T"
              by (metis i22 i23 i702)
            then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ⟶ HSTATE MAD T"
              by (metis i144)
            moreover
            { assume "¬ nextGOPending T 1"
              then have "¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                by (metis MESI_State.distinct(11))
              moreover
              { assume "¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1"
                then have "¬ CSTATE IMD T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                  by (metis MESI_State.distinct(265))
                moreover
                { assume "¬ CSTATE IMD T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ nextGOPending T 1"
                  then have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE SMD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ nextGOPending T 1 ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1)"
                    by (metis MESI_State.distinct(285))
                  moreover
                  { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE SMD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ nextGOPending T 1"
                    then have "¬ CSTATE Modified T 1 ∧ ¬ bb"
                      using f1 by metis }
                  ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                    by metis }
                ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                  by metis }
              ultimately have "(∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ ¬ CSTATE Modified T 1 ∧ ¬ bb"
                by metis }
            moreover
            { assume "HSTATE MAD T"
              then have "nextSnpRespIs RspIFwdM T 0 ∧ HSTATE MAD T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIFwdM T 1 ∧ HSTATE MAD T"
                by metis
              moreover
              { assume "nextSnpRespIs RspIFwdM T 1 ∧ HSTATE MAD T"
                then have "dthdatas2 T ≠ []"
                  by (metis i450)
                then have "¬ HSTATE ModifiedM T"
                  by (metis i189) }
              moreover
              { assume "¬ nextSnpRespIs RspIFwdM T 1 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
                then have "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
                  by (metis nextSnpRespIs_general_rule_9_0)
                then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
                  by (metis nextSnpRespIs_general_rule_9_0) }
              moreover
              { assume "nextSnpRespIs RspIFwdM T 0 ∧ HSTATE MAD T"
                then have "dthdatas1 T ≠ []"
                  by (metis i449)
                then have "¬ HSTATE ModifiedM T"
                  by (metis i189) }
              ultimately have "HSTATE ModifiedM T ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
                by metis }
            ultimately have "HSTATE ModifiedM T ∧ CSTATE ISAD T 1 ⟶ ¬ CSTATE Modified T 1 ∧ ¬ bb ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
              by metis }
          ultimately have "HSTATE ModifiedM T ∧ CSTATE ISAD T 1 ⟶ ¬ CSTATE Modified T 1 ∧ ¬ bb ∨ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
            by metis
          moreover
          { assume "¬ CSTATE Modified T 1 ∧ ¬ bb"
            then have "CSTATE MIA T 1 ∨ ¬ CSTATE MIA T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ bb"
              by metis
            moreover
            { assume "¬ CSTATE MIA T 1 ∧ ¬ CSTATE Modified T 1 ∧ ¬ bb"
              then have "HSTATE ModifiedM T ⟶ ¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ ¬ bb ∧ HSTATE ModifiedM T"
                by metis
              moreover
              { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ ¬ bb ∧ HSTATE ModifiedM T"
                then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
                  using f2 by metis }
              ultimately have "HSTATE ModifiedM T ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
                by metis }
            moreover
            { assume "CSTATE MIA T 1"
              then have "¬ nextReqIs RdShared T 1"
                using f3 by metis }
            ultimately have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
              by metis }
          ultimately have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
            by metis
          moreover
          { assume "¬ HSTATE ModifiedM T"
            then have "¬ HSTATE ModifiedM (T [ 0 +=rdreq RdOwn])"
              by (metis hstate_invariants(4))
            then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
              by (metis hstate_invariants(24)) }
          ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
            by metis }
        ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
          by metis }
      ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
        by metis }
    ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
      by metis }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (∃m. m ≠ ISAD ∧ CSTATE m T 1) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1))"
    by metis
  moreover
  { assume "∃m. m ≠ ISAD ∧ CSTATE m T 1"
    then have "¬ CSTATE ISAD T 1"
      by (metis CSTATE_disj1) }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
    by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have "¬ nextReqIs RdShared T 1"
      using f4 by metis }
  ultimately have "nextReqIs RdShared T 1 ⟶ CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
    by metis
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have "nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 1"
      by (metis InvalidStore'_nextReqIs_invariant1)
    moreover
    { assume "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 1"
      then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
        by (metis nextReqIs_otherside_rule_2_0) }
    moreover
    { assume "nextReqIs RdShared T 0"
      then have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
        by (metis C_msg_not_def i26) }
    ultimately have "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
      by metis }
  ultimately show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_disj1 MESI_State.distinct(219,47) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ SIAC"
      using MESI_State.distinct(47) by moura
    have "ISD ≠ SIAC"
      using MESI_State.distinct(219) by moura
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by moura
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE ISD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (CSTATE ISD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside InvalidStore'_HSTATE
    InvalidStore'_nextReqIs_otherside i23 i824) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
156.583s elapsed time, 56.109s cpu time, 5.016s GC time 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(133,43) SharedEvictData'_CSTATE_sameside) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(47)
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i23)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f5: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f6: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ SIAC"
    using MESI_State.distinct(47) by moura
  then have "HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ (HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside InvalidLoad'_HSTATE
    MESI_State.distinct(11) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
170.571s elapsed time, 63.078s cpu time, 5.156s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
METHOD Future: starting 
zipperposition: Try this: apply (metis CSTATE_disj1 MESI_State.distinct(215,43) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ SIA"
      using MESI_State.distinct(43) by moura
    have "ISD ≠ SIA"
      using MESI_State.distinct(215) by moura
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by moura
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(117,27) ModifiedEvict'_CSTATE_sameside) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant ModifiedEvict'_CSTATE_otherside ModifiedEvict'_CSTATE_sameside
    ModifiedEvict'_nextHTDDataPending i576 i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(11,47)
    SharedSnpInv'_CSTATE_invariant5 dthdatas1_starting_transaction_otherside_invariant1 hstate_invariants(24,4) i160
    i898 nextDTHDataFrom_def nextDTHDataPending_def nextDTHDataPending_general_rule_4_0)

Isar proof:
proof -
  have f1: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀t n r m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t [ 0 +=rdreq r] [ 0 s= m]) n"
    using nextDTHDataPending_general_rule_4_0 by moura
  have f7: "CSTATE ISAD T 1 ∨ ¬ nextDTHDataFrom 0 T ∨ ¬ HSTATE SAD T"
    using i160 by moura
  have f8: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f9: "Modified ≠ SIAC"
    using MESI_State.distinct(47) by moura
  have f10: "dthdatas2 T = [] ∨ ¬ CSTATE Modified T 1"
    using i898 by moura
  have f11: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f12: "∀n t. nextDTHDataFrom n t ∨ ¬ (if n = 0 then dthdatas1 t ≠ [] else dthdatas2 t ≠ [])"
    using nextDTHDataFrom_def by moura
  have f13: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f14: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f15: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f15 f14 f13 f12 f11 f10 f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ (HSTATE SAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_HSTATE i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside
    ModifiedEvict'_CSTATE_sameside i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(43)
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i23)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  then have "HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) C_not_C_msg_def ModifiedEvict'_CSTATE_otherside i49 i72 nextGOPending_DeviceModifiedEvict) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_HSTATE i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i22 i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_otherside_rule_10 InvalidX_HSTATE1 MESI_State.distinct(47) SharedSnpInv_C_msg_not_half
    i22)

Isar proof:
proof -
  have f1: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f2: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  have f3: "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  then have f4: "(∃m ma r t. (m ≠ ma ∧ nextReqIs r ( t [ 0 s= m]) 0) ∧ CSTATE ma ( t [ 0 s= m]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T"
    by auto
  have f6: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 = HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]))"
    by auto
  have f7: "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∧ ¬ HSTATE veriT_vr166 veriT_vr167) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    by auto
  have "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. ¬ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∨ HSTATE veriT_vr166 veriT_vr167)"
    by auto
  then have f8: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f5 f6 f7 by metis
  have "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f9: "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by (metis MESI_State.distinct(47))
  have f10: "SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f4 by (metis SharedSnpInv_C_msg_not_half)
  have f11: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f8 by (metis InvalidX_HSTATE1)
  have f12: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f13: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f14: "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f10 f9 f12 f13 by metis
  have f15: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f16: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 = CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1)"
    by auto
  have f17: "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∧ ¬ CSTATE veriT_vr218 veriT_vr219 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. ¬ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∨ CSTATE veriT_vr218 veriT_vr219 1)"
    by auto
  then have "(∃m t r ma. CSTATE m t 1 ≠ CSTATE m ( t [ 0 +=rdreq r] [ 0 s= ma]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    using f15 f16 f17 by metis
  then have f18: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_10)
  have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ CSTATE Modified T 1"
    using f18 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have ff2: "¬ HSTATE SharedM T"
      by (metis i22)
    have "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
      by auto
    then have ff3: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      using ff2 f11 by metis
    have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      by auto
    then have ff4: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff3 by metis
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff4 by metis }
  ultimately have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    by metis
  then have f19: "¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f14 by metis
  have f20: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = (CSTATE Shared T 0 ∧ nextEvict T 0 ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  have f21: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ≠ ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ (CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f19 f20 f21 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside SMADSnpInv_C_msg_not_half i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_inequality_invariant CSTATE_starting_transaction_otherside_invariant1
    MESI_State.distinct(101,11,43) SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i106)

Isar proof:
proof -
  have f1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f7: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f8: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f9: "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  have "Shared ≠ ISAD"
    using MESI_State.distinct(101) by moura
  then have "HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ (∃m. m ≠ Shared ∧ CSTATE m T 0)"
    using f9 f8 f7 f6 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume aa1: "∃m. m ≠ Shared ∧ CSTATE m T 0"
    { have "¬ CSTATE Shared T 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 i73 i897 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f3: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f4: "dthdatas1 T = [] ∨ ¬ CSTATE Modified T 0"
    using i897 by moura
  have f5: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f6: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f7: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f8: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f9: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f10: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ∧ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    using f10 f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(47)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant4 hstate_invariants(24,4) i22)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f7: "∀m t ma. CSTATE m ( t [ 0 s= ma]) 1 ∨ ¬ CSTATE m t 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f8: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have "Modified ≠ SIAC"
    using MESI_State.distinct(47) by moura
  then have "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    using f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_disj1 MESI_State.distinct(289,43) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ SIA"
      using MESI_State.distinct(43) by moura
    have "ISAD ≠ SIA"
      using MESI_State.distinct(289) by moura
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE ISAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ nextGOPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ nextGOPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by moura
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE ISAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ nextGOPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (CSTATE ISAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ nextGOPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 InvalidX_HSTATE1 MESI_State.distinct(11)
    ModifiedEvict'_nextReqIs_invariant_not_RdOwn ReqType.distinct(11) i339 i417 i419 i456 i463 i487 i594 i72 i841
    nextReqIs_nonempty_reqs1 nextSnpRespIs_general_rule_9_0 nextStore_nextEvict_exclusive)

Isar proof:
proof -
  have f1: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 = HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]))"
    by auto
  have f3: "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∧ ¬ HSTATE veriT_vr262 veriT_vr263) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. ¬ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∨ HSTATE veriT_vr262 veriT_vr263)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 = nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23)"
    by auto
  have f7: "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∧ ¬ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ ¬ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23)"
    by auto
  then have f8: "(∃r t n. DirtyEvict ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) n) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(11))
  have f11: "DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis ModifiedEvict'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f13: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  have f14: "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  then have f15: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f12 f13 f14 by (metis nextReqIs_nonempty_reqs1)
  have f16: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f17: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 = nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  have f18: "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∧ ¬ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∨ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  then have "(∃s t r m n. nextSnpRespIs s ( t [ 0 +=rdreq r] [ 0 s= m]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f16 f17 f18 by metis
  then have f19: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_9_0)
  have f20: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ nextEvict T 0 ∧ nextStore T 0"
    by auto
  have f21: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  have f22: "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    by auto
  have "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  then have f23: "¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    using f20 f21 f22 by (metis nextStore_nextEvict_exclusive)
  have f24: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f25: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. (¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199) ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  have f26: "(∃veriT_vr197 veriT_vr198 veriT_vr199. CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199 ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. ¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199 ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f24 f25 f26 by metis
  then have f27: "¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f27 by (metis MESI_State.distinct(11))
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0"
    have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0"
      by auto
    then have "CSTATE IMAD T 0 ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE IIA T 0"
      using aa1 by metis
    moreover
    { assume aaa1: "CSTATE IIA T 0"
      have "CSTATE IIA T 0 ∧ HSTATE ModifiedM T ∨ ¬ CSTATE IIA T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i419) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    moreover
    { assume aaa1: "CSTATE Invalid T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume aaa1: "CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE ISDI T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      then have fff1: "¬ nextSnpRespIs RspIFwdM T 0 ∧ ¬ nextSnpRespIs RspIHitSE T 0"
        by (metis i456)
      have "(nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIHitSE T 0) ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "¬ nextSnpRespIs RspIFwdM T 0"
        using fff1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
        using f19 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff3: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    moreover
    { assume "CSTATE IMAD T 0"
      then have "nextStore T 0"
        by (metis i339)
      then have fff1: "(¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∧ nextStore T 0"
        using f23 by metis
      have "nextEvict T 0 ∧ nextStore T 0 ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
        by auto
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        using fff1 by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      by metis
    moreover
    { assume aaa1: "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ (CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i417) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      by metis
    moreover
    { assume "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      then have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        by metis
      moreover
      { assume aaaa1: "(CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by auto
        then have "CSTATE MIA T 1 ∨ CSTATE Modified T 1"
          using aaaa1 by metis
        moreover
        { assume "CSTATE Modified T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i72) }
        moreover
        { assume "CSTATE MIA T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i594) }
        ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by metis }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1"
        have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have ffff2: "CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          using aaaa1 by metis
        have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have "CSTATE SMA T 1 ∨ CSTATE IMA T 1"
          using ffff2 by metis
        moreover
        { assume aaaaa1: "CSTATE IMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE IMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        moreover
        { assume aaaaa1: "CSTATE SMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE SMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        ultimately have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
          by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i841) }
      ultimately have "nextHTDDataPending T 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "nextHTDDataPending T 1"
        have "(CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1) ∨ ¬ nextHTDDataPending T 1"
          by auto
        then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE Modified T 0 ∧ ([] = dthdatas2 T ∨ nextSnpRespIs RspSFwdM T 1 ∨ HSTATE SD T)"
          by (metis i463)
        have "(CSTATE Modified T 0 ∨ [] ≠ dthdatas2 T ∧ ¬ nextSnpRespIs RspSFwdM T 1 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 0"
          by auto
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          using ffff2 by metis }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        using aaa1 f9 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        by auto
      then have fff3: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    ultimately have "((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis
    moreover
    { assume "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      then have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have ffff2: "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using aaaa1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have "nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using ffff2 by metis
        then have "nextReqIs RdShared T 0"
          using f11 f10 by metis
        then have ffff3: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
          using f15 by metis
        have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
          by auto
        then have "[] ≠ reqs1 T"
          using ffff3 by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i487) }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis }
  ultimately have f28: "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
  have f29: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = (CSTATE Modified T 0 ∧ nextEvict T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  have f30: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f28 f29 f30 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(43) SMADSnpInv_C_msg_not_half SharedEvictData'_CSTATE_otherside
    SharedEvictData'_HSTATE i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(103,13) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_def CSTATE_various_forms1 MESI_State.distinct(5) SharedSnpInv'_CSTATE_invariant5 i592) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(13,185) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(139,5) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
180.952s elapsed time, 68.000s cpu time, 5.344s GC time 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i23 i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
131.154s elapsed time, 55.750s cpu time, 5.203s GC time 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(5) SMADSnpInv_CSTATE SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv_HSTATE SharedSnpInv_nextSnoopIs_otherside i23 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X4. zza X1 X4 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f4: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := Some ma⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using SMADSnpInv_CSTATE by moura
  then have f5: "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  then have f8: "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    using f7 f6 f5 f4 f3 by metis
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f9 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(177) HSTATE_invariant3 hstate_invariants(12,2,24,7) i400
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i400 by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f6: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f7: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f8: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f7 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ (∃h. HSTATE h T ∧ h ≠ MA)"
    using f8 f6 f5 f4 by metis
  moreover
  { assume "∃h. HSTATE h T ∧ h ≠ MA"
    then have "¬ HSTATE MA T"
      using f3 by metis
    then have "nextSnoopIs SnpInv T 0 ⟶ ¬ HSTATE MA T ∧ nextSnoopIs SnpInv T 0"
      by metis
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        by moura }
    moreover
    { assume aaa1: "¬ HSTATE MA T ∧ nextSnoopIs SnpInv T 0"
      { have "¬ CSTATE ISD T 0"
          using aaa1 f2 by metis }
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
181.827s elapsed time, 69.109s cpu time, 5.312s GC time 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(149) HSTATE_invariant3 hstate_invariants(12,2,24,7) i400
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i400 by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f6: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f7: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f8: "SAD ≠ MA"
    using HOST_State.distinct(149) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f7 by metis
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ (∃h. MA ≠ h ∧ HSTATE h T)"
    using f8 f6 f5 f4 by metis
  moreover
  { assume "∃h. MA ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE MA T"
      using f3 by metis
    then have "nextSnoopIs SnpInv T 0 ⟶ ¬ HSTATE MA T ∧ nextSnoopIs SnpInv T 0"
      by metis
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        by moura }
    moreover
    { assume aaa1: "¬ HSTATE MA T ∧ nextSnoopIs SnpInv T 0"
      { have "¬ CSTATE ISD T 0"
          using aaa1 f2 by metis }
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
METHOD Future: starting 
e found a proof... 
e: Try this: apply (metis HOST_State.distinct(149,289) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv i400)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option" where
    f1: "∀X1071. zz X1071 = Some (nextSnoop T 0)"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    "∀X1089 B_X. zza B_X X1089 = B_X"
    by moura
  then have f2: "∀z t s ta h n m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    by (metis HSTATE_invariant_ModifiedSnpInv)
  have "∃h ha. MA ≠ h ∧ MA ≠ ha"
    by (metis HOST_State.distinct(289))
  then have "(∃h ha hb. hb ≠ MA ∧ MA ≠ ha ∧ MA ≠ h ∧ HSTATE hb T) ∨ (∃z. ¬ HSTATE SAD T ∧ zza z = zz)"
    by (metis HOST_State.distinct(149))
  moreover
  { assume "∃z. ¬ HSTATE SAD T ∧ zza z = zz"
    then have "¬ HSTATE SAD ( buffer1_update zz T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
      using f2 by metis
    then have "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
      using f1 by metis }
  moreover
  { assume "∃h ha hb. hb ≠ MA ∧ MA ≠ ha ∧ MA ≠ h ∧ HSTATE hb T"
    then have "¬ HSTATE MA T"
      by (metis HSTATE_invariant3)
    then have "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
      by (metis i400) }
  ultimately show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_assign_rule_6 CSTATE_disj1 MESI_State.distinct(3,97))

Isar proof:
proof -
  { have ff1: "∀m t ma. CSTATE m ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 0"
      using CSTATE_assign_rule_6 by moura
    have ff2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff3: "Modified ≠ Shared"
      using MESI_State.distinct(3) by moura
    have "Shared ≠ ISD"
      using MESI_State.distinct(97) by moura
    then have "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE ISD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
    by moura
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(13,259) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i400 i469 i600 i653 i657 i659 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i400 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f3: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f4: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i469 by moura
  have f5: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f6: "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f8 f6 f5 f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      using f4 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis
    moreover
    { assume "¬ HSTATE MA T"
      then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        using f2 by metis }
    ultimately have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by metis }
  ultimately have "CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  moreover
  { assume "¬ CSTATE ISD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 ISDIData_Shared MESI_State.distinct(5,95)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant ISDIData_Shared MESI_State.distinct(139,5)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_6 CSTATE_disj1 CSTATE_otherside_rule_5_0 MESI_State.distinct(3)
    hstate_invariants(17,20,24) i23 remove_instr_HSTATE)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=devd ])"
    using hstate_invariants(17) by moura
  have f6: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h (t [ n :=dd m])"
    using hstate_invariants(20) by moura
  have f7: "∀m t ma. CSTATE m ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 0"
    using CSTATE_assign_rule_6 by moura
  have f8: "∀m t ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1"
    using CSTATE_otherside_rule_5_0 by moura
  have "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  then have "HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    using f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISDIData_otherside CSTATE_inequality_invariant ISDIData_HSTATE ISDIData_Shared
    MESI_State.distinct(5) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i400 i469 i600 i653 i657 i659 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i400 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f3: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f4: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i469 by moura
  have f5: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f6: "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f8 f6 f5 f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      using f4 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis
    moreover
    { assume "¬ HSTATE MA T"
      then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
        using f2 by metis }
    ultimately have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by metis }
  ultimately have "CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  moreover
  { assume "¬ CSTATE ISD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_6 CSTATE_disj1 CSTATE_inequality_invariant MESI_State.distinct(183,3)
    dthdatas1_perform_instr hstate_invariants(17,20,24) i161 i190 nextDTHDataFrom_def nextDTHDataPending_def
    nextDTHDataPending_other_rule_5_0 nextDTHDataPending_remove_op remove_instr_HSTATE)

Isar proof:
proof -
  have f1: "∀t m ma. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 1"
    using nextDTHDataPending_other_rule_5_0 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=devd ])"
    using hstate_invariants(17) by moura
  have f7: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h (t [ n :=dd m])"
    using hstate_invariants(20) by moura
  have f8: "∀t n na. nextDTHDataPending (t [ -=i n]) na ∨ ¬ nextDTHDataPending t na"
    using nextDTHDataPending_remove_op by moura
  have f9: "∀m t ma. CSTATE m ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 0"
    using CSTATE_assign_rule_6 by moura
  have f10: "¬ nextHTDDataPending T 0 ∨ ¬ nextDTHDataFrom 0 T"
    using i190 by moura
  have f11: "CSTATE ISAD T 0 ∨ ¬ nextDTHDataFrom 1 T ∨ ¬ HSTATE SAD T"
    using i161 by moura
  have f12: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f13: "ISD ≠ ISAD"
    using MESI_State.distinct(183) by moura
  have f14: "∀t n. dthdatas1 t = dthdatas1 (t [ -=i n])"
    using dthdatas1_perform_instr by moura
  have f15: "∀n t. nextDTHDataFrom n t ∨ ¬ (if n = 0 then dthdatas1 t ≠ [] else dthdatas2 t ≠ [])"
    using nextDTHDataFrom_def by moura
  have f16: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f17: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f18: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have f19: "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  have "∀b ba. (if False then b else ba) ∨ ¬ ba"
    using if_False by moura
  then have "nextHTDDataPending T 0 ∧ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (∃m. m ≠ ISD ∧ CSTATE m T 0)"
    using f19 f18 f17 f16 f15 f14 f13 f12 f11 f10 f9 f8 f7 f6 f5 f4 f3 f1 by metis
  moreover
  { assume "¬ nextHTDDataPending T 0"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume aa1: "∃m. m ≠ ISD ∧ CSTATE m T 0"
    { have "¬ CSTATE ISD T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE SAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HOST_State.distinct(11,143,145,147,149,167,199,201,203,221,7,77) HSTATE_invariant3 HSTATE_rule_6
    i153 i190 i376 i672 nextDTHDataFrom_def)

Isar proof:
proof -
  have f1: "((∃veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. HSTATE veriT_vr384 veriT_vr385 ≠ HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T) ∨ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SAD T"
    by auto
  have f2: "((∃veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. HSTATE veriT_vr384 veriT_vr385 ≠ HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T) ∨ (∀veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. HSTATE veriT_vr384 veriT_vr385 = HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr384 veriT_vr385) ∨ ¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    by auto
  have "(∃veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. HSTATE veriT_vr384 veriT_vr385 ≠ HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr384 veriT_vr385 veriT_vr386 veriT_vr387. ¬ HSTATE veriT_vr384 ( veriT_vr385 [ 0 s= veriT_vr386] [ 0 :=dd veriT_vr387] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr384 veriT_vr385)"
    by auto
  then have "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    using f1 f2 f3 by metis
  then have f4: "¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    by (metis HSTATE_rule_6)
  have f5: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ HSTATE SAD T ∧ SB ≠ SA ∧ SB ≠ SA ∧ SAD ≠ SB ∧ HSTATE SB T"
    by auto
  have f6: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have f7: "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  have f8: "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133 ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have f9: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f5 f6 f7 by metis
  have "HSTATE SAD T ∧ SB ≠ SA ∧ SAD ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f10: "HSTATE SAD T ∧ SB ≠ SA ∧ SAD ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE SAD T ∨ ¬ HSTATE SB T"
    by (metis HOST_State.distinct(167,221))
  have f11: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SAD T ∧ MAD ≠ SA ∧ MAD ≠ SA ∧ SAD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have f12: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f13: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    using f11 f12 f8 by metis
  have "HSTATE SAD T ∧ MAD ≠ SA ∧ SAD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f14: "HSTATE SAD T ∧ MAD ≠ SA ∧ SAD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SAD T ∨ ¬ HSTATE MAD T"
    by (metis HOST_State.distinct(147,201))
  have f15: "((∃veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 ≠ (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549)) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) ∨ dthdatas1 T ≠ [] ∧ ¬ nextDTHDataFrom 0 T"
    by auto
  have f16: "((∃veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 ≠ (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549)) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) ∨ (∀veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 = (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549))"
    by auto
  have f17: "(∃veriT_vr1548 veriT_vr1549. [] ≠ dthdatas1 veriT_vr1549 ∧ 0 = veriT_vr1548 ∧ ¬ nextDTHDataFrom veriT_vr1548 veriT_vr1549) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
    by auto
  have "(∃veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 ≠ (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549)) ∨ (∀veriT_vr1548 veriT_vr1549. [] = dthdatas1 veriT_vr1549 ∨ 0 ≠ veriT_vr1548 ∨ nextDTHDataFrom veriT_vr1548 veriT_vr1549)"
    by auto
  then have f18: "(∃n t. nextDTHDataFrom n t ≠ (if 0 = n then [] ≠ dthdatas1 t else [] ≠ dthdatas2 t)) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
    using f15 f16 f17 by metis
  have f19: "dthdatas1 T = [] ∨ nextDTHDataFrom 0 T ⟶ (dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) = (dthdatas1 T = [] ∨ nextDTHDataFrom 0 T)"
    by auto
  have "dthdatas1 T = [] ∨ nextDTHDataFrom 0 T ⟶ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
    by auto
  then have f20: "dthdatas1 T ≠ [] ∧ ¬ nextDTHDataFrom 0 T ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
    using f19 by metis
  have f21: "((∃veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 ≠ (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549)) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) ∨ dthdatas1 T ≠ [] ∧ ¬ nextDTHDataFrom 0 T"
    by auto
  have "((∃veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 ≠ (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549)) ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) ∨ (∀veriT_vr1548 veriT_vr1549. nextDTHDataFrom veriT_vr1548 veriT_vr1549 = (if 0 = veriT_vr1548 then [] ≠ dthdatas1 veriT_vr1549 else [] ≠ dthdatas2 veriT_vr1549))"
    by auto
  then have f22: "dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
    using f21 f20 f18 by (metis nextDTHDataFrom_def)
  have f23: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SAD T ∧ ModifiedM ≠ SA ∧ ModifiedM ≠ SA ∧ SAD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have f24: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f25: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f23 f24 f8 by metis
  have "HSTATE SAD T ∧ ModifiedM ≠ SA ∧ SAD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f26: "HSTATE SAD T ∧ ModifiedM ≠ SA ∧ SAD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SAD T ∨ ¬ HSTATE ModifiedM T"
    by (metis HOST_State.distinct(11,7))
  have f27: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ HSTATE SAD T ∧ MA ≠ SA ∧ MA ≠ SA ∧ SAD ≠ MA ∧ HSTATE MA T"
    by auto
  have f28: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f29: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f27 f28 f8 by metis
  have f30: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) ∨ HSTATE SharedM T ∧ SAD ≠ SA ∧ SAD ≠ SA ∧ SAD ≠ SharedM ∧ HSTATE SAD T"
    by auto
  have f31: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    by auto
  then have f32: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    using f30 f31 f8 by metis
  have f33: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T) ∨ HSTATE SAD T ∧ ID ≠ SA ∧ ID ≠ SA ∧ SAD ≠ ID ∧ HSTATE ID T"
    by auto
  have f34: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  have "(∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. HSTATE veriT_vr132 veriT_vr130 ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133 ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    by auto
  then have f35: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    using f33 f34 f8 by metis
  have f36: "¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ (¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T) = (¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T)"
    by auto
  have "¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f37: "¬ HSTATE SAD T ∨ SB = SA ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f36 by metis
  have f38: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ HSTATE SAD T ∧ SB ≠ SA ∧ SAD ≠ SB ∧ HSTATE SB T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f37 f38 f9 by metis
  then have f39: "¬ HSTATE SAD T ∨ SB = SA ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by (metis HSTATE_invariant3)
  have f40: "¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T ⟶ (¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T) = (¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T)"
    by auto
  have "¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f41: "¬ HSTATE SAD T ∨ MAD = SA ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    using f40 by metis
  have f42: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SAD T ∧ MAD ≠ SA ∧ SAD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    using f41 f42 f13 by metis
  then have f43: "¬ HSTATE SAD T ∨ MAD = SA ∨ SAD = MAD ∨ ¬ HSTATE MAD T"
    by (metis HSTATE_invariant3)
  have f44: "¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ (¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T) = (¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T)"
    by auto
  have "¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f45: "¬ HSTATE SAD T ∨ ModifiedM = SA ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f44 by metis
  have f46: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SAD T ∧ ModifiedM ≠ SA ∧ SAD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f45 f46 f25 by metis
  then have f47: "¬ HSTATE SAD T ∨ ModifiedM = SA ∨ SAD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by (metis HSTATE_invariant3)
  have f48: "¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ (¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) = (¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T)"
    by auto
  have "¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f49: "¬ HSTATE SAD T ∨ MA = SA ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f48 by metis
  have f50: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ HSTATE SAD T ∧ MA ≠ SA ∧ SAD ≠ MA ∧ HSTATE MA T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f49 f50 f29 by metis
  then have f51: "¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by (metis HSTATE_invariant3)
  have f52: "¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T ⟶ (¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) = (¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T)"
    by auto
  have "¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T ⟶ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    by auto
  then have f53: "¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T ⟶ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    using f52 by metis
  have f54: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) ∨ HSTATE SharedM T ∧ SAD ≠ SA ∧ SAD ≠ SharedM ∧ HSTATE SAD T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    using f53 f54 f32 by metis
  then have f55: "¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
    by (metis HSTATE_invariant3)
  have f56: "¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T ⟶ (¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T) = (¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T)"
    by auto
  have "¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T ⟶ ¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    by auto
  then have f57: "¬ HSTATE SAD T ∨ ID = SA ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T ⟶ ¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    using f56 by metis
  have f58: "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T) ∨ HSTATE SAD T ∧ ID ≠ SA ∧ SAD ≠ ID ∧ HSTATE ID T"
    by auto
  have "((∃veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. ((HSTATE veriT_vr129 veriT_vr130 ∨ HSTATE veriT_vr131 veriT_vr130 ∨ HSTATE veriT_vr132 veriT_vr130) ∧ veriT_vr129 ≠ veriT_vr133 ∧ veriT_vr131 ≠ veriT_vr133 ∧ veriT_vr132 ≠ veriT_vr133) ∧ HSTATE veriT_vr133 veriT_vr130) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T) ∨ (∀veriT_vr129 veriT_vr130 veriT_vr131 veriT_vr132 veriT_vr133. (¬ HSTATE veriT_vr129 veriT_vr130 ∧ ¬ HSTATE veriT_vr131 veriT_vr130 ∧ ¬ HSTATE veriT_vr132 veriT_vr130 ∨ veriT_vr129 = veriT_vr133 ∨ veriT_vr131 = veriT_vr133 ∨ veriT_vr132 = veriT_vr133) ∨ ¬ HSTATE veriT_vr133 veriT_vr130)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    using f57 f58 f35 by metis
  then have f59: "¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    by (metis HSTATE_invariant3)
  have "HSTATE SAD T ∧ ID ≠ SA ∧ SAD ≠ ID ∧ HSTATE ID T ∨ ¬ HSTATE SAD T ∨ ID = SA ∨ SAD = ID ∨ ¬ HSTATE ID T"
    by auto
  then have "¬ HSTATE ID T ∨ ¬ HSTATE SAD T"
    using f59 by (metis HOST_State.distinct(145,199))
  moreover
  { assume "¬ HSTATE ID T"
    then have "HSTATE SharedM T ∨ HSTATE MA T ∨ HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE SB T ∨ HSTATE MD T ∨ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE MD T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE InvalidM T ∧ ¬ HSTATE SharedM T ∧ ¬ HSTATE SB T ∨ (HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE MA T ∨ HSTATE MD T ∨ HSTATE ID T ∨ HSTATE InvalidM T ∨ HSTATE SharedM T ∨ HSTATE SB T) ∧ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE MD T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE SharedM T ∧ ¬ HSTATE SB T"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE MA T ∨ HSTATE MD T ∨ HSTATE ID T ∨ HSTATE InvalidM T ∨ HSTATE SharedM T ∨ HSTATE SB T) ∧ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE MD T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE SharedM T ∧ ¬ HSTATE SB T"
      have "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE MD T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE InvalidM T ∧ ¬ HSTATE SharedM T ∧ ¬ HSTATE SB T ∨ HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE MA T ∨ HSTATE MD T ∨ HSTATE ID T ∨ HSTATE InvalidM T ∨ HSTATE SharedM T ∨ HSTATE SB T"
        by auto
      then have "HSTATE InvalidM T"
        using aaa1 by metis
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        by (metis i672) }
    moreover
    { assume "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE MD T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE InvalidM T ∧ ¬ HSTATE SharedM T ∧ ¬ HSTATE SB T"
      then have fff1: "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0"
        by (metis i376)
      have "CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0"
        by auto
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        using fff1 by metis }
    moreover
    { assume "HSTATE MD T"
      then have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE MD T ∨ (¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE MD T) ∧ HSTATE MD T"
        by metis
      moreover
      { assume aaaa1: "(¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE MD T) ∧ HSTATE MD T"
        have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE MD T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE MD T"
          by auto
        then have ffff2: "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0"
          using aaaa1 by metis
        have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE ISDI T 0"
          by auto
        then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
          using ffff2 by metis }
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE MD T"
        then have "dthdatas1 T ≠ []"
          by (metis i153)
        then have ffff1: "(dthdatas1 T = [] ∨ nextDTHDataFrom 0 T) ∧ dthdatas1 T ≠ []"
          using f22 by metis
        have "dthdatas1 T ≠ [] ∧ ¬ nextDTHDataFrom 0 T ∨ dthdatas1 T = [] ∨ nextDTHDataFrom 0 T"
          by auto
        then have "nextDTHDataFrom 0 T"
          using ffff1 by metis
        then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
          by (metis i190) }
      ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        by metis }
    moreover
    { assume "HSTATE SB T"
      then have "¬ HSTATE SAD T"
        using f39 f10 by metis }
    moreover
    { assume "HSTATE MAD T"
      then have "¬ HSTATE SAD T"
        using f43 f14 by metis }
    moreover
    { assume "HSTATE ModifiedM T"
      then have "¬ HSTATE SAD T"
        using f47 f26 by metis }
    moreover
    { assume "HSTATE MA T"
      then have fff1: "(¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T) ∧ HSTATE MA T"
        using f51 by metis
      have "HSTATE SAD T ∧ MA ≠ SA ∧ SAD ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE SAD T ∨ MA = SA ∨ SAD = MA ∨ ¬ HSTATE MA T"
        by auto
      then have "¬ HSTATE SAD T"
        using fff1 by (metis HOST_State.distinct(149,203)) }
    moreover
    { assume "HSTATE SharedM T"
      then have fff1: "(¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T) ∧ HSTATE SharedM T"
        using f55 by metis
      have "HSTATE SharedM T ∧ SAD ≠ SA ∧ SAD ≠ SharedM ∧ HSTATE SAD T ∨ ¬ HSTATE SharedM T ∨ SAD = SA ∨ SAD = SharedM ∨ ¬ HSTATE SAD T"
        by auto
      then have "¬ HSTATE SAD T"
        using fff1 by (metis HOST_State.distinct(143,77)) }
    ultimately have "HSTATE SAD T ⟶ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have "HSTATE SAD T ⟶ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE SAD T"
    have "HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SAD T ∨ ¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
      by auto
    then have ff2: "¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      using aa1 f4 by metis
    have ff3: "(HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f60: "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  have f61: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  have f62: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE SAD ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f60 f61 f62 by metis
next 
METHOD Future: starting 
zipperposition found a proof... 
SH Future: starting 
Sledgehammering... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant ISDIData_Shared MESI_State.distinct(143,5)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis HSTATE_invariant_ModifiedSnpInv i74 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ HSTATE ModifiedM T ∨ ¬ CSTATE ISD T 0"
    using i74 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISD T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_6 CSTATE_disj1 CSTATE_otherside_rule_5_0 MESI_State.distinct(101,11,3))

Isar proof:
proof -
  have f1: "∀m t ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1"
    using CSTATE_otherside_rule_5_0 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀m t ma. CSTATE m ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 0"
    using CSTATE_assign_rule_6 by moura
  have f4: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f5: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have "Shared ≠ ISAD"
    using MESI_State.distinct(101) by moura
  then have "¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    using f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISDIData_otherside CSTATE_inequality_invariant ISDIData_HSTATE ISDIData_Shared
    MESI_State.distinct(5) i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis HSTATE_invariant_ModifiedSnpInv i74 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ HSTATE ModifiedM T ∨ ¬ CSTATE ISD T 0"
    using i74 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISD T 0"
        using aa1 f2 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0)"
    by metis
next 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISDIData_otherside CSTATE_inequality_invariant ISDIData_HSTATE ISDIData_Shared
    MESI_State.distinct(5) i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_different1 ISDIData_HSTATE ISDIData_Shared MESI_State.distinct(5) i778 nextReqIs_ISDIData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_otherside_rule_5_0 C_msg_state_def HSTATE_rule_6
    MESI_State.distinct(183) i22 i47 nextReqIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 ≠ nextReqIs veriT_vr469 veriT_vr470 veriT_vr473) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f2: "((∃veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 ≠ nextReqIs veriT_vr469 veriT_vr470 veriT_vr473) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 = nextReqIs veriT_vr469 veriT_vr470 veriT_vr473)"
    by auto
  have f3: "(∃veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 ∧ ¬ nextReqIs veriT_vr469 veriT_vr470 veriT_vr473) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 ≠ nextReqIs veriT_vr469 veriT_vr470 veriT_vr473) ∨ (∀veriT_vr469 veriT_vr470 veriT_vr471 veriT_vr472 veriT_vr473. ¬ nextReqIs veriT_vr469 ( veriT_vr470 [ 0 s= veriT_vr471] [ 0 :=dd veriT_vr472] [ -=i 0] [ 0 -=devd ]) veriT_vr473 ∨ nextReqIs veriT_vr469 veriT_vr470 veriT_vr473)"
    by auto
  then have f4: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. HSTATE veriT_vr452 veriT_vr453 ≠ HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T) ∨ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SharedM T"
    by auto
  have f6: "((∃veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. HSTATE veriT_vr452 veriT_vr453 ≠ HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T) ∨ (∀veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. HSTATE veriT_vr452 veriT_vr453 = HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f7: "(∃veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr452 veriT_vr453) ∨ ¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T"
    by auto
  have "(∃veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. HSTATE veriT_vr452 veriT_vr453 ≠ HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455. ¬ HSTATE veriT_vr452 ( veriT_vr453 [ 0 s= veriT_vr454] [ 0 :=dd veriT_vr455] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr452 veriT_vr453)"
    by auto
  then have f8: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T"
    using f5 f6 f7 by metis
  have f9: "¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f4 by (metis nextReqIs_general_rule_7_0)
  have f10: "¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T"
    using f8 by (metis HSTATE_rule_6)
  have f11: "((∃veriT_vr753 veriT_vr754 veriT_vr755. C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 ≠ ((nextReqIs veriT_vr753 veriT_vr755 0 ⟶ CSTATE veriT_vr754 veriT_vr755 0) ∧ (nextReqIs veriT_vr753 veriT_vr755 1 ⟶ CSTATE veriT_vr754 veriT_vr755 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0) ∨ C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0"
    by auto
  have f12: "((∃veriT_vr753 veriT_vr754 veriT_vr755. C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 ≠ ((nextReqIs veriT_vr753 veriT_vr755 0 ⟶ CSTATE veriT_vr754 veriT_vr755 0) ∧ (nextReqIs veriT_vr753 veriT_vr755 1 ⟶ CSTATE veriT_vr754 veriT_vr755 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0) ∨ (∀veriT_vr753 veriT_vr754 veriT_vr755. C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 = ((nextReqIs veriT_vr753 veriT_vr755 0 ⟶ CSTATE veriT_vr754 veriT_vr755 0) ∧ (nextReqIs veriT_vr753 veriT_vr755 1 ⟶ CSTATE veriT_vr754 veriT_vr755 1)))"
    by auto
  have f13: "(∃veriT_vr753 veriT_vr754 veriT_vr755. C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 ∧ nextReqIs veriT_vr753 veriT_vr755 0 ∧ ¬ CSTATE veriT_vr754 veriT_vr755 0) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr753 veriT_vr754 veriT_vr755. C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 ≠ ((nextReqIs veriT_vr753 veriT_vr755 0 ⟶ CSTATE veriT_vr754 veriT_vr755 0) ∧ (nextReqIs veriT_vr753 veriT_vr755 1 ⟶ CSTATE veriT_vr754 veriT_vr755 1))) ∨ (∀veriT_vr753 veriT_vr754 veriT_vr755. ¬ C_msg_state veriT_vr753 veriT_vr754 veriT_vr755 ∨ ¬ nextReqIs veriT_vr753 veriT_vr755 0 ∨ CSTATE veriT_vr754 veriT_vr755 0)"
    by auto
  then have f14: "(∃r m t. C_msg_state r m t ≠ ((nextReqIs r t 0 ⟶ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ CSTATE m t 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    using f11 f12 f13 by metis
  have "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0 ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by auto
  then have f15: "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0 ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by (metis i47)
  have f16: "¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    using f14 by (metis C_msg_state_def)
  have f17: "((∃veriT_vr161 veriT_vr162 veriT_vr163. (CSTATE veriT_vr161 veriT_vr162 0 ∧ veriT_vr161 ≠ veriT_vr163) ∧ CSTATE veriT_vr163 veriT_vr162 0) ∨ ¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE ISD T 0 ∧ ISD ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f18: "((∃veriT_vr161 veriT_vr162 veriT_vr163. (CSTATE veriT_vr161 veriT_vr162 0 ∧ veriT_vr161 ≠ veriT_vr163) ∧ CSTATE veriT_vr163 veriT_vr162 0) ∨ ¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr161 veriT_vr162 veriT_vr163. (¬ CSTATE veriT_vr161 veriT_vr162 0 ∨ veriT_vr161 = veriT_vr163) ∨ ¬ CSTATE veriT_vr163 veriT_vr162 0)"
    by auto
  have f19: "(∃veriT_vr161 veriT_vr162 veriT_vr163. CSTATE veriT_vr161 veriT_vr162 0 ∧ veriT_vr161 ≠ veriT_vr163 ∧ CSTATE veriT_vr163 veriT_vr162 0) ∨ ¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr161 veriT_vr162 veriT_vr163. (CSTATE veriT_vr161 veriT_vr162 0 ∧ veriT_vr161 ≠ veriT_vr163) ∧ CSTATE veriT_vr163 veriT_vr162 0) ∨ (∀veriT_vr161 veriT_vr162 veriT_vr163. ¬ CSTATE veriT_vr161 veriT_vr162 0 ∨ veriT_vr161 = veriT_vr163 ∨ ¬ CSTATE veriT_vr163 veriT_vr162 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f17 f18 f19 by metis
  then have f20: "¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have f21: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr504 veriT_vr505 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f22: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr504 veriT_vr505 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr504 veriT_vr505 1)"
    by auto
  have f23: "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr504 veriT_vr505 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr504 veriT_vr505 1) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. ¬ CSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr504 veriT_vr505 1)"
    by auto
  then have "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f21 f22 f23 by metis
  then have f24: "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_5_0)
  have "CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ CSTATE Modified T 1"
    using f24 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have ff2: "¬ HSTATE SharedM T"
      by (metis i22)
    have "HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SharedM T ∨ ¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SharedM T"
      by auto
    then have ff3: "¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      using ff2 f10 by metis
    have "(¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      by auto
    then have ff4: "¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using ff3 by metis
    have "(HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using ff4 by metis }
  ultimately have "(¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    by metis
  then have "(HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume aa1: "(HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    have "(HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    then have ff2: "HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using aa1 by metis
    have "(¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    then have ff3: "nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff2 by metis
    have "nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
      by auto
    then have "nextReqIs RdShared T 0"
      using ff3 f9 by metis
    then have "CSTATE ISAD T 0"
      using f16 f15 by metis
    then have ff4: "(¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0) ∧ CSTATE ISAD T 0"
      using f20 by metis
    have "CSTATE ISD T 0 ∧ ISD ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE ISD T 0 ∨ ISD = ISAD ∨ ¬ CSTATE ISAD T 0"
      by auto
    then have "¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      using ff4 by (metis MESI_State.distinct(183)) }
  ultimately have f25: "¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  have f26: "((CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = (CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  have f27: "((CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ (CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = ((CSTATE ISD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE SharedM ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f25 f26 f27 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis HSTATE_invariant_ModifiedSnpInv i74 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ HSTATE ModifiedM T ∨ ¬ CSTATE ISD T 0"
    using i74 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISD T 0"
        using aa1 f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_state_def HSTATE_rule_6 MESI_State.distinct(259) i47 i778
    nextReqIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ≠ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f2: "((∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ≠ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 = nextReqIs veriT_vr491 veriT_vr492 veriT_vr495)"
    by auto
  have f3: "(∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ∧ ¬ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have f4: "(∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ≠ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ (∀veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. ¬ nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ∨ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495)"
    by auto
  then have f5: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f1 f2 f3 by metis
  have f6: "((∃veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. HSTATE veriT_vr462 veriT_vr463 ≠ HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f7: "((∃veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. HSTATE veriT_vr462 veriT_vr463 ≠ HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. HSTATE veriT_vr462 veriT_vr463 = HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f8: "(∃veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr462 veriT_vr463) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. HSTATE veriT_vr462 veriT_vr463 ≠ HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr462 veriT_vr463 veriT_vr464 veriT_vr465. ¬ HSTATE veriT_vr462 ( veriT_vr463 [ 0 s= veriT_vr464] [ 0 :=dd veriT_vr465] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr462 veriT_vr463)"
    by auto
  then have f9: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f6 f7 f8 by metis
  have f10: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f5 by (metis nextReqIs_general_rule_7_0)
  have f11: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f9 by (metis HSTATE_rule_6)
  have f12: "((∃veriT_vr813 veriT_vr814 veriT_vr815. C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 ≠ ((nextReqIs veriT_vr813 veriT_vr815 0 ⟶ CSTATE veriT_vr814 veriT_vr815 0) ∧ (nextReqIs veriT_vr813 veriT_vr815 1 ⟶ CSTATE veriT_vr814 veriT_vr815 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0) ∨ C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0"
    by auto
  have f13: "((∃veriT_vr813 veriT_vr814 veriT_vr815. C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 ≠ ((nextReqIs veriT_vr813 veriT_vr815 0 ⟶ CSTATE veriT_vr814 veriT_vr815 0) ∧ (nextReqIs veriT_vr813 veriT_vr815 1 ⟶ CSTATE veriT_vr814 veriT_vr815 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0) ∨ (∀veriT_vr813 veriT_vr814 veriT_vr815. C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 = ((nextReqIs veriT_vr813 veriT_vr815 0 ⟶ CSTATE veriT_vr814 veriT_vr815 0) ∧ (nextReqIs veriT_vr813 veriT_vr815 1 ⟶ CSTATE veriT_vr814 veriT_vr815 1)))"
    by auto
  have f14: "(∃veriT_vr813 veriT_vr814 veriT_vr815. C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 ∧ nextReqIs veriT_vr813 veriT_vr815 0 ∧ ¬ CSTATE veriT_vr814 veriT_vr815 0) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr813 veriT_vr814 veriT_vr815. C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 ≠ ((nextReqIs veriT_vr813 veriT_vr815 0 ⟶ CSTATE veriT_vr814 veriT_vr815 0) ∧ (nextReqIs veriT_vr813 veriT_vr815 1 ⟶ CSTATE veriT_vr814 veriT_vr815 1))) ∨ (∀veriT_vr813 veriT_vr814 veriT_vr815. ¬ C_msg_state veriT_vr813 veriT_vr814 veriT_vr815 ∨ ¬ nextReqIs veriT_vr813 veriT_vr815 0 ∨ CSTATE veriT_vr814 veriT_vr815 0)"
    by auto
  then have f15: "(∃r m t. C_msg_state r m t ≠ ((nextReqIs r t 0 ⟶ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ CSTATE m t 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    using f12 f13 f14 by metis
  have "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0 ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by auto
  then have f16: "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 0 ∧ ¬ CSTATE ISAD T 0 ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    by (metis i47)
  have f17: "¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 0 ∨ CSTATE ISAD T 0"
    using f15 by (metis C_msg_state_def)
  have f18: "((∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ≠ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f19: "((∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ≠ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 = nextReqIs veriT_vr491 veriT_vr492 veriT_vr495)"
    by auto
  have "(∃veriT_vr491 veriT_vr492 veriT_vr493 veriT_vr494 veriT_vr495. nextReqIs veriT_vr491 ( veriT_vr492 [ 0 s= veriT_vr493] [ 0 :=dd veriT_vr494] [ -=i 0] [ 0 -=devd ]) veriT_vr495 ∧ ¬ nextReqIs veriT_vr491 veriT_vr492 veriT_vr495) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f18 f19 f4 by metis
  then have f20: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_general_rule_7_0)
  have f21: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE ISDI T 0 ∧ ISDI ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f22: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. (¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159) ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  have f23: "(∃veriT_vr157 veriT_vr158 veriT_vr159. CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159 ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. ¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159 ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f21 f22 f23 by metis
  then have f24: "¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE ISDI T 0 ∧ ISDI ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE ISDI T 0 ∨ ISDI = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f24 by (metis MESI_State.distinct(259))
  moreover
  { assume "¬ CSTATE ISAD T 0"
    then have ff1: "¬ nextReqIs RdShared T 0"
      using f17 f16 by metis
    have "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff1 f10 by metis
    have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    then have ff3: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff2 by metis
    have "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using ff3 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      have "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have fff2: "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using aaa1 by metis
      have fff3: "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
        by auto
      have fff4: "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
        by auto
      have fff5: "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
        by auto
      have fff6: "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1"
        using fff2 f20 fff3 f11 fff4 fff5 fff6 by metis
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by (metis i778) }
    ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f25: "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f26: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f27: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f25 f26 f27 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(177) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv SharedSnpInv_C_msg_not_half2
    i384 i699 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X5. zz B_X X5 = Some B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X6. zza B_X X6 = B_X"
    by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f4: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  have f5: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f6: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE IB T"
    using i699 by moura
  have f7: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have f8: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f2 f4 by metis
  have "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 f2 f1 f7 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE Shared T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
213.617s elapsed time, 74.422s cpu time, 5.797s GC time 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this: apply (metis HSTATE_invariant_ModifiedSnpInv i74 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ HSTATE ModifiedM T ∨ ¬ CSTATE ISD T 0"
    using i74 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISD T 0"
        using aa1 f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1)"
    by metis
next 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit: Try this:
  apply (smt (verit) HSTATE_rule_6 i100 i778 nextHTDDataPending_def nextReqIs_general_rule_7_0
    nextReqIs_nonempty_reqs1)

Isar proof:
proof -
  have "∀veriT_vr1567 veriT_vr1566. (if 1 = veriT_vr1567 then [] ≠ htddatas2 (veriT_vr1566::Type1State) else False) = (1 = veriT_vr1567 ∧ [] ≠ htddatas2 veriT_vr1566)"
    by auto
  then have f1: "∀t n. nextHTDDataPending t n = (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)"
    by (metis nextHTDDataPending_def)
  have f2: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f3: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 = (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568))"
    by auto
  have f4: "(∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ∧ 0 = veriT_vr1569 ∧ [] = htddatas1 veriT_vr1568) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ (∀veriT_vr1568 veriT_vr1569. ¬ nextHTDDataPending veriT_vr1568 veriT_vr1569 ∨ 0 ≠ veriT_vr1569 ∨ [] ≠ htddatas1 veriT_vr1568)"
    by auto
  then have f5: "(∃t n. nextHTDDataPending t n ≠ (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f2 f3 f4 by metis
  have f6: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) = (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T)"
    by auto
  have "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  then have f7: "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f6 by metis
  have f8: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f9: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 = nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  have f10: "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∧ ¬ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have f11: "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. ¬ nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∨ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  then have f12: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f8 f9 f10 by metis
  have f13: "((∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f14: "((∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 = HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f15: "(∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr500 veriT_vr501) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. ¬ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr500 veriT_vr501)"
    by auto
  then have f16: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f13 f14 f15 by metis
  have f17: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 = (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568))"
    by auto
  then have f18: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f17 f7 f5 f1 by metis
  have f19: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f12 by (metis nextReqIs_general_rule_7_0)
  have f20: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f16 by (metis HSTATE_rule_6)
  have f21: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f22: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 = nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  have "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∧ ¬ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have f23: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f21 f22 f11 by metis
  have f24: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f25: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  have f26: "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  then have f27: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f24 f25 f26 by (metis nextReqIs_nonempty_reqs1)
  have f28: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f23 by (metis nextReqIs_general_rule_7_0)
  have "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have f29: "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ nextReqIs RdShared T 1"
    using f28 by metis
  have f30: "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    by auto
  have f31: "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    by auto
  { assume aa1: "nextReqIs RdShared T 1"
    have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
      by auto
    then have "HSTATE ModifiedM T ⟶ HSTATE ModifiedM T ∧ nextReqIs RdShared T 1"
      using aa1 by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1"
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by (metis i778) }
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using aaa1 f20 by metis
      have fff3: "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff2 f30 fff3 f31 by metis }
    ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using f30 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      then have fff1: "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using f31 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have fff2: "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff1 by metis
      have "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
        by auto
      then have "nextReqIs RdShared T 0"
        using fff2 f19 by metis
      then have fff3: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
        using f27 by metis
      have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
        by auto
      then have "[] ≠ reqs1 T"
        using fff3 by metis
      then have "[] = htddatas1 T"
        by (metis i100)
      then have fff4: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f18 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff4 by metis }
    ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f32: "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f29 by metis
  have f33: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f34: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f32 f33 f34 by metis
next 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ISDData_HSTATE i74) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ISDData_HSTATE i74) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(177) HSTATE_invariant3 hstate_invariants(12,2,24,7) i400 i763
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f5: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f6: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using i400 by moura
  have f8: "¬ CSTATE ISD T 0 ∨ ¬ HSTATE IB T"
    using i763 by moura
  have f9: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f6 by metis
  then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    using f9 f8 f7 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE ISD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE ISD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= ISDI]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ISDData_HSTATE i74) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
240.014s elapsed time, 85.672s cpu time, 6.078s GC time 
SH Future: starting 
Sledgehammering... 
verit: Try this:
  apply (smt (verit) HSTATE_rule_6 i100 i778 nextHTDDataPending_def nextReqIs_general_rule_7_0
    nextReqIs_nonempty_reqs1)

Isar proof:
proof -
  have "∀veriT_vr1567 veriT_vr1566. (if 1 = veriT_vr1567 then [] ≠ htddatas2 (veriT_vr1566::Type1State) else False) = (1 = veriT_vr1567 ∧ [] ≠ htddatas2 veriT_vr1566)"
    by auto
  then have f1: "∀t n. nextHTDDataPending t n = (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)"
    by (metis nextHTDDataPending_def)
  have f2: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f3: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 = (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568))"
    by auto
  have f4: "(∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ∧ 0 = veriT_vr1569 ∧ [] = htddatas1 veriT_vr1568) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ (∀veriT_vr1568 veriT_vr1569. ¬ nextHTDDataPending veriT_vr1568 veriT_vr1569 ∨ 0 ≠ veriT_vr1569 ∨ [] ≠ htddatas1 veriT_vr1568)"
    by auto
  then have f5: "(∃t n. nextHTDDataPending t n ≠ (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f2 f3 f4 by metis
  have f6: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) = (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T)"
    by auto
  have "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  then have f7: "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f6 by metis
  have f8: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f9: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 = nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  have f10: "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∧ ¬ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have f11: "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. ¬ nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∨ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  then have f12: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f8 f9 f10 by metis
  have f13: "((∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f14: "((∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 = HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f15: "(∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr500 veriT_vr501) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. HSTATE veriT_vr500 veriT_vr501 ≠ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr500 veriT_vr501 veriT_vr502 veriT_vr503. ¬ HSTATE veriT_vr500 ( veriT_vr501 [ 0 s= veriT_vr502] [ 0 :=dd veriT_vr503] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr500 veriT_vr501)"
    by auto
  then have f16: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f13 f14 f15 by metis
  have f17: "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have "((∃veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 ≠ (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1568 veriT_vr1569. nextHTDDataPending veriT_vr1568 veriT_vr1569 = (if 0 = veriT_vr1569 then [] ≠ htddatas1 veriT_vr1568 else 1 = veriT_vr1569 ∧ [] ≠ htddatas2 veriT_vr1568))"
    by auto
  then have f18: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f17 f7 f5 f1 by metis
  have f19: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f12 by (metis nextReqIs_general_rule_7_0)
  have f20: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f16 by (metis HSTATE_rule_6)
  have f21: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f22: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  have f23: "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  then have f24: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f21 f22 f23 by (metis nextReqIs_nonempty_reqs1)
  have f25: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f26: "((∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ≠ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 = nextReqIs veriT_vr517 veriT_vr518 veriT_vr521)"
    by auto
  have "(∃veriT_vr517 veriT_vr518 veriT_vr519 veriT_vr520 veriT_vr521. nextReqIs veriT_vr517 ( veriT_vr518 [ 0 s= veriT_vr519] [ 0 :=dd veriT_vr520] [ -=i 0] [ 0 -=devd ]) veriT_vr521 ∧ ¬ nextReqIs veriT_vr517 veriT_vr518 veriT_vr521) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f25 f26 f11 by metis
  then have f27: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_general_rule_7_0)
  have "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have f28: "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ nextReqIs RdShared T 1"
    using f27 by metis
  have f29: "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    by auto
  have f30: "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
    by auto
  { assume aa1: "nextReqIs RdShared T 1"
    have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
      by auto
    then have "HSTATE ModifiedM T ⟶ HSTATE ModifiedM T ∧ nextReqIs RdShared T 1"
      using aa1 by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1"
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        by (metis i778) }
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using aaa1 f20 by metis
      have fff3: "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        using fff2 f29 fff3 f30 by metis }
    ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using f29 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis
    moreover
    { assume "(HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      then have fff1: "HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using f30 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have fff2: "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff1 by metis
      have "nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
        by auto
      then have "nextReqIs RdShared T 0"
        using fff2 f19 by metis
      then have fff3: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
        using f24 by metis
      have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
        by auto
      then have "[] ≠ reqs1 T"
        using fff3 by metis
      then have "[] = htddatas1 T"
        by (metis i100)
      then have fff4: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f18 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
        using fff4 by metis }
    ultimately have "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have f31: "¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f28 by metis
  have f32: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  have f33: "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE ISDI T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ (CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = ((CSTATE ISDI T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE ISDI T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE ModifiedM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Invalid] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f31 f32 f33 by metis
next 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ISDData_HSTATE i74) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== EXIT my_hammer_or_method_away with result: success === 
METHOD Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 CSTATE_xyad_htdd_invariant3 MESI_State.distinct(127,37)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 IMADData_CSTATE_IMA MESI_State.distinct(107,17)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(109) SharedSnpInv'_CSTATE_invariant5
    devcache1_IMADGO_invariant_aux1 devcache1_consume_reqresps1_invariant) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3
    MESI_State.distinct(37) i844) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
SH Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISDIData_otherside CSTATE_inequality_invariant ISDIData_HSTATE ISDIData_Shared
    MESI_State.distinct(5) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
153.457s elapsed time, 55.188s cpu time, 1.406s GC time 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_6 CSTATE_disj1 CSTATE_otherside_rule_8 MESI_State.distinct(3)
    hstate_invariants(17,20,24) i23 remove_instr_HSTATE)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=devd ])"
    using hstate_invariants(17) by moura
  have f6: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h (t [ n :=dd m])"
    using hstate_invariants(20) by moura
  have f7: "∀m t ma. CSTATE m ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 0"
    using CSTATE_assign_rule_6 by moura
  have f8: "∀m t ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1"
    using CSTATE_otherside_rule_8 by moura
  have "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  then have "HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    using f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    then have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  then show "CSTATE ISD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE IMAD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Shared] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
next 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
242.110s elapsed time, 79.547s cpu time, 1.781s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3
    MESI_State.distinct(37) i844) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_IMADData_otherside CSTATE_inequality_invariant HSTATE_IMADData IMADData_CSTATE_IMA
    MESI_State.distinct(17) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
METHOD Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(97) SharedSnpInv'_CSTATE_invariant5
    devcache1_SIAGO_WritePullDrop_invariant_aux1 devcache1_consume_reqresps1_invariant) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3
    MESI_State.distinct(37) i844) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_IMADData_otherside CSTATE_inequality_invariant HSTATE_IMADData IMADData_CSTATE_IMA
    MESI_State.distinct(11,17,261) i106) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3
    MESI_State.distinct(37) i844) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_msg_P_oppo_def ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside i3 i6
    nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_X. zz X1 B_X = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 x. zza X1 x = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 x. bb X1 x = (¬ CSTATE Modified X1 x)"
    by moura
  have "C_msg_P_oppo ISAD nextGOPending (λt n. ¬ CSTATE Modified t n) T"
    using i6 by moura
  then have f4: "C_msg_P_oppo ISAD nextGOPending bb T"
    using f3 by metis
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f6: "∀m t. CSTATE ISD ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  then have f7: "nextGOPending T 0 ∧ CSTATE ISAD T 0 ⟶ ¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f6 f5 f4 f3 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE ISAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ CSTATE ISD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_IMADData_otherside CSTATE_inequality_invariant C_not_C_msg_def IMADData_CSTATE_IMA
    MESI_State.distinct(17) i337 nextGOPending_DeviceIMADData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(141,175,179,195,197,9) HSTATE_invariant3 hstate_invariants(14,2,24) i338
    nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f5: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f6: "HSTATE ModifiedM T ∨ HSTATE SAD T ∨ HSTATE MAD T ∨ HSTATE MD T ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE IMAD T 0"
    using i338 by moura
  have f7: "ModifiedM ≠ SD"
    using HOST_State.distinct(9) by moura
  have f8: "SAD ≠ SD"
    using HOST_State.distinct(141) by moura
  have f9: "SD ≠ MAD"
    using HOST_State.distinct(175) by moura
  have f10: "SD ≠ MD"
    using HOST_State.distinct(179) by moura
  have f11: "SD ≠ IB"
    using HOST_State.distinct(197) by moura
  have f12: "SD ≠ SB"
    using HOST_State.distinct(195) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f5 by metis
  then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    using f12 f11 f10 f9 f8 f7 f6 f4 f3 f2 by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_SMADData i658) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_IMADData i656) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_SMADData i658) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside ISADGO'_HSTATE
    MESI_State.distinct(7) i23 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_X. zz X1 B_X = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 x. zza X1 x = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE ISD ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ])"
    using ISADGO'_HSTATE by moura
  then have f7: "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ])"
    using f1 by metis
  have f8: "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f9 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_IMADData i656) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
METHOD Future: result = timeout 
SH Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant C_msg_state_def MESI_State.distinct(281)
    i47 i844 nextReqIs_SMADData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_IMADData_otherside CSTATE_inequality_invariant C_msg_not_def C_msg_state_def
    MESI_State.distinct(11) i25 i47 nextReqIs_IMADData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_inequality_invariant CSTATE_otherside_rule_4_0 CSTATE_remove_op
    MESI_State.distinct(11,19,261) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5
    hstate_invariants(14,2,24) i106 nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_4_0 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f7: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f8: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f9: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f10: "∀m t n na. CSTATE m (t [ -=i n]) na ∨ ¬ CSTATE m t na"
    using CSTATE_remove_op by moura
  have f11: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f12: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f13: "ISAD ≠ IMAD"
    using MESI_State.distinct(261) by moura
  have f14: "Modified ≠ IMD"
    using MESI_State.distinct(19) by moura
  have f15: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f2 by metis
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f7 by metis
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ (∃m. m ≠ IMAD ∧ CSTATE m T 0) ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f15 f14 f13 f12 f11 f10 f9 f8 f6 f5 f4 by metis
  moreover
  { assume aa1: "∃m. m ≠ IMAD ∧ CSTATE m T 0"
    { have "¬ CSTATE IMAD T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant C_msg_state_def HSTATE_SMADData MESI_State.distinct(281,347) i417 i419
    i456 i47 i577 i833 i844 i902 i904 i908 i910 i914 nextReqIs_SMADData nextSnpRespIs_general_rule_5_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(19,265)
    SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5) 
zipperposition found a proof... 
METHOD Future: starting 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_not_C_msg_def IMADGO'_CSTATE_otherside IMADGO'_CSTATE_sameside
    MESI_State.distinct(19) i337 nextGOPending_DeviceIMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_X. zz X1 B_X = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 x. zza X1 x = Some X1"
    by moura
  have f3: "C_not_C_msg Modified IMAD nextGOPending T"
    using i337 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using IMADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE IMD ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using IMADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE IMD ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "Modified ≠ IMD"
    using MESI_State.distinct(19) by moura
  then have "∀m n t. Modified ≠ m ∨ ¬ CSTATE IMD t n ∨ ¬ CSTATE m t n"
    using f6 by metis
  then have "nextGOPending T 0 ∧ CSTATE IMAD T 0 ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using f5 f4 f3 by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using aa1 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HSTATE_rule_3 i159 nextSnpRespIs_general_rule_5_0 nextSnpRespIs_invariant1
    nextSnpRespIs_invariant2)

Isar proof:
proof -
  have "∀veriT_vr977 veriT_vr976. (¬ nextSnpRespIs veriT_vr977 veriT_vr976 0) = (¬ nextSnpRespIs veriT_vr977 veriT_vr976 0)"
    by auto
  then have f1: "∀t s. [] = snpresps1 t ⟶ ¬ nextSnpRespIs s t 0"
    by (metis nextSnpRespIs_invariant1)
  have "∀veriT_vr993 veriT_vr992. (¬ nextSnpRespIs veriT_vr993 veriT_vr992 1) = (¬ nextSnpRespIs veriT_vr993 veriT_vr992 1)"
    by auto
  then have f2: "∀t s. [] = snpresps2 t ⟶ ¬ nextSnpRespIs s t 1"
    by (metis nextSnpRespIs_invariant2)
  have f3: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f4: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 = nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  have f5: "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∧ ¬ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f6: "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. ¬ nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∨ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  then have f7: "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f3 f4 f5 by metis
  have f8: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f9: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 = HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]))"
    by auto
  have f10: "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr280 veriT_vr281) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∨ HSTATE veriT_vr280 veriT_vr281)"
    by auto
  then have f11: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f8 f9 f10 by metis
  have f12: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f7 by (metis nextSnpRespIs_general_rule_5_0)
  have f13: "¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f11 by (metis HSTATE_rule_3)
  have f14: "((∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1) ∨ [] = snpresps2 T ∧ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f15: "((∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr994 veriT_vr995. [] ≠ snpresps2 veriT_vr994 ∨ ¬ nextSnpRespIs veriT_vr995 veriT_vr994 1)"
    by auto
  have f16: "(∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have "(∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ (∀veriT_vr994 veriT_vr995. [] ≠ snpresps2 veriT_vr994 ∨ ¬ nextSnpRespIs veriT_vr995 veriT_vr994 1)"
    by auto
  then have f17: "[] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
    using f14 f15 f16 f2 by metis
  have f18: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f19: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 = nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  have "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∧ ¬ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  then have "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f18 f19 f6 by metis
  then have f20: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_5_0)
  have f21: "((∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0) ∨ [] = snpresps1 T ∧ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f22: "((∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr978 veriT_vr979. [] ≠ snpresps1 veriT_vr978 ∨ ¬ nextSnpRespIs veriT_vr979 veriT_vr978 0)"
    by auto
  have f23: "(∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ (∀veriT_vr978 veriT_vr979. [] ≠ snpresps1 veriT_vr978 ∨ ¬ nextSnpRespIs veriT_vr979 veriT_vr978 0)"
    by auto
  then have f24: "[] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    using f21 f22 f23 f1 by metis
  have "[] = snpresps1 T ∧ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f24 by metis
  moreover
  { assume aa1: "[] ≠ snpresps1 T"
    have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ [] = snpresps1 T"
      by auto
    then have "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
      using aa1 by metis }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 0"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
      using f20 by metis
    have "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      using ff1 by metis
    have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      using ff2 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
        by auto
      then have "nextSnpRespIs RspIFwdM T 1"
        using fff2 f12 by metis
      then have fff3: "([] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1) ∧ nextSnpRespIs RspIFwdM T 1"
        using f17 by metis
      have "[] = snpresps2 T ∧ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
        by auto
      then have fff4: "[] ≠ snpresps2 T"
        using fff3 by metis
      have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ [] = snpresps2 T"
        by auto
      then have "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
        using fff4 by metis }
    ultimately have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
  moreover
  { assume "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
    then have ff1: "¬ HSTATE ModifiedM T"
      by (metis i159)
    have "HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
      by auto
    then have ff2: "¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      using ff1 f13 by metis
    have ff3: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f25: "¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
  have f26: "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) = (CSTATE IMAD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0))"
    by auto
  have f27: "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ∨ (CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) = ((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE IMAD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    using f25 f26 f27 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3
    MESI_State.distinct(37) i844) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
151.264s elapsed time, 52.734s cpu time, 4.094s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis IMADGO'_HSTATE i656 nextGOPending_DeviceIMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  have f4: "¬ nextGOPending T 0 ∨ ¬ CSTATE IMAD T 0 ∨ ¬ HSTATE SharedM T"
    using i656 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume "HSTATE SharedM T"
    then have "¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      using f4 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume "¬ CSTATE IMAD T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HSTATE_rule_3 i159 nextSnpRespIs_general_rule_5_0 nextSnpRespIs_invariant1
    nextSnpRespIs_invariant2)

Isar proof:
proof -
  have "∀veriT_vr977 veriT_vr976. (¬ nextSnpRespIs veriT_vr977 veriT_vr976 0) = (¬ nextSnpRespIs veriT_vr977 veriT_vr976 0)"
    by auto
  then have f1: "∀t s. [] = snpresps1 t ⟶ ¬ nextSnpRespIs s t 0"
    by (metis nextSnpRespIs_invariant1)
  have "∀veriT_vr993 veriT_vr992. (¬ nextSnpRespIs veriT_vr993 veriT_vr992 1) = (¬ nextSnpRespIs veriT_vr993 veriT_vr992 1)"
    by auto
  then have f2: "∀t s. [] = snpresps2 t ⟶ ¬ nextSnpRespIs s t 1"
    by (metis nextSnpRespIs_invariant2)
  have f3: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f4: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 = nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  have f5: "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∧ ¬ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f6: "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. ¬ nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∨ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  then have f7: "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f3 f4 f5 by metis
  have f8: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f9: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 = HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]))"
    by auto
  have f10: "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr280 veriT_vr281) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∨ HSTATE veriT_vr280 veriT_vr281)"
    by auto
  then have f11: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f8 f9 f10 by metis
  have f12: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f7 by (metis nextSnpRespIs_general_rule_5_0)
  have f13: "¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f11 by (metis HSTATE_rule_3)
  have f14: "((∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0) ∨ [] = snpresps1 T ∧ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f15: "((∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr978 veriT_vr979. [] ≠ snpresps1 veriT_vr978 ∨ ¬ nextSnpRespIs veriT_vr979 veriT_vr978 0)"
    by auto
  have f16: "(∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr978 veriT_vr979. [] = snpresps1 veriT_vr978 ∧ nextSnpRespIs veriT_vr979 veriT_vr978 0) ∨ (∀veriT_vr978 veriT_vr979. [] ≠ snpresps1 veriT_vr978 ∨ ¬ nextSnpRespIs veriT_vr979 veriT_vr978 0)"
    by auto
  then have f17: "[] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    using f14 f15 f16 f1 by metis
  have f18: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f19: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 = nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  have "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∧ ¬ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  then have "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f18 f19 f6 by metis
  then have f20: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by (metis nextSnpRespIs_general_rule_5_0)
  have f21: "((∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1) ∨ [] = snpresps2 T ∧ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f22: "((∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr994 veriT_vr995. [] ≠ snpresps2 veriT_vr994 ∨ ¬ nextSnpRespIs veriT_vr995 veriT_vr994 1)"
    by auto
  have f23: "(∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have "(∃veriT_vr994 veriT_vr995. [] = snpresps2 veriT_vr994 ∧ nextSnpRespIs veriT_vr995 veriT_vr994 1) ∨ (∀veriT_vr994 veriT_vr995. [] ≠ snpresps2 veriT_vr994 ∨ ¬ nextSnpRespIs veriT_vr995 veriT_vr994 1)"
    by auto
  then have f24: "[] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
    using f21 f22 f23 f2 by metis
  have "[] = snpresps2 T ∧ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f24 by metis
  moreover
  { assume aa1: "[] ≠ snpresps2 T"
    have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ [] = snpresps2 T"
      by auto
    then have "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
      using aa1 by metis }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 1"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∧ ¬ nextSnpRespIs RspIFwdM T 1"
      using f20 by metis
    have "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      using ff1 by metis
    have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      using ff2 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      have "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "nextSnpRespIs RspIFwdM T 0"
        using fff2 f12 by metis
      then have fff3: "([] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0) ∧ nextSnpRespIs RspIFwdM T 0"
        using f17 by metis
      have "[] = snpresps1 T ∧ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff4: "[] ≠ snpresps1 T"
        using fff3 by metis
      have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ [] = snpresps1 T"
        by auto
      then have "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
        using fff4 by metis }
    ultimately have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have "([] ≠ snpresps2 T ∨ [] ≠ snpresps1 T) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume "[] ≠ snpresps2 T ∨ [] ≠ snpresps1 T"
    then have ff1: "¬ HSTATE ModifiedM T"
      by (metis i159)
    have "HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
      by auto
    then have ff2: "¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      using ff1 f13 by metis
    have ff3: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f25: "¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  have f26: "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = (CSTATE IMAD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  have f27: "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE IMAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ (CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = ((CSTATE IMAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE IMAD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ (HSTATE ModifiedM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= IMA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    using f25 f26 f27 by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside MESI_State.distinct(7)
    hstate_invariants(14,2,24) i22 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE ISD ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 by metis
  have f10: "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f12: "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  have "∀m n t. Modified ≠ m ∨ ¬ CSTATE ISD t n ∨ ¬ CSTATE m t n"
    using f10 f6 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f12 f9 f8 f7 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f11 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f11 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis IMADGO'_HSTATE i656 nextGOPending_DeviceIMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  have f4: "¬ nextGOPending T 0 ∨ ¬ CSTATE IMAD T 0 ∨ ¬ HSTATE SharedM T"
    using i656 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume "HSTATE SharedM T"
    then have "¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      using f4 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume "¬ CSTATE IMAD T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside MESI_State.distinct(7)
    hstate_invariants(14,2,24) i22 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE ISD ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 by metis
  have f10: "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f12: "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  have "∀m n t. Modified ≠ m ∨ ¬ CSTATE ISD t n ∨ ¬ CSTATE m t n"
    using f10 f6 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f12 f9 f8 f7 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f11 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f11 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0)"
    by metis
next 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 CSTATE_xyad_htdd_invariant3 MESI_State.distinct(9,99)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(129) SharedSnpInv'_CSTATE_invariant5
    devcache1_SMADGO_invariant_aux1 devcache1_consume_reqresps1_invariant) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_IMADData_otherside CSTATE_disj4' CSTATE_inequality_invariant HSTATE_IMADData
    IMADData_CSTATE_IMA MESI_State.distinct(17,3) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
175.473s elapsed time, 62.266s cpu time, 5.938s GC time 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(211,39)
    SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant H_C_state_msg_same_def IMADGO'_CSTATE_otherside IMADGO'_CSTATE_sameside
    IMADGO'_HSTATE IMADGO'_nextReqIs MESI_State.distinct(19) i12 i36 nextGOPending_DeviceIMADGO
    nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ CSTATE Modified X1 B_X)"
    by moura
  have "H_C_state_msg_same ModifiedM Modified (λt n. ¬ nextReqIs RdShared t n) T"
    using i36 by moura
  then have f5: "H_C_state_msg_same ModifiedM Modified bb T"
    using f3 by metis
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using IMADGO'_CSTATE_otherside by moura
  then have f6: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextReqIs by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  have "∀m t. CSTATE IMD ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using IMADGO'_CSTATE_sameside by moura
  then have f9: "∀m t. CSTATE IMD ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f10: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f11: "Modified ≠ IMD"
    using MESI_State.distinct(19) by moura
  have "∀n t m. m = Modified ∨ ¬ CSTATE m t n ∨ bba t n"
    using f10 f4 by metis
  then have f12: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f11 f9 f8 f7 f4 f6 f5 f3 by metis
  have f13: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f13 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f13 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f13 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    using f12 by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_not_C_msg_def ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside
    MESI_State.distinct(7) i49 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_X. zz X1 B_X = Some X1"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_x. zza X1 B_x = X1"
    by moura
  have f3: "C_not_C_msg Modified ISAD nextGOPending T"
    using i49 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f1 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE ISD ( buffer1_update (zz m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f1 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  then have "nextGOPending T 0 ∧ CSTATE ISAD T 0 ⟶ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f6 f5 f4 f3 by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE ISAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "∀X0. zza (Some X0) = zz X0"
        by moura
      then have "¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_disj1 CSTATE_xyad_htdd_invariant3 MESI_State.distinct(181,9))

Isar proof:
proof -
  { have ff1: "∀m t n ma na. CSTATE m ( t [ 0 s= m] [ n :=dd ma] [ na -=devd ]) 0"
      using CSTATE_xyad_htdd_invariant3 by moura
    have ff2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff3: "Modified ≠ ISA"
      using MESI_State.distinct(9) by moura
    have "ISD ≠ ISA"
      using MESI_State.distinct(181) by moura
    then have "¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE ISD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
    by moura
  then show "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def IMADGO'_HSTATE IMADGO'_nextDTHDataPending IMADGO'_nextReqIs i13
    nextGOPending_DeviceIMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextDTHDataPending by moura
  then have f5: "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  then have f7: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f6 f5 f4 f3 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f8 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def ISADGO'_HSTATE ISADGO'_nextDTHDataPending ISADGO'_nextReqIs i13
    nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextDTHDataPending by moura
  then have f5: "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ])"
    using ISADGO'_HSTATE by moura
  then have f7: "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ])"
    using f1 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f8 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(141,173,175,179,197,9) HSTATE_invariant3 hstate_invariants(14,2,24) i347
    nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f5: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f6: "HSTATE ModifiedM T ∨ HSTATE SAD T ∨ HSTATE MAD T ∨ HSTATE MD T ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE SMAD T 0"
    using i347 by moura
  have f7: "ModifiedM ≠ SD"
    using HOST_State.distinct(9) by moura
  have f8: "SAD ≠ SD"
    using HOST_State.distinct(141) by moura
  have f9: "SD ≠ MAD"
    using HOST_State.distinct(175) by moura
  have f10: "SD ≠ MD"
    using HOST_State.distinct(179) by moura
  have f11: "SD ≠ ID"
    using HOST_State.distinct(173) by moura
  have f12: "SD ≠ IB"
    using HOST_State.distinct(197) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f5 by metis
  then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    using f12 f11 f10 f9 f8 f7 f6 f4 f3 f2 by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3 HSTATE_ISADData
    MESI_State.distinct(9) i23) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
METHOD Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def IMADGO'_HSTATE IMADGO'_nextReqIs IMADGO'_nextSnpRespIs i14 nextGOPending_DeviceIMADGO
    nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextSnpRespIs by moura
  then have f5: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  then have f7: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    using f6 f5 f4 f3 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f8 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def H_msg_P_same_def ISADGO'_nextReqIs ISADGO'_nextSnpRespIs hstate_invariants(14,2,24)
    i14 i15 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f1 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f5: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f1 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextSnpRespIs by moura
  then have f6: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f3 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextReqIs by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f3 by metis
  have f8: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f9: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f10: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f2 by metis
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f3 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f10 f9 f8 f7 f6 f5 f4 f1 by metis
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f11 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f11 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f11 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f11 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HOST_State.distinct(107,143,149,167,219,289,375,77) HSTATE_invariant3 HSTATE_rule_3 i333)

Isar proof:
proof -
  have f1: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T) ∨ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE SAD T"
    by auto
  have f2: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 = HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr242 veriT_vr243) ∨ ¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    by auto
  have "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ])) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. ¬ HSTATE veriT_vr242 ( veriT_vr243 [ 0 s= veriT_vr244] [ 0 :=dd veriT_vr245] [ 0 -=devd ]) ∨ HSTATE veriT_vr242 veriT_vr243)"
    by auto
  then have "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ])) ∨ ¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    using f1 f2 f3 by metis
  then have f4: "¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
    by (metis HSTATE_rule_3)
  have f5: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ HSTATE SAD T ∧ MB ≠ SB ∧ MB ≠ SB ∧ SAD ≠ SB ∧ HSTATE SB T"
    by auto
  have f6: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have f7: "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  have f8: "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149 ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have f9: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f5 f6 f7 by metis
  have "HSTATE SAD T ∧ MB ≠ SB ∧ SAD ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f10: "HSTATE SAD T ∧ MB ≠ SB ∧ SAD ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE SAD T ∨ ¬ HSTATE SB T"
    by (metis HOST_State.distinct(167,375))
  have f11: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ HSTATE SAD T ∧ MA ≠ IB ∧ MA ≠ IB ∧ SAD ≠ MA ∧ HSTATE MA T"
    by auto
  have f12: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f13: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f11 f12 f8 by metis
  have "HSTATE SAD T ∧ MA ≠ IB ∧ SAD ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f14: "HSTATE SAD T ∧ MA ≠ IB ∧ SAD ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE SAD T ∨ ¬ HSTATE MA T"
    by (metis HOST_State.distinct(149,289))
  have f15: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) ∨ HSTATE SAD T ∧ MB ≠ SA ∧ MB ≠ SA ∧ SAD ≠ SA ∧ HSTATE SA T"
    by auto
  have f16: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f17: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    using f15 f16 f8 by metis
  have f18: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE SAD T ∧ SharedM ≠ IB ∧ SharedM ≠ IB ∧ SAD ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have f19: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f20: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    using f18 f19 f8 by metis
  have f21: "¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ (¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T) = (¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T)"
    by auto
  have "¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f22: "¬ HSTATE SAD T ∨ MB = SB ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f21 by metis
  have f23: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ HSTATE SAD T ∧ MB ≠ SB ∧ SAD ≠ SB ∧ HSTATE SB T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    using f22 f23 f9 by metis
  then have f24: "¬ HSTATE SAD T ∨ MB = SB ∨ SAD = SB ∨ ¬ HSTATE SB T"
    by (metis HSTATE_invariant3)
  have f25: "¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ (¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T) = (¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T)"
    by auto
  have "¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f26: "¬ HSTATE SAD T ∨ MA = IB ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f25 by metis
  have f27: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ HSTATE SAD T ∧ MA ≠ IB ∧ SAD ≠ MA ∧ HSTATE MA T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    using f26 f27 f13 by metis
  then have f28: "¬ HSTATE SAD T ∨ MA = IB ∨ SAD = MA ∨ ¬ HSTATE MA T"
    by (metis HSTATE_invariant3)
  have f29: "¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T ⟶ (¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) = (¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T)"
    by auto
  have "¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f30: "¬ HSTATE SAD T ∨ MB = SA ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    using f29 by metis
  have f31: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) ∨ HSTATE SAD T ∧ MB ≠ SA ∧ SAD ≠ SA ∧ HSTATE SA T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    using f30 f31 f17 by metis
  then have f32: "¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
    by (metis HSTATE_invariant3)
  have f33: "¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T ⟶ (¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T) = (¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T)"
    by auto
  have "¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f34: "¬ HSTATE SAD T ∨ SharedM = IB ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    using f33 by metis
  have f35: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE SAD T ∧ SharedM ≠ IB ∧ SAD ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    using f34 f35 f20 by metis
  then have f36: "¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    by (metis HSTATE_invariant3)
  have "HSTATE SAD T ∧ SharedM ≠ IB ∧ SAD ≠ SharedM ∧ HSTATE SharedM T ∨ ¬ HSTATE SAD T ∨ SharedM = IB ∨ SAD = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have "¬ HSTATE SharedM T ∨ ¬ HSTATE SAD T"
    using f36 by (metis HOST_State.distinct(107,77))
  moreover
  { assume aa1: "¬ HSTATE SharedM T"
    have "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T ∨ HSTATE SharedM T ∨ HSTATE SA T ∨ HSTATE MA T ∨ HSTATE SB T"
      by auto
    then have "HSTATE SA T ∨ HSTATE MA T ∨ HSTATE SB T ∨ ¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      using aa1 by metis
    moreover
    { assume "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      then have fff1: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by (metis i333)
      have "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by auto
      then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
        using fff1 by metis }
    moreover
    { assume "HSTATE SB T"
      then have "¬ HSTATE SAD T"
        using f24 f10 by metis }
    moreover
    { assume "HSTATE MA T"
      then have "¬ HSTATE SAD T"
        using f28 f14 by metis }
    moreover
    { assume "HSTATE SA T"
      then have fff1: "(¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T) ∧ HSTATE SA T"
        using f32 by metis
      have "HSTATE SAD T ∧ MB ≠ SA ∧ SAD ≠ SA ∧ HSTATE SA T ∨ ¬ HSTATE SAD T ∨ MB = SA ∨ SAD = SA ∨ ¬ HSTATE SA T"
        by auto
      then have "¬ HSTATE SAD T"
        using fff1 by (metis HOST_State.distinct(143,219)) }
    ultimately have "HSTATE SAD T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have "HSTATE SAD T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE SAD T"
    have "HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE SAD T ∨ ¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE SAD T"
      by auto
    then have ff2: "¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      using aa1 f4 by metis
    have ff3: "(HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f37: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  have f38: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  have f39: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ (HSTATE SAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    using f37 f38 f39 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_otherside_rule_4_0 CSTATE_remove_op MESI_State.distinct(39)
    SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5 i844 nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have f3: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_4_0 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n na. CSTATE m (t [ -=i n]) na ∨ ¬ CSTATE m t na"
    using CSTATE_remove_op by moura
  have f7: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f8: "Modified ≠ SMD"
    using MESI_State.distinct(39) by moura
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f3 by metis
  then have "CSTATE SMAD T 0 ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    using f8 f7 f6 f5 f4 f2 by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_same_def IMADGO'_HSTATE IMADGO'_nextReqIs IMADGO'_nextSnpRespIs i14 i15
    nextGOPending_DeviceIMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f4: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextSnpRespIs by moura
  then have f5: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using IMADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
    using IMADGO'_HSTATE by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= IMD] [ 0 -=reqresp ])"
    using f2 by metis
  then have f7: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    using f6 f5 f4 f3 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ])"
        using aa1 f8 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def H_msg_P_same_def ISADGO'_nextReqIs ISADGO'_nextSnpRespIs hstate_invariants(14,2,24)
    i14 i15 nextGOPending_DeviceISADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f5: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextSnpRespIs by moura
  then have f6: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using ISADGO'_nextReqIs by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= ISD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have f8: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f9: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f10: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 by metis
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f10 f9 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f11 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f11 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using aa1 f11 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f11 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_disj1 CSTATE_xyad_htdd_invariant3 MESI_State.distinct(221,9))

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t n ma na. CSTATE m ( t [ 0 s= m] [ n :=dd ma] [ na -=devd ]) 0"
      using CSTATE_xyad_htdd_invariant3 by moura
    have ff3: "Modified ≠ ISA"
      using MESI_State.distinct(9) by moura
    have "ISA ≠ ISAD"
      using MESI_State.distinct(221) by moura
    then have "¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ CSTATE ISAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE ISAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
    by moura
  then show "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISAD ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_4 CSTATE_inequality_invariant IMADGO'_CSTATE_sameside
    IMADGO'_nextReqIs_invariant_not_RdOwn MESI_State.distinct(19,331) nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  { obtain zz :: "Message ⇒ Message option ⇒ Message option" where
      ff1: "∀B_x x. zz B_x x = Some B_x"
      by moura
    obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
      ff2: "∀X0. zza (Some X0) = zz X0"
      by moura
    have "∀m t. CSTATE IMD ( t⦇buffer1 := Some m⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
      using IMADGO'_CSTATE_sameside by moura
    then have ff3: "∀m t. CSTATE IMD ( buffer1_update (zz m) t [ 0 s= IMD] [ 0 -=reqresp ]) 0"
      using ff1 by metis
    have ff4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
      using CSTATE_inequality_invariant by moura
    have ff5: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ]) 0"
      using CSTATE_assign_rule_4 by moura
    have ff6: "∀X1 B_x. zza X1 B_x = X1"
      by moura
    then have ff7: "∀m z t. CSTATE m ( buffer1_update (zza z) t [ 0 s= m] [ 0 -=reqresp ]) 0"
      using ff5 by metis
    have ff8: "Modified ≠ IMD"
      using MESI_State.distinct(19) by moura
    have ff9: "IMAD ≠ IMD"
      using MESI_State.distinct(331) by moura
    have ff10: "∀z m. zza (zz m z) = zz m"
      using ff2 ff1 by metis
    have "∀m n t. m ≠ IMD ∨ ¬ CSTATE IMAD t n ∨ ¬ CSTATE m t n"
      using ff9 ff4 by metis
    then have "¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zz (nextGO T 0)) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
      using ff10 ff8 ff7 ff4 ff3 by metis
    then have "¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= IMD] [ 0 -=reqresp ]) 0"
      using ff2 by metis
    then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0"
      using ff6 by metis }
  then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE IMAD T 0 ∨ ¬ nextGOPending T 0"
    by moura
  then show "CSTATE IMAD T 0 ∧ nextGOPending T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= IMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISADData_otherside CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3 HSTATE_ISADData
    MESI_State.distinct(9) i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant ISADGO'_CSTATE_otherside ISADGO'_CSTATE_sameside
    ISADGO'_nextReqIs_invariant_not_RdOwn MESI_State.distinct(7) hstate_invariants(14,2,24) i23
    nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀B_x x. zz B_x x = Some B_x"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_x. zza X1 B_x = X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using ISADGO'_CSTATE_otherside by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz ma) t [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f1 by metis
  have "∀m t. CSTATE ISD ( t⦇buffer1 := Some m⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using ISADGO'_CSTATE_sameside by moura
  then have f5: "∀m t. CSTATE ISD ( buffer1_update (zz m) t [ 0 s= ISD] [ 0 -=reqresp ]) 0"
    using f1 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zza z) t)"
    using f2 by metis
  have f10: "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  have f11: "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "∀z m. zza (zz m z) = zz m"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    using f10 f9 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
    { have "¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using aa1 f11 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (nextGO T 0)) T [ 0 s= ISD] [ 0 -=reqresp ])"
    { have "¬ HSTATE SD ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= ISD] [ 0 -=reqresp ])"
        using aa1 f11 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ])"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISAD T 0 ∧ nextGOPending T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= ISD] [ 0 -=reqresp ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
281.872s elapsed time, 92.734s cpu time, 9.141s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SMADGO'_HSTATE i658 nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
    using SMADGO'_HSTATE by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ])"
    using f2 by metis
  have f4: "¬ nextGOPending T 0 ∨ ¬ CSTATE SMAD T 0 ∨ ¬ HSTATE SharedM T"
    using i658 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume "HSTATE SharedM T"
    then have "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      using f4 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume "¬ CSTATE SMAD T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
METHOD Future: result = timeout 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
248.045s elapsed time, 81.719s cpu time, 8.891s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISADData_otherside CSTATE_disj2 CSTATE_disj4' CSTATE_xyad_htdd_invariant3 HSTATE_ISADData
    MESI_State.distinct(15,9) i22) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(105,15) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_ISADData_otherside CSTATE_different2 CSTATE_disj4' CSTATE_inequality_invariant
    CSTATE_xyad_htdd_invariant3 C_msg_state_def MESI_State.distinct(11,9) i47 nextReqIs_ISADData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_ISAGO_IMAD_invariant CSTATE_assign_rule_2 CSTATE_remove_op CSTATE_various_forms1
    CSTATE_various_forms2 CSTATE_various_forms6 MESI_State.distinct(3) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant SharedSnpInv'_MAD_CSTATE_invariant4 devcache1_consume_reqresps1_invariant
    devcache2_buffer1_invariant devcache2_consume_reqresps1_invariant devcache2_copy_perform1_invariant i849)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "∀t. CLEntry.block_state (devcache1 t) = CLEntry.block_state (devcache1 (t [ 0 -=reqresp ]))"
    using devcache1_consume_reqresps1_invariant by moura
  have f3: "∀m t. CLEntry.block_state (devcache1 t) = m ∨ ¬ CSTATE m t 0"
    using CSTATE_various_forms1 by moura
  have f4: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have "∀t m. devcache2 ((t::Type1State)⦇buffer1 := Some m⦈) = devcache2 t"
    using devcache2_buffer1_invariant by moura
  then have f5: "∀t m. devcache2 (buffer1_update (zz (Some m)) (t::Type1State)) = devcache2 t"
    using f1 by metis
  have f6: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f7: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have f8: "∀m t. CLEntry.block_state (devcache2 t) = m ∨ ¬ CSTATE m t 1"
    using CSTATE_various_forms6 by moura
  have f9: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f10: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f11: "∀t. devcache2 (t [ -=i 0]) = devcache2 t"
    using devcache2_copy_perform1_invariant by moura
  have f12: "∀t. devcache2 (t [ 0 -=reqresp ]) = devcache2 t"
    using devcache2_consume_reqresps1_invariant by moura
  have "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (t⦇buffer1 := Some ma⦈) n"
    using SharedSnpInv'_MAD_CSTATE_invariant by moura
  then have f13: "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (buffer1_update (zz (Some ma)) t) n"
    using f1 by metis
  have f14: "¬ CSTATE Shared T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE SMA T 0"
    using i849 by moura
  have f15: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f16: "∀X0. zz (Some X0) = x_l_lift1 X0"
    by moura
  then have f17: "∀t m. devcache2 (buffer1_update (x_l_lift1 m) (t::Type1State)) = devcache2 t"
    using f5 by metis
  have "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (buffer1_update (x_l_lift1 ma) t) n"
    using f13 f16 by metis
  then have "CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared ∨ CSTATE Shared T 1"
    using f17 f15 f10 f9 f8 f7 f6 f4 f3 f2 by metis
  moreover
  { assume "CSTATE Shared T 1"
    then have "¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      using f14 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume "¬ CSTATE SMA T 0"
      then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "CLEntry.block_state (devcache1 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared"
    { have "CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using aa1 f12 f11 f16 by metis
      then have "CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using f1 by metis }
    then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared"
    { have "CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using aa1 f12 f11 f16 by metis
      then have "CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using f1 by metis }
    then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared)"
    by metis
next 
Done 
METHOD Future: starting 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(15,187) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
METHOD Future: starting 
zipperposition: Try this:
  apply (metis SMADGO'_HSTATE i658 nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
    using SMADGO'_HSTATE by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ])"
    using f2 by metis
  have f4: "¬ nextGOPending T 0 ∨ ¬ CSTATE SMAD T 0 ∨ ¬ HSTATE SharedM T"
    using i658 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume "HSTATE SharedM T"
    then have "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      using f4 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume "¬ CSTATE SMAD T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 MESI_State.distinct(15)
    SharedSnpInv'_CSTATE_invariant5 i844 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f3: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ IMAD"
    using MESI_State.distinct(15) by moura
  then have "CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    using f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    { have "¬ CSTATE SMAD T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HOST_State.distinct(107,11,17,203,287,289,3,35) HSTATE_invariant3 HSTATE_rule_3 i333)

Isar proof:
proof -
  have f1: "((∃veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. HSTATE veriT_vr276 veriT_vr277 ≠ HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. HSTATE veriT_vr276 veriT_vr277 ≠ HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. HSTATE veriT_vr276 veriT_vr277 = HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr276 veriT_vr277) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. HSTATE veriT_vr276 veriT_vr277 ≠ HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ])) ∨ (∀veriT_vr276 veriT_vr277 veriT_vr278 veriT_vr279. ¬ HSTATE veriT_vr276 ( veriT_vr277 [ 0 s= veriT_vr278] [ 0 :=dd veriT_vr279] [ 0 -=devd ]) ∨ HSTATE veriT_vr276 veriT_vr277)"
    by auto
  then have "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  then have f4: "¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by (metis HSTATE_rule_3)
  have f5: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ HSTATE ModifiedM T ∧ MA ≠ SB ∧ MA ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T"
    by auto
  have f6: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have f7: "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by auto
  have f8: "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149 ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have f9: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f5 f6 f7 by metis
  have "HSTATE ModifiedM T ∧ MA ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f10: "HSTATE ModifiedM T ∧ MA ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE SB T"
    by (metis HOST_State.distinct(287,35))
  have f11: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ HSTATE ModifiedM T ∧ MA ≠ SA ∧ MA ≠ SA ∧ ModifiedM ≠ SA ∧ HSTATE SA T"
    by auto
  have f12: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f13: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f11 f12 f8 by metis
  have "HSTATE ModifiedM T ∧ MA ≠ SA ∧ ModifiedM ≠ SA ∧ HSTATE SA T ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f14: "HSTATE ModifiedM T ∧ MA ≠ SA ∧ ModifiedM ≠ SA ∧ HSTATE SA T ∨ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE SA T"
    by (metis HOST_State.distinct(11,203))
  have f15: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ HSTATE ModifiedM T ∧ MA ≠ IB ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T"
    by auto
  have f16: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f17: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f15 f16 f8 by metis
  have "HSTATE ModifiedM T ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f18: "HSTATE ModifiedM T ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE MA T"
    by (metis HOST_State.distinct(17,289))
  have f19: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE ModifiedM T ∧ SharedM ≠ IB ∧ SharedM ≠ IB ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have f20: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  have "(∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. HSTATE veriT_vr148 veriT_vr146 ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149 ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f21: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f19 f20 f8 by metis
  have f22: "¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ (¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) = (¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f23: "¬ HSTATE ModifiedM T ∨ MA = SB ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f22 by metis
  have f24: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ HSTATE ModifiedM T ∧ MA ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f23 f24 f9 by metis
  then have f25: "¬ HSTATE ModifiedM T ∨ MA = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by (metis HSTATE_invariant3)
  have f26: "¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ (¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) = (¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f27: "¬ HSTATE ModifiedM T ∨ MA = SA ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f26 by metis
  have f28: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ HSTATE ModifiedM T ∧ MA ≠ SA ∧ ModifiedM ≠ SA ∧ HSTATE SA T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f27 f28 f13 by metis
  then have f29: "¬ HSTATE ModifiedM T ∨ MA = SA ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by (metis HSTATE_invariant3)
  have f30: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ (¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) = (¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f31: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f30 by metis
  have f32: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ HSTATE ModifiedM T ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f31 f32 f17 by metis
  then have f33: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by (metis HSTATE_invariant3)
  have f34: "¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ (¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) = (¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f35: "¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f34 by metis
  have f36: "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE ModifiedM T ∧ SharedM ≠ IB ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have "((∃veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. ((HSTATE veriT_vr145 veriT_vr146 ∨ HSTATE veriT_vr147 veriT_vr146 ∨ HSTATE veriT_vr148 veriT_vr146) ∧ veriT_vr145 ≠ veriT_vr149 ∧ veriT_vr147 ≠ veriT_vr149 ∧ veriT_vr148 ≠ veriT_vr149) ∧ HSTATE veriT_vr149 veriT_vr146) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr145 veriT_vr146 veriT_vr147 veriT_vr148 veriT_vr149. (¬ HSTATE veriT_vr145 veriT_vr146 ∧ ¬ HSTATE veriT_vr147 veriT_vr146 ∧ ¬ HSTATE veriT_vr148 veriT_vr146 ∨ veriT_vr145 = veriT_vr149 ∨ veriT_vr147 = veriT_vr149 ∨ veriT_vr148 = veriT_vr149) ∨ ¬ HSTATE veriT_vr149 veriT_vr146)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f35 f36 f21 by metis
  then have f37: "¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by (metis HSTATE_invariant3)
  have "HSTATE ModifiedM T ∧ SharedM ≠ IB ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T ∨ ¬ HSTATE ModifiedM T ∨ SharedM = IB ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have "¬ HSTATE SharedM T ∨ ¬ HSTATE ModifiedM T"
    using f37 by (metis HOST_State.distinct(107,3))
  moreover
  { assume aa1: "¬ HSTATE SharedM T"
    have "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T ∨ HSTATE SharedM T ∨ HSTATE SA T ∨ HSTATE MA T ∨ HSTATE SB T"
      by auto
    then have "HSTATE MA T ∨ HSTATE SA T ∨ HSTATE SB T ∨ ¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      using aa1 by metis
    moreover
    { assume "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      then have fff1: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by (metis i333)
      have "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by auto
      then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
        using fff1 by metis }
    moreover
    { assume "HSTATE SB T"
      then have "¬ HSTATE ModifiedM T"
        using f25 f10 by metis }
    moreover
    { assume "HSTATE SA T"
      then have "¬ HSTATE ModifiedM T"
        using f29 f14 by metis }
    moreover
    { assume "HSTATE MA T"
      then have "¬ HSTATE ModifiedM T"
        using f33 f18 by metis }
    ultimately have "HSTATE ModifiedM T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have "HSTATE ModifiedM T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM T"
    have "HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
      by auto
    then have ff2: "¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      using aa1 f4 by metis
    have ff3: "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f38: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by metis
  have f39: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) = (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0))"
    by auto
  have f40: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) ∨ (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)) = ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0)"
    using f38 f39 f40 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(39) SMADGO'_CSTATE_otherside SMADGO'_CSTATE_sameside
    i12 i844 nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ CSTATE Modified X1 B_X)"
    by moura
  have f4: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1"
    using SMADGO'_CSTATE_otherside by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= SMD] [ 0 -=reqresp ]) 1"
    using f2 by metis
  have "∀m t. CSTATE SMD ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    using SMADGO'_CSTATE_sameside by moura
  then have f6: "∀m t. CSTATE SMD ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    using f2 by metis
  have f7: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f8: "Modified ≠ SMD"
    using MESI_State.distinct(39) by moura
  have "∀n t m. m = Modified ∨ ¬ CSTATE m t n ∨ bb t n"
    using f7 f3 by metis
  then have "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ CSTATE Modified T 1"
    using f8 f6 f3 f5 by metis
  moreover
  { assume aa1: "CSTATE Modified T 1"
    { have "¬ CSTATE SMAD T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 MESI_State.distinct(15)
    SharedSnpInv'_CSTATE_invariant5 i844 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f3: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ IMAD"
    using MESI_State.distinct(15) by moura
  then have "CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    using f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    { have "¬ CSTATE SMAD T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_otherside_rule_5_0 i546 i921 nextHTDDataPending_otherside_rule_2_0
    nextHTDDataPending_various_forms1)

Isar proof:
proof -
  have f1: "((∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f2: "((∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1505. nextHTDDataPending veriT_vr1505 0 = ([] ≠ htddatas1 veriT_vr1505))"
    by auto
  have f3: "(∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ∧ [] = htddatas1 veriT_vr1505) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ (∀veriT_vr1505. ¬ nextHTDDataPending veriT_vr1505 0 ∨ [] ≠ htddatas1 veriT_vr1505)"
    by auto
  then have f4: "(∃t. nextHTDDataPending t 0 ≠ ([] ≠ htddatas1 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f6: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr38 veriT_vr39 1)"
    by auto
  have f7: "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. ¬ CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr38 veriT_vr39 1)"
    by auto
  then have f8: "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f5 f6 f7 by metis
  have f9: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f4 by (metis nextHTDDataPending_various_forms1)
  have f10: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f8 by (metis CSTATE_otherside_rule_5_0)
  have f11: "((∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1) ∨ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending T 1"
    by auto
  have f12: "((∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1) ∨ (∀veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 = nextHTDDataPending veriT_vr17 1)"
    by auto
  have f13: "(∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by auto
  have "(∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ (∀veriT_vr17 veriT_vr18 veriT_vr19. ¬ nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending veriT_vr17 1)"
    by auto
  then have "(∃t m ma. nextHTDDataPending ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending t 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    using f11 f12 f13 by metis
  then have f14: "¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by (metis nextHTDDataPending_otherside_rule_2_0)
  have "nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by auto
  then have "nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ nextHTDDataPending T 1"
    using f14 by metis
  moreover
  { assume aa1: "nextHTDDataPending T 1"
    have "(CSTATE ISA T 1 ∨ nextHTDDataPending T 1) ∨ ¬ nextHTDDataPending T 1"
      by auto
    then have "CSTATE ISA T 1 ∨ nextHTDDataPending T 1"
      using aa1 by metis
    then have ff2: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by (metis i546)
    have "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by auto
    then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      using ff2 by metis }
  moreover
  { assume aa1: "¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have ff2: "¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis
    have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff2 by metis
    then have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using f10 by metis
      have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "[] = htddatas1 T"
        by (metis i921)
      then have fff3: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f9 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff3 by metis }
    ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f15: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f16: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f17: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f15 f16 f17 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_msg_state_def H_msg_P_oppo_def MESI_State.distinct(281) SMADGO'_HSTATE
    SMADGO'_nextDTHDataPending SMADGO'_nextReqIs i13 i47 nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextDTHDataPending by moura
  then have f5: "∀t n m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
    using SMADGO'_HSTATE by moura
  then have f7: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ])"
    using f2 by metis
  have f8: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f9: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f10: "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have "ISAD ≠ SMAD"
    using MESI_State.distinct(281) by moura
  then have "∀m n t. m ≠ SMAD ∨ ¬ CSTATE ISAD t n ∨ ¬ CSTATE m t n"
    using f8 by metis
  then have f11: "CSTATE SMAD T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    using f10 f9 f7 f6 f5 f4 f3 by metis
  have f12: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f12 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f12 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 f12 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    using f11 by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(15,261) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_msg_state_def H_msg_P_oppo_def H_msg_P_same_def
    MESI_State.distinct(167,347) SMADGO'_HSTATE SMADGO'_nextReqIs SMADGO'_nextSnpRespIs i14 i15 i419 i456 i47 i744 i778
    i844 i902 i904 i906 i908 i910 i913 nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f4: "¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE SMAD T 0"
    using i913 by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f5: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f1 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f6: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f1 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextSnpRespIs by moura
  then have f7: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f3 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextReqIs by moura
  then have f8: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f3 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
    using SMADGO'_HSTATE by moura
  then have f9: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ])"
    using f3 by metis
  have f10: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f11: "¬ CSTATE ISDI T 0 ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T"
    using i778 by moura
  have f12: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMAD T 1"
    using i910 by moura
  have f13: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i906 by moura
  have f14: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i908 by moura
  have f15: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have f16: "¬ nextGOPending T 0 ∨ ¬ CSTATE SMAD T 0 ∨ ¬ CSTATE MIA T 1"
    using i744 by moura
  have f17: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMD T 1"
    using i902 by moura
  have f18: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMD T 1"
    using i904 by moura
  have f19: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f20: "CSTATE ISDI T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE Invalid T 0 ∨ ¬ nextSnpRespIs RspIFwdM T 0"
    using i456 by moura
  have f21: "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have f22: "∀r t m. ¬ nextReqIs r t 1 ∨ CSTATE m t 1 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have f23: "Invalid ≠ SMAD"
    using MESI_State.distinct(167) by moura
  have f24: "IMAD ≠ SMAD"
    using MESI_State.distinct(347) by moura
  have f25: "∀m n t. m ≠ SMAD ∨ ¬ CSTATE m t n ∨ ¬ CSTATE Invalid t n"
    using f23 f10 by metis
  have "∀m n t. IMAD ≠ m ∨ ¬ CSTATE SMAD t n ∨ ¬ CSTATE m t n"
    using f24 f10 by metis
  then have f26: "CSTATE SMAD T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ CSTATE SMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMA T 1 ∨ nextGOPending T 1 ∧ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE IMD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE SMD T 1 ∨ ¬ CSTATE IMAD T 1 ∧ zip_tseitin_19 ∨ ¬ zip_tseitin_17 ∧ ¬ zip_tseitin_18 ∧ ¬ zip_tseitin_19 ∧ HSTATE ModifiedM T ∧ CSTATE IIA T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ (∃m. m ≠ SMAD ∧ CSTATE m T 0)"
    using f25 f22 f21 f20 f19 f11 f9 f8 f7 f6 f5 f1 by metis
  have f27: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "nextGOPending T 1 ∧ CSTATE IMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f12 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f13 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f14 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE IMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f17 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE SMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f18 by metis }
  moreover
  { assume "¬ CSTATE IMAD T 1 ∧ zip_tseitin_19"
    then have "CSTATE SMAD T 1"
      by metis }
  moreover
  { assume "¬ zip_tseitin_17 ∧ ¬ zip_tseitin_18 ∧ ¬ zip_tseitin_19 ∧ HSTATE ModifiedM T ∧ CSTATE IIA T 0"
    then have "CSTATE MIA T 1 ∨ CSTATE Modified T 1"
      by metis
    moreover
    { assume "CSTATE Modified T 1"
      then have "¬ CSTATE SMAD T 0"
        using f15 by metis }
    moreover
    { assume "CSTATE MIA T 1"
      then have "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
        using f16 by metis }
    ultimately have "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f27 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f27 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1"
        using aa1 f27 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 f27 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using f2 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "∃m. m ≠ SMAD ∧ CSTATE m T 0"
    then have "¬ CSTATE SMAD T 0"
      using f10 by metis }
  ultimately have "nextGOPending T 0 ∧ CSTATE SMAD T 0 ⟶ ((¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0) ∨ CSTATE SMAD T 1"
    using f26 by metis
  moreover
  { assume "CSTATE SMAD T 1"
    then have "CSTATE SMAD T 0 ⟶ CSTATE SMAD T 1 ∧ CSTATE SMAD T 0"
      by metis
    moreover
    { assume "CSTATE SMAD T 1 ∧ CSTATE SMAD T 0"
      then have "¬ nextGOPending T 0"
        using f4 by metis }
    ultimately have "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  ultimately have "nextGOPending T 0 ∧ CSTATE SMAD T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) HOST_State.distinct(103,11,17,223,289,3,35,375) HSTATE_invariant3 HSTATE_rule_3 i333 i731
    nextSnpRespIs_general_rule_5_0 nextSnpRespIs_property1)

Isar proof:
proof -
  have f1: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f2: "((∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 = nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  have f3: "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∧ ¬ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ≠ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329) ∨ (∀veriT_vr325 veriT_vr326 veriT_vr327 veriT_vr328 veriT_vr329. ¬ nextSnpRespIs veriT_vr325 ( veriT_vr326 [ 0 s= veriT_vr327] [ 0 :=dd veriT_vr328] [ 0 -=devd ]) veriT_vr329 ∨ nextSnpRespIs veriT_vr325 veriT_vr326 veriT_vr329)"
    by auto
  then have f4: "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f6: "((∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 = HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]))"
    by auto
  have f7: "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr280 veriT_vr281) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. HSTATE veriT_vr280 veriT_vr281 ≠ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ])) ∨ (∀veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ HSTATE veriT_vr280 ( veriT_vr281 [ 0 s= veriT_vr282] [ 0 :=dd veriT_vr283] [ 0 -=devd ]) ∨ HSTATE veriT_vr280 veriT_vr281)"
    by auto
  then have f8: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f5 f6 f7 by metis
  have f9: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f4 by (metis nextSnpRespIs_general_rule_5_0)
  have f10: "¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f8 by (metis HSTATE_rule_3)
  have f11: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ HSTATE ModifiedM T ∧ MB ≠ SB ∧ MB ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T"
    by auto
  have f12: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  have f13: "(∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. HSTATE veriT_vr144 veriT_vr142 ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145 ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by auto
  have f14: "(∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145 ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  then have f15: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f11 f12 f13 by metis
  have f16: "((∃veriT_vr946 veriT_vr947. nextSnpRespIs veriT_vr946 veriT_vr947 0 ∧ [] = snpresps1 veriT_vr947) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T"
    by auto
  have f17: "((∃veriT_vr946 veriT_vr947. nextSnpRespIs veriT_vr946 veriT_vr947 0 ∧ [] = snpresps1 veriT_vr947) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ (∀veriT_vr946 veriT_vr947. ¬ nextSnpRespIs veriT_vr946 veriT_vr947 0 ∨ [] ≠ snpresps1 veriT_vr947)"
    by auto
  have f18: "(∃veriT_vr946 veriT_vr947. nextSnpRespIs veriT_vr946 veriT_vr947 0 ∧ [] = snpresps1 veriT_vr947) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  have "(∃veriT_vr946 veriT_vr947. nextSnpRespIs veriT_vr946 veriT_vr947 0 ∧ [] = snpresps1 veriT_vr947) ∨ (∀veriT_vr946 veriT_vr947. ¬ nextSnpRespIs veriT_vr946 veriT_vr947 0 ∨ [] ≠ snpresps1 veriT_vr947)"
    by auto
  then have f19: "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f16 f17 f18 by (metis nextSnpRespIs_property1)
  have f20: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE ModifiedM T ∧ MB ≠ SharedM ∧ MB ≠ SharedM ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have f21: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  have "(∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. HSTATE veriT_vr144 veriT_vr142 ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145 ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f22: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f20 f21 f14 by metis
  have f23: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ HSTATE ModifiedM T ∧ SA ≠ IB ∧ SA ≠ IB ∧ ModifiedM ≠ SA ∧ HSTATE SA T"
    by auto
  have f24: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  have "(∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. HSTATE veriT_vr144 veriT_vr142 ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145 ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f25: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f23 f24 f14 by metis
  have f26: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ HSTATE ModifiedM T ∧ MA ≠ IB ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T"
    by auto
  have f27: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  have "(∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. HSTATE veriT_vr144 veriT_vr142 ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145 ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f28: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f26 f27 f14 by metis
  have f29: "¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ (¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) = (¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by auto
  then have f30: "¬ HSTATE ModifiedM T ∨ MB = SB ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T ⟶ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f29 by metis
  have f31: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ HSTATE ModifiedM T ∧ MB ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T"
    by auto
  have "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    using f30 f31 f15 by metis
  then have f32: "¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
    by (metis HSTATE_invariant3)
  have f33: "¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ (¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) = (¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by auto
  then have f34: "¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T ⟶ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f33 by metis
  have f35: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ HSTATE ModifiedM T ∧ MB ≠ SharedM ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T"
    by auto
  have "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    using f34 f35 f22 by metis
  then have f36: "¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
    by (metis HSTATE_invariant3)
  have f37: "¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ (¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) = (¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by auto
  then have f38: "¬ HSTATE ModifiedM T ∨ SA = IB ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T ⟶ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f37 by metis
  have f39: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ HSTATE ModifiedM T ∧ SA ≠ IB ∧ ModifiedM ≠ SA ∧ HSTATE SA T"
    by auto
  have "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    using f38 f39 f25 by metis
  then have f40: "¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
    by (metis HSTATE_invariant3)
  have f41: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ (¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) = (¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T)"
    by auto
  have "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have f42: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T ⟶ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f41 by metis
  have f43: "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ HSTATE ModifiedM T ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T"
    by auto
  have "((∃veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. ((HSTATE veriT_vr141 veriT_vr142 ∨ HSTATE veriT_vr143 veriT_vr142 ∨ HSTATE veriT_vr144 veriT_vr142) ∧ veriT_vr141 ≠ veriT_vr145 ∧ veriT_vr143 ≠ veriT_vr145 ∧ veriT_vr144 ≠ veriT_vr145) ∧ HSTATE veriT_vr145 veriT_vr142) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T) ∨ (∀veriT_vr141 veriT_vr142 veriT_vr143 veriT_vr144 veriT_vr145. (¬ HSTATE veriT_vr141 veriT_vr142 ∧ ¬ HSTATE veriT_vr143 veriT_vr142 ∧ ¬ HSTATE veriT_vr144 veriT_vr142 ∨ veriT_vr141 = veriT_vr145 ∨ veriT_vr143 = veriT_vr145 ∨ veriT_vr144 = veriT_vr145) ∨ ¬ HSTATE veriT_vr145 veriT_vr142)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    using f42 f43 f28 by metis
  then have f44: "¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by (metis HSTATE_invariant3)
  have "HSTATE ModifiedM T ∧ MA ≠ IB ∧ ModifiedM ≠ MA ∧ HSTATE MA T ∨ ¬ HSTATE ModifiedM T ∨ MA = IB ∨ ModifiedM = MA ∨ ¬ HSTATE MA T"
    by auto
  then have "¬ HSTATE MA T ∨ ¬ HSTATE ModifiedM T"
    using f44 by (metis HOST_State.distinct(17,289))
  moreover
  { assume aa1: "¬ HSTATE MA T"
    have "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T ∨ HSTATE SharedM T ∨ HSTATE SA T ∨ HSTATE MA T ∨ HSTATE SB T"
      by auto
    then have "HSTATE SA T ∨ HSTATE SharedM T ∨ HSTATE SB T ∨ ¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      using aa1 by metis
    moreover
    { assume "¬ HSTATE SharedM T ∧ ¬ HSTATE SA T ∧ ¬ HSTATE MA T ∧ ¬ HSTATE SB T"
      then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by (metis i333) }
    moreover
    { assume "HSTATE SB T"
      then have fff1: "(¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T) ∧ HSTATE SB T"
        using f32 by metis
      have "HSTATE ModifiedM T ∧ MB ≠ SB ∧ ModifiedM ≠ SB ∧ HSTATE SB T ∨ ¬ HSTATE ModifiedM T ∨ MB = SB ∨ ModifiedM = SB ∨ ¬ HSTATE SB T"
        by auto
      then have "¬ HSTATE ModifiedM T"
        using fff1 by (metis HOST_State.distinct(35,375)) }
    moreover
    { assume "HSTATE SharedM T"
      then have fff1: "(¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T) ∧ HSTATE SharedM T"
        using f36 by metis
      have "HSTATE ModifiedM T ∧ MB ≠ SharedM ∧ ModifiedM ≠ SharedM ∧ HSTATE SharedM T ∨ ¬ HSTATE ModifiedM T ∨ MB = SharedM ∨ ModifiedM = SharedM ∨ ¬ HSTATE SharedM T"
        by auto
      then have "¬ HSTATE ModifiedM T"
        using fff1 by (metis HOST_State.distinct(103,3)) }
    moreover
    { assume "HSTATE SA T"
      then have fff1: "(¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T) ∧ HSTATE SA T"
        using f40 by metis
      have "HSTATE ModifiedM T ∧ SA ≠ IB ∧ ModifiedM ≠ SA ∧ HSTATE SA T ∨ ¬ HSTATE ModifiedM T ∨ SA = IB ∨ ModifiedM = SA ∨ ¬ HSTATE SA T"
        by auto
      then have "¬ HSTATE ModifiedM T"
        using fff1 by (metis HOST_State.distinct(11,223)) }
    ultimately have "HSTATE ModifiedM T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
      by metis }
  ultimately have "HSTATE ModifiedM T ⟶ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM T"
    have "HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
      by auto
    then have ff2: "¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      using aa1 f10 by metis
    have "(¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ])"
      by auto
    then have ff3: "¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      using ff2 by metis
    have "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1"
      using ff3 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
      have "(HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "nextSnpRespIs RspIFwdM T 0"
        using fff2 f9 by metis
      then have fff3: "(¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∧ nextSnpRespIs RspIFwdM T 0"
        using f19 by metis
      have "nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
        by auto
      then have "[] ≠ snpresps1 T"
        using fff3 by metis
      then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
        by (metis i731) }
    ultimately have "(¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have "(¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
    have "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0"
      by auto
    then have "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
      using aa1 by metis }
  ultimately have f45: "¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by metis
  have f46: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  have f47: "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE ISAD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) ∨ (CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)) = ((CSTATE ISAD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE ISAD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 0) ∧ (HSTATE ModifiedM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= ISA] [ 0 :=dd getHTDDataOrMakeup T 0] [ 0 -=devd ]) 1)"
    using f45 f46 f47 by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_otherside_rule_19 C_msg_state_def SMADSnpInv_nextReqIs i396 i47 i494 i844
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f3: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f4: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( t ⦇buffer1 := z⦈ [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using SMADSnpInv_nextReqIs by moura
  then have f5: "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using f1 by metis
  have f6: "¬ CSTATE ISAD T 0 ∨ ¬ nextReqIs RdOwn T 0"
    using i494 by moura
  have f7: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  then have "CSTATE ISAD T 0 ∨ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    using f7 f5 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE SMAD T 0"
      using f2 by metis }
  moreover
  { assume "CSTATE ISAD T 0"
    then have "¬ nextReqIs RdOwn T 0"
      using f6 by metis
    then have "¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f4 by metis
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by moura }
    moreover
    { assume "¬ CXL_SPG_used T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by moura }
    ultimately have "CSTATE SMAD T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  ultimately have "CSTATE SMAD T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_same_def SMADGO'_HSTATE SMADGO'_nextReqIs SMADGO'_nextSnpRespIs i14 i15
    nextGOPending_DeviceSMADGO nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f4: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextSnpRespIs by moura
  then have f5: "∀s t n m. nextSnpRespIs s t n ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using SMADGO'_nextReqIs by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
    using SMADGO'_HSTATE by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ])"
    using f2 by metis
  then have f7: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    using f6 f5 f4 f3 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using aa1 f8 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ])"
        using aa1 f8 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_xyad_htdd_invariant3 MESI_State.distinct(9) i494
    nextReqIs_ISADData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
248.795s elapsed time, 74.812s cpu time, 5.719s GC time 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_msg_not_def C_msg_state_def HSTATE_invariant_ModifiedSnpInv
    SMADSnpInv_nextReqIs i25 i396 i47 i494 i508 i653 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "C_msg_not RdShared IMAD T"
    using i25 by moura
  have f3: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( t ⦇buffer1 := z⦈ [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using SMADSnpInv_nextReqIs by moura
  then have f5: "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using f1 by metis
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f6: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f7: "∀r t m. ¬ nextReqIs r t 1 ∨ ¬ CSTATE m t 1 ∨ ¬ C_msg_not r m t"
    using C_msg_not_def by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    using i508 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f10: "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f11: "¬ CSTATE ISAD T 0 ∨ ¬ nextReqIs RdOwn T 0"
    using i494 by moura
  have f12: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f13: "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have "∀r t m. ¬ nextReqIs r t 1 ∨ CSTATE m t 1 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  then have "CSTATE SMAD T 0 ∧ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ CSTATE ISAD T 0 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ (∃m n t. CSTATE m T 0 ∧ CSTATE m t n ∧ CSTATE ISAD t n)"
    using f13 f12 f10 f9 f7 f6 f5 f2 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
    { have "¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f8 by metis }
  moreover
  { assume "∃m n t. CSTATE m T 0 ∧ CSTATE m t n ∧ CSTATE ISAD t n"
    then have "CSTATE ISAD T 0"
      using f4 by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ ((¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0) ∨ CSTATE ISAD T 0"
    by metis
  moreover
  { assume "CSTATE ISAD T 0"
    then have "¬ nextReqIs RdOwn T 0"
      using f11 by metis
    then have "¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f3 by metis
    moreover
    { assume "¬ CXL_SPG_used T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by moura }
    ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(351,39) SMADGO'_CSTATE_sameside
    SMADGO'_nextReqIs_invariant_not_RdOwn nextGOPending_yes_reqresp_rule_6_1)

Isar proof:
proof -
  { obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
      ff1: "∀X1 B_x. zz X1 B_x = X1"
      by moura
    obtain zza :: "Message ⇒ Message option ⇒ Message option" where
      ff2: "∀B_x x. zza B_x x = Some B_x"
      by moura
    have "∀m t. CSTATE SMD ( t⦇buffer1 := Some m⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
      using SMADGO'_CSTATE_sameside by moura
    then have ff3: "∀m t. CSTATE SMD ( buffer1_update (zza m) t [ 0 s= SMD] [ 0 -=reqresp ]) 0"
      using ff2 by metis
    have ff4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
      using CSTATE_inequality_invariant by moura
    have ff5: "Modified ≠ SMD"
      using MESI_State.distinct(39) by moura
    have ff6: "IMAD ≠ SMD"
      using MESI_State.distinct(351) by moura
    have "∀m n t. m ≠ SMD ∨ ¬ CSTATE Modified t n ∨ ¬ CSTATE m t n"
      using ff5 ff4 by metis
    then have ff7: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
      using ff6 ff4 ff3 by metis
    have "∀X0. zz (Some X0) = zza X0"
      by moura
    then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= SMD] [ 0 -=reqresp ]) 0"
      using ff7 by metis
    then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0"
      using ff1 by metis }
  then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0) ∨ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0"
    by moura
  then show "CSTATE SMAD T 0 ∧ nextGOPending T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= SMD] [ 0 -=reqresp ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
270.473s elapsed time, 82.203s cpu time, 5.875s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SMAGO_otherside_invariant2 CSTATE_inequality_invariant MESI_State.distinct(11)
    SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5 i847 nextGOPending_DeviceSMAGO_other
    nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ nextGOPending T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE SMA T 0"
    using i847 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SMAGO_otherside_invariant2 by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have f5: "∀t z m. nextGOPending t 1 ∨ ¬ nextGOPending ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 1"
    using nextGOPending_yes_reqresp_rule_4_1 by moura
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f7: "∀t z m. nextGOPending t 1 ∨ ¬ nextGOPending ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f1 f5 by metis
  have f8: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f9: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f10: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f11: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have "∀z m. zz (zza m z) = zza m"
    using f6 f2 by metis
  then have "¬ nextGOPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ nextGOPending T 1 ∧ CSTATE ISAD T 1"
    using f11 f10 f9 f8 f7 f4 by metis
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE ISAD T 1"
    then have "CSTATE SMA T 0 ⟶ nextGOPending T 1 ∧ CSTATE ISAD T 1 ∧ CSTATE SMA T 0"
      by metis
    moreover
    { assume "¬ CSTATE SMA T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume aaa1: "nextGOPending T 1 ∧ CSTATE ISAD T 1 ∧ CSTATE SMA T 0"
      { have "¬ nextGOPending T 0"
          using aaa1 f3 by metis }
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE ISAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f6 by metis
      then have "¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextGOPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextGOPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f6 by metis
      then have "¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_otherside_rule_5_0 MESI_State.distinct(351,561) i352 i465 i619 i921
    nextGOPending_General_rule_4_1 nextHTDDataPending_various_forms1)

Isar proof:
proof -
  have f1: "((∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr56 veriT_vr57 1)"
    by auto
  have f3: "(∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f4: "(∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr56 veriT_vr57 1) ∨ (∀veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. ¬ CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr56 veriT_vr57 1)"
    by auto
  then have "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  then have f5: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_5_0)
  have f6: "((∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f7: "((∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1505. nextHTDDataPending veriT_vr1505 0 = ([] ≠ htddatas1 veriT_vr1505))"
    by auto
  have f8: "(∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ∧ [] = htddatas1 veriT_vr1505) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1505. nextHTDDataPending veriT_vr1505 0 ≠ ([] ≠ htddatas1 veriT_vr1505)) ∨ (∀veriT_vr1505. ¬ nextHTDDataPending veriT_vr1505 0 ∨ [] ≠ htddatas1 veriT_vr1505)"
    by auto
  then have f9: "(∃t. nextHTDDataPending t 0 ≠ ([] ≠ htddatas1 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f6 f7 f8 by metis
  have f10: "((∃veriT_vr123 veriT_vr124 veriT_vr125. (CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125) ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ CSTATE SMD T 0 ∧ SMD ≠ IMAD ∧ CSTATE IMAD T 0"
    by auto
  have f11: "((∃veriT_vr123 veriT_vr124 veriT_vr125. (CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125) ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ (∀veriT_vr123 veriT_vr124 veriT_vr125. (¬ CSTATE veriT_vr123 veriT_vr124 0 ∨ veriT_vr123 = veriT_vr125) ∨ ¬ CSTATE veriT_vr125 veriT_vr124 0)"
    by auto
  have f12: "(∃veriT_vr123 veriT_vr124 veriT_vr125. CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125 ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by auto
  have f13: "(∃veriT_vr123 veriT_vr124 veriT_vr125. (CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125) ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ (∀veriT_vr123 veriT_vr124 veriT_vr125. ¬ CSTATE veriT_vr123 veriT_vr124 0 ∨ veriT_vr123 = veriT_vr125 ∨ ¬ CSTATE veriT_vr125 veriT_vr124 0)"
    by auto
  then have f14: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    using f10 f11 f12 by metis
  have f15: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f9 by (metis nextHTDDataPending_various_forms1)
  have f16: "¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    using f14 by (metis CSTATE_different1)
  have f17: "((∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1) ∨ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE ISAD T 1"
    by auto
  have f18: "((∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1) ∨ (∀veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr56 veriT_vr57 1)"
    by auto
  have "(∃veriT_vr56 veriT_vr57 veriT_vr58 veriT_vr59. CSTATE veriT_vr56 ( veriT_vr57 [ 0 s= veriT_vr58] [ 0 :=dd veriT_vr59] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr56 veriT_vr57 1) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1"
    by auto
  then have f19: "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1"
    using f17 f18 f4 by metis
  have f20: "((∃veriT_vr35 veriT_vr36 veriT_vr37. nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextGOPending veriT_vr35 1) ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1) ∨ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextGOPending T 1"
    by auto
  have f21: "((∃veriT_vr35 veriT_vr36 veriT_vr37. nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextGOPending veriT_vr35 1) ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1) ∨ (∀veriT_vr35 veriT_vr36 veriT_vr37. nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 = nextGOPending veriT_vr35 1)"
    by auto
  have f22: "(∃veriT_vr35 veriT_vr36 veriT_vr37. nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextGOPending veriT_vr35 1) ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1"
    by auto
  have "(∃veriT_vr35 veriT_vr36 veriT_vr37. nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextGOPending veriT_vr35 1) ∨ (∀veriT_vr35 veriT_vr36 veriT_vr37. ¬ nextGOPending ( veriT_vr35 [ 0 s= veriT_vr36] [ 0 :=dd veriT_vr37] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending veriT_vr35 1)"
    by auto
  then have f23: "(∃t m ma. nextGOPending ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextGOPending t 1) ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1"
    using f20 f21 f22 by metis
  have f24: "¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1"
    using f19 by (metis CSTATE_otherside_rule_5_0)
  have f25: "¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1"
    using f23 by (metis nextGOPending_General_rule_4_1)
  have f26: "((∃veriT_vr123 veriT_vr124 veriT_vr125. (CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125) ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0) ∨ CSTATE SMD T 0 ∧ SMD ≠ SMAD ∧ CSTATE SMAD T 0"
    by auto
  have f27: "((∃veriT_vr123 veriT_vr124 veriT_vr125. (CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125) ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0) ∨ (∀veriT_vr123 veriT_vr124 veriT_vr125. (¬ CSTATE veriT_vr123 veriT_vr124 0 ∨ veriT_vr123 = veriT_vr125) ∨ ¬ CSTATE veriT_vr125 veriT_vr124 0)"
    by auto
  have "(∃veriT_vr123 veriT_vr124 veriT_vr125. CSTATE veriT_vr123 veriT_vr124 0 ∧ veriT_vr123 ≠ veriT_vr125 ∧ CSTATE veriT_vr125 veriT_vr124 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0"
    using f26 f27 f13 by metis
  then have f28: "¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE SMD T 0 ∧ SMD ≠ SMAD ∧ CSTATE SMAD T 0 ∨ ¬ CSTATE SMD T 0 ∨ SMD = SMAD ∨ ¬ CSTATE SMAD T 0"
    by auto
  then have "CSTATE SMAD T 0 ⟶ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f28 by (metis MESI_State.distinct(561))
  moreover
  { assume aa1: "¬ CSTATE SMAD T 0"
    have "¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE SMAD T 0"
      by auto
    then have "¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ CSTATE IMAD T 0"
      using aa1 by metis
    moreover
    { assume "CSTATE IMAD T 0"
      then have fff1: "(¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∧ CSTATE IMAD T 0"
        using f16 by metis
      have "CSTATE SMD T 0 ∧ SMD ≠ IMAD ∧ CSTATE IMAD T 0 ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
        by auto
      then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff1 by (metis MESI_State.distinct(351)) }
    moreover
    { assume aaa1: "¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0"
      have "(¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ [] = htddatas1 T) ∨ CSTATE IMAD T 0 ∨ CSTATE SMAD T 0"
        by auto
      then have fff2: "¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ [] = htddatas1 T"
        using aaa1 by metis
      have "(¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ [] = htddatas1 T) ∧ (¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∨ [] ≠ htddatas1 T) ∨ (CSTATE IMAD T 0 ∨ CSTATE SMAD T 0) ∧ [] ≠ htddatas1 T ∨ (CSTATE IMA T 0 ∨ CSTATE SMA T 0) ∧ [] = htddatas1 T"
        by auto
      then have "(¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ [] = htddatas1 T) ∧ (¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∨ [] ≠ htddatas1 T) ∨ (CSTATE IMA T 0 ∨ CSTATE SMA T 0) ∧ [] = htddatas1 T"
        using fff2 by metis
      moreover
      { assume aaaa1: "(CSTATE IMA T 0 ∨ CSTATE SMA T 0) ∧ [] = htddatas1 T"
        have "(¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∨ [] ≠ htddatas1 T) ∨ CSTATE IMA T 0 ∨ CSTATE SMA T 0"
          by auto
        then have ffff2: "CSTATE IMA T 0 ∨ CSTATE SMA T 0"
          using aaaa1 by metis
        have "¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∨ CSTATE IMA T 0 ∨ CSTATE SMA T 0"
          by auto
        then have "CSTATE SMA T 0 ∨ CSTATE IMA T 0"
          using ffff2 by metis
        moreover
        { assume aaaaa1: "CSTATE IMA T 0"
          have "(CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ CSTATE ISA T 0) ∨ ¬ CSTATE IMA T 0"
            by auto
          then have "CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ CSTATE ISA T 0"
            using aaaaa1 by metis }
        moreover
        { assume aaaaa1: "CSTATE SMA T 0"
          have "(CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ CSTATE ISA T 0) ∨ ¬ CSTATE SMA T 0"
            by auto
          then have "CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ CSTATE ISA T 0"
            using aaaaa1 by metis }
        ultimately have "CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ CSTATE ISA T 0"
          by metis
        then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          by (metis i352) }
      moreover
      { assume "(¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ [] = htddatas1 T) ∧ (¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∨ [] ≠ htddatas1 T)"
        then have ffff1: "¬ CSTATE ISAD T 1 ∨ ¬ nextSnoopIs SnpInv T 1"
          by (metis i619)
        have "CSTATE ISAD T 1 ∧ nextSnoopIs SnpInv T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ¬ nextSnoopIs SnpInv T 1"
          by auto
        then have "¬ nextSnoopIs SnpInv T 1 ∨ ¬ CSTATE ISAD T 1"
          using ffff1 by metis
        moreover
        { assume aaaaa1: "¬ nextSnoopIs SnpInv T 1"
          have "(CSTATE ISD T 1 ∨ CSTATE IMD T 1 ∨ CSTATE SMD T 1 ∨ (CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1 ∨ CSTATE Modified T 1) ∧ ¬ nextSnoopIs SnpInv T 1 ∨ ¬ CSTATE ISD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∧ (¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1) ∧ ¬ CSTATE ISA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1 ∧ ¬ CSTATE Shared T 1 ∧ ¬ CSTATE Modified T 1 ∨ nextSnoopIs SnpInv T 1"
            by auto
          then have "¬ CSTATE ISD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∧ (¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1) ∧ ¬ CSTATE ISA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1 ∧ ¬ CSTATE Shared T 1 ∧ ¬ CSTATE Modified T 1 ∨ (CSTATE ISD T 1 ∨ CSTATE IMD T 1 ∨ CSTATE SMD T 1 ∨ (CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1 ∨ CSTATE Modified T 1) ∧ ¬ nextSnoopIs SnpInv T 1"
            using aaaaa1 by metis
          moreover
          { assume "(CSTATE ISD T 1 ∨ CSTATE IMD T 1 ∨ CSTATE SMD T 1 ∨ (CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1 ∨ CSTATE Modified T 1) ∧ ¬ nextSnoopIs SnpInv T 1"
            then have ffffff1: "¬ CSTATE IMD T 0 ∧ ¬ CSTATE SMD T 0 ∧ (¬ CSTATE IMAD T 0 ∧ ¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 0)"
              by (metis i465)
            have "(CSTATE IMD T 0 ∨ CSTATE SMD T 0 ∨ (CSTATE IMAD T 0 ∨ CSTATE SMAD T 0) ∧ nextGOPending T 0) ∨ ¬ CSTATE SMD T 0"
              by auto
            then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
              using ffffff1 by metis }
          moreover
          { assume aaaaaa1: "¬ CSTATE ISD T 1 ∧ ¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∧ (¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1) ∧ ¬ CSTATE ISA T 1 ∧ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1 ∧ ¬ CSTATE Shared T 1 ∧ ¬ CSTATE Modified T 1"
            have "(CSTATE ISD T 1 ∨ CSTATE IMD T 1 ∨ CSTATE SMD T 1 ∨ (CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1"
              by auto
            then have ffffff2: "¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1"
              using aaaaaa1 by metis
            have "(CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextGOPending T 1 ∨ ¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextGOPending T 1"
              by auto
            then have "nextGOPending T 1 ⟶ ¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1"
              using ffffff2 by metis
            moreover
            { assume aaaaaaa1: "¬ CSTATE ISAD T 1 ∧ ¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1"
              have "(CSTATE ISAD T 1 ∨ CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∨ ¬ CSTATE ISAD T 1"
                by auto
              then have "¬ CSTATE ISAD T 1"
                using aaaaaaa1 by metis }
            moreover
            { assume "¬ nextGOPending T 1"
              then have fffffff1: "(¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1) ∧ ¬ nextGOPending T 1"
                using f25 by metis
              have "nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextGOPending T 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextGOPending T 1"
                by auto
              then have fffffff2: "¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
                using fffffff1 by metis
              have "(¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
                by auto
              then have "¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
                using fffffff2 by metis }
            ultimately have "CSTATE ISAD T 1 ⟶ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
              by metis }
          ultimately have "CSTATE ISAD T 1 ⟶ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            by metis }
        ultimately have "CSTATE ISAD T 1 ⟶ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          by metis
        moreover
        { assume "¬ CSTATE ISAD T 1"
          then have fffff1: "(¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1) ∧ ¬ CSTATE ISAD T 1"
            using f24 by metis
          have "CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE ISAD T 1 ∨ ¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE ISAD T 1"
            by auto
          then have fffff2: "¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            using fffff1 by metis
          have "(¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            by auto
          then have "¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            using fffff2 by metis }
        ultimately have "(¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          by metis
        moreover
        { assume aaaaa1: "¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          have "(CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            by auto
          then have "(¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
            using aaaaa1 by metis
          then have "(CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
            by metis
          moreover
          { assume aaaaaa1: "(CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
            have "(CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
              by auto
            then have ffffff2: "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
              using aaaaaa1 by metis
            have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
              by auto
            then have "CSTATE Modified T 1"
              using ffffff2 f5 by metis
            then have "[] = htddatas1 T"
              by (metis i921)
            then have ffffff3: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
              using f15 by metis
            have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
              by auto
            then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
              using ffffff3 by metis }
          ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
            by metis }
        ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          by metis }
      ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f29: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f30: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f31: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextGOPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f29 f30 f31 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant HSTATE_invariant_ModifiedSnpInv i396 i415 i508 i745 i758 i844 i902 i904 i906
    i908 i910 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have f3: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have f4: "¬ CSTATE SMAD T 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ CSTATE MIA T 1"
    using i758 by moura
  have f5: "CSTATE IMAD T 0 ∨ ¬ nextReqIs RdOwn T 0 ∨ ¬ HSTATE ModifiedM T"
    using i745 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f7: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    using i508 by moura
  have f9: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMAD T 1"
    using i910 by moura
  have f10: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i906 by moura
  have f11: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i908 by moura
  have f12: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMD T 1"
    using i902 by moura
  have f13: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMD T 1"
    using i904 by moura
  have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ nextGOPending T 1 ∧ CSTATE IMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMA T 1 ∨ nextGOPending T 1 ∧ CSTATE SMA T 1 ∨ ¬ CSTATE IMAD T 0 ∧ HSTATE ModifiedM T ∨ nextHTDDataPending T 1 ∧ CSTATE IMD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE SMD T 1 ∨ HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ (∃m. m ≠ SMAD ∧ CSTATE m T 0)"
    using f7 by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f9 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f10 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f11 by metis }
  moreover
  { assume "¬ CSTATE IMAD T 0 ∧ HSTATE ModifiedM T"
    then have "¬ nextReqIs RdOwn T 0"
      using f5 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE IMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f12 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE SMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f13 by metis }
  moreover
  { assume "HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55"
    then have "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T ∨ HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      then have "¬ CSTATE SMAD T 0"
        using f4 by metis }
    moreover
    { assume "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T"
      then have "nextReqIs RdOwn T 0 ⟶ CSTATE Modified T 1"
        by metis
      moreover
      { assume "CSTATE Modified T 1"
        then have "¬ CSTATE SMAD T 0"
          using f2 by metis }
      ultimately have "¬ nextReqIs RdOwn T 0 ∨ ¬ CSTATE SMAD T 0"
        by metis }
    ultimately have "¬ nextReqIs RdOwn T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f8 by metis }
  moreover
  { assume "∃m. m ≠ SMAD ∧ CSTATE m T 0"
    then have "¬ CSTATE SMAD T 0"
      using f6 by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ∧ nextReqIs RdOwn T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ nextReqIs RdOwn T 0"
    then have "¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f3 by metis
    moreover
    { assume "¬ CXL_SPG_used T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by moura }
    ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant i652 nextGOPending_DeviceSMAGO_other nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f4: "¬ CSTATE SMA T 0 ∨ ¬ HSTATE SharedM T"
    using i652 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE SMA T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SMDData_HSTATE i654) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_ISAGO_IMAD_invariant CSTATE_assign_rule_2 CSTATE_inequality_invariant CSTATE_remove_op
    CSTATE_various_forms2 CSTATE_various_forms6 MESI_State.distinct(3) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant SharedSnpInv'_MAD_CSTATE_invariant4 devcache1_consume_reqresps1_invariant
    devcache2_consume_reqresps1_invariant devcache2_copy_perform1_invariant i791)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  have f2: "¬ CSTATE Shared T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE IMA T 0"
    using i791 by moura
  have f3: "∀t. CLEntry.block_state (devcache1 t) = CLEntry.block_state (devcache1 (t [ 0 -=reqresp ]))"
    using devcache1_consume_reqresps1_invariant by moura
  have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f5: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f8: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f9: "∀t. devcache2 (t [ -=i 0]) = devcache2 t"
    using devcache2_copy_perform1_invariant by moura
  have f10: "∀t. devcache2 (t [ 0 -=reqresp ]) = devcache2 t"
    using devcache2_consume_reqresps1_invariant by moura
  have "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (t⦇buffer1 := Some ma⦈) n"
    using SharedSnpInv'_MAD_CSTATE_invariant by moura
  then have f11: "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (buffer1_update (zz (Some ma)) t) n"
    using f1 by metis
  have f12: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have f13: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f14: "∀X0. zz (Some X0) = x_l_lift1 X0"
    by moura
  then have "∀m t n ma. CSTATE m t n ∨ ¬ CSTATE m (buffer1_update (x_l_lift1 ma) t) n"
    using f11 by metis
  then have "CLEntry.block_state (devcache1 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared ∨ CSTATE Shared T 1"
    using f13 f12 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume "CSTATE Shared T 1"
    then have "CSTATE IMA T 0 ⟶ CSTATE Shared T 1 ∧ CSTATE IMA T 0"
      by metis
    moreover
    { assume "¬ CSTATE IMA T 0"
      then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    moreover
    { assume aaa1: "CSTATE Shared T 1 ∧ CSTATE IMA T 0"
      { have "¬ nextGOPending T 0"
          using aaa1 f2 by metis }
      then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "CLEntry.block_state (devcache1 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Modified])) ≠ Shared"
    { have "CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using aa1 f10 f9 f14 by metis
      then have "CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∧ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared"
        using f1 by metis }
    then have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache1 ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])) ≠ Shared)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i396 i415 i508 i758 i844 i902 i904 i906 i908 i910 i914
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have f3: "¬ CSTATE SMAD T 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ CSTATE MIA T 1"
    using i758 by moura
  have f4: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    using i508 by moura
  have f7: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMD T 1"
    using i902 by moura
  have f8: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMD T 1"
    using i904 by moura
  have f9: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMAD T 1"
    using i914 by moura
  have f10: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMAD T 1"
    using i910 by moura
  have f11: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i906 by moura
  have f12: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i908 by moura
  have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ nextGOPending T 1 ∧ CSTATE IMAD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE IMD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE SMD T 1 ∨ nextGOPending T 1 ∧ CSTATE SMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMA T 1 ∨ nextGOPending T 1 ∧ CSTATE SMA T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55"
    using f5 by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f10 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE IMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f7 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE SMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f8 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f9 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f11 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f12 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f6 by metis }
  moreover
  { assume "HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55"
    then have "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T ∨ HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      then have "¬ CSTATE SMAD T 0"
        using f3 by metis }
    moreover
    { assume "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T"
      then have "nextReqIs RdOwn T 0 ⟶ CSTATE Modified T 1"
        by metis
      moreover
      { assume "CSTATE Modified T 1"
        then have "¬ CSTATE SMAD T 0"
          using f4 by metis }
      moreover
      { assume "¬ nextReqIs RdOwn T 0"
        then have "¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
          using f2 by metis
        moreover
        { assume "¬ CXL_SPG_used T 0"
          then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
            by moura }
        ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
          by metis }
      ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by metis }
    ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant i652 nextGOPending_DeviceSMAGO_other nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f4: "¬ CSTATE SMA T 0 ∨ ¬ HSTATE SharedM T"
    using i652 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE SMA T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SMDData_HSTATE i654) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SMAGO_nextHTDDataPending_sameside i352 i834 nextGOPending_DeviceSMAGO_other
    nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀t n m. nextHTDDataPending t n ∨ ¬ nextHTDDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using SMAGO_nextHTDDataPending_sameside by moura
  then have f3: "∀t n m. nextHTDDataPending t n ∨ ¬ nextHTDDataPending ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have f4: "¬ nextHTDDataPending T 0 ∨ ¬ CSTATE IMA T 0"
    using i352 by moura
  have f5: "¬ nextGOPending T 0 ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextHTDDataPending T 1"
    using i834 by moura
  have "¬ nextHTDDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextHTDDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ nextHTDDataPending T 1 ∨ nextHTDDataPending T 0"
    using f3 by metis
  moreover
  { assume "nextHTDDataPending T 0"
    then have "¬ CSTATE IMA T 0"
      using f4 by metis }
  moreover
  { assume "nextHTDDataPending T 1"
    then have "¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      using f5 by metis
    moreover
    { assume "¬ nextGOPending T 0"
      then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
        by moura }
    ultimately have "CSTATE IMA T 0 ⟶ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ nextHTDDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextHTDDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ nextHTDDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextHTDDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 by metis
      then have "¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "CSTATE IMA T 0 ⟶ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  moreover
  { assume "¬ CSTATE IMA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_otherside_rule_5_0 i100 i921 nextHTDDataPending_def nextReqIs_general_rule_7_0
    nextReqIs_nonempty_reqs1)

Isar proof:
proof -
  have "∀veriT_vr1515 veriT_vr1514. (if 1 = veriT_vr1515 then [] ≠ htddatas2 (veriT_vr1514::Type1State) else False) = (1 = veriT_vr1515 ∧ [] ≠ htddatas2 veriT_vr1514)"
    by auto
  then have f1: "∀t n. nextHTDDataPending t n = (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)"
    by (metis nextHTDDataPending_def)
  have f2: "((∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ≠ (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f3: "((∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ≠ (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 = (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516))"
    by auto
  have f4: "(∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ∧ 0 = veriT_vr1517 ∧ [] = htddatas1 veriT_vr1516) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ≠ (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516)) ∨ (∀veriT_vr1516 veriT_vr1517. ¬ nextHTDDataPending veriT_vr1516 veriT_vr1517 ∨ 0 ≠ veriT_vr1517 ∨ [] ≠ htddatas1 veriT_vr1516)"
    by auto
  then have f5: "(∃t n. nextHTDDataPending t n ≠ (if 0 = n then [] ≠ htddatas1 t else 1 = n ∧ [] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f2 f3 f4 by metis
  have f6: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) = (¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T)"
    by auto
  have "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T ⟶ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  then have f7: "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f6 by metis
  have f8: "((∃veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 ≠ nextReqIs veriT_vr473 veriT_vr474 veriT_vr477) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f9: "((∃veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 ≠ nextReqIs veriT_vr473 veriT_vr474 veriT_vr477) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 = nextReqIs veriT_vr473 veriT_vr474 veriT_vr477)"
    by auto
  have f10: "(∃veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 ∧ ¬ nextReqIs veriT_vr473 veriT_vr474 veriT_vr477) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 ≠ nextReqIs veriT_vr473 veriT_vr474 veriT_vr477) ∨ (∀veriT_vr473 veriT_vr474 veriT_vr475 veriT_vr476 veriT_vr477. ¬ nextReqIs veriT_vr473 ( veriT_vr474 [ 0 s= veriT_vr475] [ 0 :=dd veriT_vr476] [ -=i 0] [ 0 -=devd ]) veriT_vr477 ∨ nextReqIs veriT_vr473 veriT_vr474 veriT_vr477)"
    by auto
  then have f11: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f8 f9 f10 by metis
  have f12: "((∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ≠ (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have "((∃veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 ≠ (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1516 veriT_vr1517. nextHTDDataPending veriT_vr1516 veriT_vr1517 = (if 0 = veriT_vr1517 then [] ≠ htddatas1 veriT_vr1516 else 1 = veriT_vr1517 ∧ [] ≠ htddatas2 veriT_vr1516))"
    by auto
  then have f13: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f12 f7 f5 f1 by metis
  have f14: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f11 by (metis nextReqIs_general_rule_7_0)
  have f15: "((∃veriT_vr1534 veriT_vr1535. nextReqIs veriT_vr1534 veriT_vr1535 0 ∧ [] = reqs1 veriT_vr1535) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f16: "((∃veriT_vr1534 veriT_vr1535. nextReqIs veriT_vr1534 veriT_vr1535 0 ∧ [] = reqs1 veriT_vr1535) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1534 veriT_vr1535. ¬ nextReqIs veriT_vr1534 veriT_vr1535 0 ∨ [] ≠ reqs1 veriT_vr1535)"
    by auto
  have f17: "(∃veriT_vr1534 veriT_vr1535. nextReqIs veriT_vr1534 veriT_vr1535 0 ∧ [] = reqs1 veriT_vr1535) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1534 veriT_vr1535. nextReqIs veriT_vr1534 veriT_vr1535 0 ∧ [] = reqs1 veriT_vr1535) ∨ (∀veriT_vr1534 veriT_vr1535. ¬ nextReqIs veriT_vr1534 veriT_vr1535 0 ∨ [] ≠ reqs1 veriT_vr1535)"
    by auto
  then have f18: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f15 f16 f17 by (metis nextReqIs_nonempty_reqs1)
  have f19: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f20: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  have f21: "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. ¬ CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  then have "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f19 f20 f21 by metis
  then have f22: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_5_0)
  have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ CSTATE Modified T 1"
    using f22 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "[] = htddatas1 T"
      by (metis i921) }
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis
    then have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have fff2: "HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using aaa1 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have fff3: "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff2 by metis
      have "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
        by auto
      then have "nextReqIs RdShared T 0"
        using fff3 f14 by metis
      then have fff4: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
        using f18 by metis
      have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
        by auto
      then have "[] ≠ reqs1 T"
        using fff4 by metis
      then have "[] = htddatas1 T"
        by (metis i100) }
    ultimately have "[] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      by metis }
  ultimately have "[] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume "[] = htddatas1 T"
    then have ff1: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
      using f13 by metis
    have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
      by auto
    then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      using ff1 by metis }
  ultimately have f23: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  have f24: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = (CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  have f25: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ (CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f23 f24 f25 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i396 i415 i508 i758 i844 i902 i904 i906 i908 i910 i914
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have f3: "¬ CSTATE SMAD T 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ CSTATE MIA T 1"
    using i758 by moura
  have f4: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    using i508 by moura
  have f7: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMD T 1"
    using i902 by moura
  have f8: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMD T 1"
    using i904 by moura
  have f9: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMAD T 1"
    using i914 by moura
  have f10: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMAD T 1"
    using i910 by moura
  have f11: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i906 by moura
  have f12: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i908 by moura
  have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ nextGOPending T 1 ∧ CSTATE IMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMA T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE IMD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE SMD T 1 ∨ nextGOPending T 1 ∧ CSTATE SMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE SMA T 1 ∨ HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    using f5 by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f10 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f11 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE IMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f7 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE SMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f8 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f9 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f12 by metis }
  moreover
  { assume "HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55"
    then have "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T ∨ HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      then have "¬ CSTATE SMAD T 0"
        using f3 by metis }
    moreover
    { assume "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T"
      then have "nextReqIs RdOwn T 0 ⟶ CSTATE Modified T 1"
        by metis
      moreover
      { assume "CSTATE Modified T 1"
        then have "¬ CSTATE SMAD T 0"
          using f4 by metis }
      moreover
      { assume "¬ nextReqIs RdOwn T 0"
        then have "nextSnoopIs SnpInv T 0 ⟶ ¬ nextReqIs RdOwn T 0 ∧ nextSnoopIs SnpInv T 0"
          by metis
        moreover
        { assume "¬ nextReqIs RdOwn T 0 ∧ nextSnoopIs SnpInv T 0"
          then have "¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
            using f2 by metis
          moreover
          { assume "¬ CXL_SPG_used T 0"
            then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
              by moura }
          ultimately have "CSTATE SMAD T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
            by metis }
        ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
          by metis }
      ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by metis }
    ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f6 by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i396 i415 i508 i758 i844 i902 i904 i906 i908 i910 i914
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "nextReqIs RdOwn T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
    using i396 by moura
  have f3: "¬ CSTATE SMAD T 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ CSTATE MIA T 1"
    using i758 by moura
  have f4: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    using i508 by moura
  have f7: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMD T 1"
    using i902 by moura
  have f8: "¬ CSTATE SMAD T 0 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMD T 1"
    using i904 by moura
  have f9: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMAD T 1"
    using i914 by moura
  have f10: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMAD T 1"
    using i910 by moura
  have f11: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i906 by moura
  have f12: "¬ CSTATE SMAD T 0 ∨ ¬ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i908 by moura
  have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ nextGOPending T 1 ∧ CSTATE IMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE IMA T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE IMD T 1 ∨ nextHTDDataPending T 1 ∧ CSTATE SMD T 1 ∨ nextGOPending T 1 ∧ CSTATE SMAD T 1 ∨ nextGOPending T 1 ∧ CSTATE SMA T 1 ∨ HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    using f5 by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f10 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE IMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f11 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE IMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f7 by metis }
  moreover
  { assume "nextHTDDataPending T 1 ∧ CSTATE SMD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f8 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMAD T 1"
    then have "¬ CSTATE SMAD T 0"
      using f9 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE SMA T 1"
    then have "¬ CSTATE SMAD T 0"
      using f12 by metis }
  moreover
  { assume "HSTATE ModifiedM T ∧ ¬ zip_tseitin_57 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_55"
    then have "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T ∨ HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      by metis
    moreover
    { assume "HSTATE ModifiedM T ∧ CSTATE MIA T 1"
      then have "¬ CSTATE SMAD T 0"
        using f3 by metis }
    moreover
    { assume "¬ CSTATE MIA T 1 ∧ ¬ zip_tseitin_55 ∧ ¬ zip_tseitin_56 ∧ ¬ zip_tseitin_57 ∧ HSTATE ModifiedM T"
      then have "nextReqIs RdOwn T 0 ⟶ CSTATE Modified T 1"
        by metis
      moreover
      { assume "CSTATE Modified T 1"
        then have "¬ CSTATE SMAD T 0"
          using f4 by metis }
      moreover
      { assume "¬ nextReqIs RdOwn T 0"
        then have "nextSnoopIs SnpInv T 0 ⟶ ¬ nextReqIs RdOwn T 0 ∧ nextSnoopIs SnpInv T 0"
          by metis
        moreover
        { assume "¬ nextReqIs RdOwn T 0 ∧ nextSnoopIs SnpInv T 0"
          then have "¬ CXL_SPG_used T 0 ∨ ¬ CSTATE SMAD T 0"
            using f2 by metis
          moreover
          { assume "¬ CXL_SPG_used T 0"
            then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
              by moura }
          ultimately have "CSTATE SMAD T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
            by metis }
        ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
          by metis }
      ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
        by metis }
    ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      using f6 by metis }
  ultimately have "CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  moreover
  { assume "¬ CSTATE SMAD T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_oppo_def SMAGO_nextHTDDataPending_otherside i13
    nextDTHDataPending_general_rule_1_0 nextGOPending_yes_reqresp_rule_4_1 nextReqIs_SMAGO nextReqIs_general_rule_4_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextHTDDataPending_otherside by moura
  then have f5: "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f7: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_general_rule_4_0 by moura
  then have f8: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f1 by metis
  have "∀t n z m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextDTHDataPending_general_rule_1_0 by moura
  then have f9: "∀t n z m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f1 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f9 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis AllBackgroundInvariants.device_perform_op_dthdatas2 dthdatas1_general_rule_4_0
    hstate_invariants(17,20,24) i189 i435 i546 nextDTHDataPending_def remove_instr_HSTATE)

Isar proof:
proof -
  have f1: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f2: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=devd ])"
    using hstate_invariants(17) by moura
  have f4: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h (t [ n :=dd m])"
    using hstate_invariants(20) by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ nextHTDDataPending T 0 ∨ ¬ CSTATE SMD T 0"
    using i546 by moura
  have f6: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f7: "dthdatas1 T = [] ∨ ¬ CSTATE SMD T 0"
    using i435 by moura
  have f8: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f9: "∀t m ma. dthdatas1 ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) = dthdatas1 t"
    using dthdatas1_general_rule_4_0 by moura
  have f10: "∀t m. dthdatas2 t = dthdatas2 ( t [ 0 s= Modified] [ 0 :=dd m] [ -=i 0] [ 0 -=devd ])"
    using AllBackgroundInvariants.device_perform_op_dthdatas2 by moura
  have f11: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "nextHTDDataPending T 0 ∧ CSTATE SMD T 0 ∧ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    using f11 f10 f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ nextHTDDataPending T 0"
    then have "(¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SMD T 0"
    then have "(¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    then have "(¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
    by metis
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 SharedSnpInv'_CSTATE_invariant5 i844
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE SMAD T 0 ∨ ¬ CSTATE Modified T 1"
    using i844 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f3: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  then have "CSTATE Modified T 1 ∨ ¬ CSTATE IMAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1"
    using f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE IMAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1"
    { have "¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    { have "¬ CSTATE SMAD T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SMAD T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SMAD T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IMAD]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
255.816s elapsed time, 74.641s cpu time, 1.484s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_oppo_def H_msg_P_same_def ISADGO'_HSTATE_neg
    SMAGO_nextSnpRespIs_otherside SMAGO_nextSnpRespIs_sameside i14 i15 nextReqIs_SMAGO)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X B_x. zza B_X B_x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextSnpRespIs_otherside by moura
  then have f5: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SMAGO_nextSnpRespIs_sameside by moura
  then have f6: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  then have f9: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f8 f7 f6 f5 f4 f3 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    using f9 by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 HSTATE_rule_6 MESI_State.distinct(285,351) i100 i417 i419 i456 i462 i546 i577
    i778 i833 i852 nextHTDDataPending_various_forms1 nextReqIs_general_rule_7_0 nextReqIs_nonempty_reqs1
    nextSnpRespIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f2: "((∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1599. nextHTDDataPending veriT_vr1599 0 = ([] ≠ htddatas1 veriT_vr1599))"
    by auto
  have f3: "(∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ∧ [] = htddatas1 veriT_vr1599) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ (∀veriT_vr1599. ¬ nextHTDDataPending veriT_vr1599 0 ∨ [] ≠ htddatas1 veriT_vr1599)"
    by auto
  then have f4: "(∃t. nextHTDDataPending t 0 ≠ ([] ≠ htddatas1 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 = nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  have f7: "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∧ ¬ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have f8: "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. ¬ nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∨ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  then have f9: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f10: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f11: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 = HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f12: "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr504 veriT_vr505) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. ¬ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr504 veriT_vr505)"
    by auto
  then have f13: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f10 f11 f12 by metis
  have f14: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f4 by (metis nextHTDDataPending_various_forms1)
  have f15: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f9 by (metis nextReqIs_general_rule_7_0)
  have f16: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f13 by (metis HSTATE_rule_6)
  have f17: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f18: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  have f19: "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  then have f20: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f17 f18 f19 by (metis nextReqIs_nonempty_reqs1)
  have f21: "((∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f22: "((∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 = nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545)"
    by auto
  have f23: "(∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ∧ ¬ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ (∀veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. ¬ nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ∨ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545)"
    by auto
  then have f24: "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f21 f22 f23 by metis
  have f25: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f26: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 = nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  have "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∧ ¬ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have f27: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f25 f26 f8 by metis
  have f28: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f24 by (metis nextSnpRespIs_general_rule_7_0)
  have f29: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f27 by (metis nextReqIs_general_rule_7_0)
  have f30: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE SMD T 0 ∧ SMD ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f31: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. (¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175) ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  have f32: "(∃veriT_vr173 veriT_vr174 veriT_vr175. CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175 ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have f33: "(∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. ¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175 ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f30 f31 f32 by metis
  then have f34: "¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have f35: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ CSTATE SMD T 0 ∧ SMD ≠ IMAD ∧ CSTATE IMAD T 0"
    by auto
  have f36: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. (¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175) ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  have "(∃veriT_vr173 veriT_vr174 veriT_vr175. CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175 ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    using f35 f36 f33 by metis
  then have f37: "¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE SMD T 0 ∧ SMD ≠ IMAD ∧ CSTATE IMAD T 0 ∨ ¬ CSTATE SMD T 0 ∨ SMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by auto
  then have "CSTATE IMAD T 0 ⟶ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f37 by (metis MESI_State.distinct(351))
  moreover
  { assume aa1: "¬ CSTATE IMAD T 0"
    have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0"
      by auto
    then have "CSTATE Invalid T 0 ∨ CSTATE IIA T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE ISDI T 0 ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      using aa1 by metis
    moreover
    { assume "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      then have fff1: "¬ nextSnpRespIs RspIFwdM T 0 ∧ ¬ nextSnpRespIs RspIHitSE T 0"
        by (metis i456)
      have "(nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIHitSE T 0) ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "¬ nextSnpRespIs RspIFwdM T 0"
        using fff1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
        using f28 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff3: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff3 by metis }
    moreover
    { assume "CSTATE ISDI T 0"
      then have fff1: "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
        by (metis i778)
      have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
        by auto
      then have "¬ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T"
        using fff1 by metis
      moreover
      { assume "¬ nextReqIs RdShared T 1"
        then have ffff1: "(¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
          using f29 by metis
        have "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
          by auto
        then have ffff2: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          using ffff1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          by auto
        then have "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          using ffff2 by metis }
      ultimately have "HSTATE ModifiedM T ⟶ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by metis }
    moreover
    { assume "CSTATE ISAD T 0"
      then have fff1: "(¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∧ CSTATE ISAD T 0"
        using f34 by metis
      have "CSTATE SMD T 0 ∧ SMD ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
        by auto
      then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff1 by (metis MESI_State.distinct(285)) }
    moreover
    { assume aaa1: "CSTATE IIA T 0"
      have "CSTATE IIA T 0 ∧ HSTATE ModifiedM T ∨ ¬ CSTATE IIA T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i419) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    moreover
    { assume aaa1: "CSTATE Invalid T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have fff2: "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ (CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        using fff2 by metis
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i417) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ (¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      by metis
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using aaa1 f16 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using fff2 by metis }
    moreover
    { assume "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      then have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ CSTATE Modified T 1 ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ ¬ CSTATE Modified T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        by metis
      moreover
      { assume aaaa1: "(CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ ¬ CSTATE Modified T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by auto
        then have "CSTATE MIA T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∧ ¬ nextHTDDataPending T 0"
          by (metis i577)
        have "(CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ nextHTDDataPending T 0) ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      moreover
      { assume aaaa1: "CSTATE Modified T 1"
        have "(CSTATE Modified T 1 ∨ dthdatas1 T ≠ [] ∧ ¬ nextSnpRespIs RspSFwdM T 0 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 1"
          by auto
        then have "CSTATE Modified T 1 ∨ dthdatas1 T ≠ [] ∧ ¬ nextSnpRespIs RspSFwdM T 0 ∧ ¬ HSTATE SD T"
          using aaaa1 by metis
        then have "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
          by (metis i462) }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1"
        have ffff2: "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ nextGOPending T 1"
          by auto
        have ffff3: "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        have ffff4: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        have ffff5: "CSTATE IMA T 1 ∧ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1 ∨ ¬ nextGOPending T 1"
          by auto
        have "CSTATE SMA T 1 ∧ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1"
          by auto
        then have "CSTATE SMA T 1 ∧ nextGOPending T 1 ∨ CSTATE IMA T 1 ∧ nextGOPending T 1"
          using aaaa1 ffff2 ffff3 ffff4 ffff5 by metis
        moreover
        { assume "CSTATE IMA T 1 ∧ nextGOPending T 1"
          then have "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
            by (metis i833) }
        moreover
        { assume "CSTATE SMA T 1 ∧ nextGOPending T 1"
          then have "[] = htddatas1 T"
            by (metis i852) }
        ultimately have "[] = htddatas1 T ∨ (¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
          by metis }
      ultimately have "[] = htddatas1 T ∨ nextHTDDataPending T 1 ∨ (¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume aaaa1: "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
        have "(CSTATE ISAD T 0 ∧ nextGOPending T 0 ∨ CSTATE ISA T 0 ∨ nextHTDDataPending T 0 ∨ CSTATE Shared T 0) ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "nextHTDDataPending T 1"
        have "(CSTATE ISA T 1 ∨ nextHTDDataPending T 1) ∨ ¬ nextHTDDataPending T 1"
          by auto
        then have "CSTATE ISA T 1 ∨ nextHTDDataPending T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by (metis i546)
        have "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      ultimately have "[] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ [] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using aaa1 by metis }
    ultimately have "((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ [] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      then have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume aaaa1: "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          by auto
        then have ffff2: "HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          using aaaa1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          by auto
        then have ffff3: "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          using ffff2 by metis
        have "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
          by auto
        then have "nextReqIs RdShared T 0"
          using ffff3 f15 by metis
        then have ffff4: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
          using f20 by metis
        have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
          by auto
        then have "[] ≠ reqs1 T"
          using ffff4 by metis
        then have "[] = htddatas1 T"
          by (metis i100) }
      ultimately have "[] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "[] = htddatas1 T ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume "[] = htddatas1 T"
      then have fff1: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f14 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff1 by metis }
    ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f38: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f39: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f40: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f38 f39 f40 by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_oppo_def H_msg_P_same_def ISADGO'_HSTATE_neg
    SMAGO_nextSnpRespIs_otherside SMAGO_nextSnpRespIs_sameside i14 i15 nextReqIs_SMAGO)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X B_x. zza B_X B_x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextSnpRespIs_otherside by moura
  then have f5: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SMAGO_nextSnpRespIs_sameside by moura
  then have f6: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  then have f9: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f8 f7 f6 f5 f4 f3 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0"
    using f9 by metis
  then show "CSTATE SMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Done 
Sledgehammering... 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SMAGO_otherside_invariant2 i791 i827 nextGOPending_DeviceSMAGO_other
    nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ nextGOPending T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE IMA T 0"
    using i827 by moura
  have "∀t m. nextGOPending t 1 ∨ ¬ nextGOPending ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using nextGOPending_DeviceSMAGO_other by moura
  then have f4: "∀t m. nextGOPending t 1 ∨ ¬ nextGOPending ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SMAGO_otherside_invariant2 by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have f6: "¬ CSTATE Modified T 1 ∨ ¬ nextGOPending T 0 ∨ ¬ CSTATE IMA T 0"
    using i791 by moura
  have f7: "¬ nextGOPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ nextGOPending T 1 ∧ CSTATE ISAD T 1 ∨ CSTATE Modified T 1"
    using f5 f4 by metis
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      using f6 by metis }
  moreover
  { assume "nextGOPending T 1 ∧ CSTATE ISAD T 1"
    then have "CSTATE IMA T 0 ⟶ nextGOPending T 1 ∧ CSTATE ISAD T 1 ∧ CSTATE IMA T 0"
      by metis
    moreover
    { assume "nextGOPending T 1 ∧ CSTATE ISAD T 1 ∧ CSTATE IMA T 0"
      then have "¬ nextGOPending T 0"
        using f3 by metis }
    ultimately have "¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by metis }
  moreover
  { assume aa1: "¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ CSTATE ISAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f8 by metis
      then have "¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextGOPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextGOPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f8 by metis
      then have "¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "nextGOPending T 0 ∧ CSTATE IMA T 0 ⟶ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    using f7 by metis
  moreover
  { assume "¬ nextGOPending T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant i652 nextGOPending_DeviceSMAGO_other nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f4: "¬ CSTATE IMA T 0 ∨ ¬ HSTATE SharedM T"
    using i652 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE IMA T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
323.375s elapsed time, 88.031s cpu time, 1.750s GC time 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_otherside_rule_5_0 HOST_State.distinct(15,175,249,9) HSTATE_invariant3
    HSTATE_rule_6 MESI_State.distinct(285) i106 i23 i366 i495 nextReqIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T"
    by auto
  have f2: "((∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ (∀veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 = HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr448 veriT_vr449) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. ¬ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr448 veriT_vr449)"
    by auto
  then have f4: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f6: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  have f7: "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. ¬ CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  then have f8: "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    using f4 by (metis HSTATE_rule_6)
  have f10: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f8 by (metis CSTATE_otherside_rule_5_0)
  have f11: "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f12: "HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by auto
  have f13: "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
    by auto
  have f14: "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    by auto
  have f15: "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    by auto
  have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    by auto
  then have f16: "CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    using f10 f11 f9 f12 f13 f14 f15 by (metis i23)
  have f17: "((∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∨ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdOwn T 1"
    by auto
  have f18: "((∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∨ (∀veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 = nextReqIs veriT_vr465 veriT_vr466 veriT_vr469)"
    by auto
  have f19: "(∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ∧ ¬ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    by auto
  have "(∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ (∀veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. ¬ nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ∨ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469)"
    by auto
  then have f20: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    using f17 f18 f19 by metis
  have f21: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ MA ≠ MAD ∧ MA ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have f22: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  have f23: "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. HSTATE veriT_vr136 veriT_vr134 ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137 ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  have f24: "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137 ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have f25: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f21 f22 f23 by metis
  have f26: "¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    using f20 by (metis nextReqIs_general_rule_7_0)
  have f27: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ MAD ∧ ModifiedM ≠ MAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have f28: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  have "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. HSTATE veriT_vr136 veriT_vr134 ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137 ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f29: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f27 f28 f24 by metis
  have f30: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE SMD T 0 ∧ SMD ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f31: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. (¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159) ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  have f32: "(∃veriT_vr157 veriT_vr158 veriT_vr159. CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159 ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. ¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159 ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f30 f31 f32 by metis
  then have f33: "¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have f34: "¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ (¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) = (¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T)"
    by auto
  have "¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f35: "¬ HSTATE SD T ∨ MA = MAD ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f34 by metis
  have f36: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ MA ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f35 f36 f25 by metis
  then have f37: "¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by (metis HSTATE_invariant3)
  have f38: "¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ (¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) = (¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T)"
    by auto
  have "¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f39: "¬ HSTATE SD T ∨ ModifiedM = MAD ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f38 by metis
  have f40: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ MAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f39 f40 f29 by metis
  then have f41: "¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by (metis HSTATE_invariant3)
  have "CSTATE SMD T 0 ∧ SMD ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE SMD T 0 ∨ SMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f33 by (metis MESI_State.distinct(285))
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0"
    have "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ CSTATE ISAD T 1"
      by auto
    then have "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1 ∨ CSTATE ISAD T 1"
      using aa1 by metis
    moreover
    { assume aaa1: "CSTATE ISAD T 1"
      have "(CSTATE ISAD T 1 ∨ CSTATE Invalid T 1) ∨ ¬ CSTATE ISAD T 1"
        by auto
      then have "CSTATE ISAD T 1 ∨ CSTATE Invalid T 1"
        using aaa1 by metis
      then have "¬ nextReqIs RdOwn T 1"
        by (metis i495)
      then have fff2: "(¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∧ ¬ nextReqIs RdOwn T 1"
        using f26 by metis
      have "nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdOwn T 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
        by auto
      then have fff3: "¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using fff2 by metis
      have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using fff3 by metis }
    moreover
    { assume "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1"
      then have fff1: "¬ HSTATE SAD T"
        by (metis i106)
      have "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T ∨ HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE SAD T"
        by auto
      then have "HSTATE ModifiedM T ∨ HSTATE MAD T ∨ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
        using fff1 by metis
      moreover
      { assume "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
        then have ffff1: "(¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0) ∧ (¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∧ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0)"
          by (metis i366)
        have "(CSTATE SMA T 0 ∧ nextGOPending T 0 ∨ CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have ffff2: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
          using ffff1 by metis
        have "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      moreover
      { assume "HSTATE MAD T"
        then have ffff1: "(¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∧ HSTATE MAD T"
          using f37 by metis
        have "HSTATE SD T ∧ MA ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SD T ∨ MA = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
          by auto
        then have "¬ HSTATE SD T"
          using ffff1 by (metis HOST_State.distinct(175,249)) }
      moreover
      { assume "HSTATE ModifiedM T"
        then have ffff1: "(¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          using f41 by metis
        have "HSTATE SD T ∧ ModifiedM ≠ MAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SD T ∨ ModifiedM = MAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
          by auto
        then have "¬ HSTATE SD T"
          using ffff1 by (metis HOST_State.distinct(15,9)) }
      ultimately have "HSTATE SD T ⟶ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume "¬ HSTATE SD T"
        then have ffff1: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          using f9 f12 by metis
        have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          by auto
        then have "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          using ffff1 by metis }
      ultimately have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      have "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using aaa1 by metis
      then have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using f16 by metis }
    ultimately have "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f42: "¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f43: "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE SMD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f42 f43 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
327.501s elapsed time, 88.109s cpu time, 1.750s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant i652 nextGOPending_DeviceSMAGO_other nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f4: "¬ CSTATE IMA T 0 ∨ ¬ HSTATE SharedM T"
    using i652 by moura
  have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE IMA T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 CSTATE_various_forms6 SWMR_def devcache2_copy_perform1_invariant i0 i72) 
zipperposition found a proof... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_various_forms2 CSTATE_various_forms6 SWMR_def
    devcache2_copy_perform1_invariant i0 i72)

Isar proof:
proof -
  have f1: "SWMR T"
    using i0 by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have f3: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have f4: "∀t. devcache2 (t [ -=i 0]) = devcache2 t"
    using devcache2_copy_perform1_invariant by moura
  have f5: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀t. CLEntry.block_state (devcache1 t) ≠ Modified ∨ CLEntry.block_state (devcache2 t) ≠ Shared ∨ ¬ SWMR t"
    using SWMR_def by moura
  then have "(∃m. m ≠ Modified ∧ CSTATE m T 0) ∨ CLEntry.block_state (devcache2 T) ≠ Modified ∧ CLEntry.block_state (devcache2 T) ≠ Shared ∨ CSTATE Modified T 1"
    using f5 f3 f1 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE Modified T 0"
      using f2 by metis }
  moreover
  { assume aa1: "CLEntry.block_state (devcache2 T) ≠ Modified ∧ CLEntry.block_state (devcache2 T) ≠ Shared"
    { have "CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Modified ∧ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared"
        using aa1 f4 by metis }
    then have "(CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
      by moura }
  moreover
  { assume "∃m. m ≠ Modified ∧ CSTATE m T 0"
    then have "¬ CSTATE Modified T 0"
      using f6 by metis }
  ultimately have "CSTATE Modified T 0 ⟶ (CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared ∨ CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Modified) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (CLEntry.block_state (devcache1 (T [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache2 (T [ -=i 0])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 (T [ -=i 0])) = Modified ⟶ CLEntry.block_state (devcache1 (T [ -=i 0])) ≠ Shared)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 CSTATE_various_forms6 SWMR_def devcache2_copy_perform1_invariant i0 i72) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i463 i72 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant nextHTDDataPending_general_rule_12_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr175 veriT_vr176 veriT_vr177. CSTATE veriT_vr175 veriT_vr176 veriT_vr177 ≠ CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr175 veriT_vr176 veriT_vr177. CSTATE veriT_vr175 veriT_vr176 veriT_vr177 ≠ CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr175 veriT_vr176 veriT_vr177. CSTATE veriT_vr175 veriT_vr176 veriT_vr177 = CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177)"
    by auto
  have f3: "(∃veriT_vr175 veriT_vr176 veriT_vr177. CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177 ∧ ¬ CSTATE veriT_vr175 veriT_vr176 veriT_vr177) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr175 veriT_vr176 veriT_vr177. CSTATE veriT_vr175 veriT_vr176 veriT_vr177 ≠ CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177) ∨ (∀veriT_vr175 veriT_vr176 veriT_vr177. ¬ CSTATE veriT_vr175 (veriT_vr176 [ -=i 0]) veriT_vr177 ∨ CSTATE veriT_vr175 veriT_vr176 veriT_vr177)"
    by auto
  then have "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  then have f4: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f5: "((∃veriT_vr120 veriT_vr121. nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 ≠ nextHTDDataPending veriT_vr120 veriT_vr121) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1) ∨ nextHTDDataPending (T [ -=i 0]) 1 ∧ ¬ nextHTDDataPending T 1"
    by auto
  have f6: "((∃veriT_vr120 veriT_vr121. nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 ≠ nextHTDDataPending veriT_vr120 veriT_vr121) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1) ∨ (∀veriT_vr120 veriT_vr121. nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 = nextHTDDataPending veriT_vr120 veriT_vr121)"
    by auto
  have f7: "(∃veriT_vr120 veriT_vr121. nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 ∧ ¬ nextHTDDataPending veriT_vr120 veriT_vr121) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by auto
  have "(∃veriT_vr120 veriT_vr121. nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 ≠ nextHTDDataPending veriT_vr120 veriT_vr121) ∨ (∀veriT_vr120 veriT_vr121. ¬ nextHTDDataPending (veriT_vr120 [ -=i 0]) veriT_vr121 ∨ nextHTDDataPending veriT_vr120 veriT_vr121)"
    by auto
  then have "(∃t n. nextHTDDataPending (t [ -=i 0]) n ≠ nextHTDDataPending t n) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    using f5 f6 f7 by metis
  then have f8: "¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by (metis nextHTDDataPending_general_rule_12_0)
  have "nextHTDDataPending (T [ -=i 0]) 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by auto
  then have "nextHTDDataPending (T [ -=i 0]) 1 ⟶ nextHTDDataPending T 1"
    using f8 by metis
  moreover
  { assume aa1: "nextHTDDataPending T 1"
    have "(CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1) ∨ ¬ nextHTDDataPending T 1"
      by auto
    then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1"
      using aa1 by metis
    then have ff2: "¬ CSTATE Modified T 0 ∧ ([] = dthdatas2 T ∨ nextSnpRespIs RspSFwdM T 1 ∨ HSTATE SD T)"
      by (metis i463)
    have "(CSTATE Modified T 0 ∨ [] ≠ dthdatas2 T ∧ ¬ nextSnpRespIs RspSFwdM T 1 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      using ff2 by metis }
  moreover
  { assume aa1: "¬ nextHTDDataPending (T [ -=i 0]) 1"
    have "(¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ nextHTDDataPending (T [ -=i 0]) 1"
      by auto
    then have ff2: "¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1"
      using aa1 by metis
    have "(CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1"
      by auto
    then have "(¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1"
      have "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
        by auto
      then have "CSTATE Modified (T [ -=i 0]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified (T [ -=i 0]) 1"
        using f4 by metis
      have "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
        by (metis i72) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis }
  ultimately have f9: "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    by metis
  have f10: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) = (CSTATE Modified T 0 ∧ nextStore T 0 ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  have f11: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0) ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f9 f10 f11 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_ISAGO_otherside_invariant2 CSTATE_disj1 HSTATE_ISAGO_invariant ISADGO'_HSTATE_neg
    ISAGO_nextHTDDataPending_otherside MESI_State.distinct(3) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5 i23)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_ISAGO_otherside_invariant2 by moura
  then have f4: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have f5: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f6: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f7: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f8: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  then have f9: "HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f8 f7 f6 f5 f4 f3 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    using f9 by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i463 i72 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant nextHTDDataPending_general_rule_12_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr351 veriT_vr352 veriT_vr353. CSTATE veriT_vr351 veriT_vr352 veriT_vr353 ≠ CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr351 veriT_vr352 veriT_vr353. CSTATE veriT_vr351 veriT_vr352 veriT_vr353 ≠ CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr351 veriT_vr352 veriT_vr353. CSTATE veriT_vr351 veriT_vr352 veriT_vr353 = CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353)"
    by auto
  have f3: "(∃veriT_vr351 veriT_vr352 veriT_vr353. CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353 ∧ ¬ CSTATE veriT_vr351 veriT_vr352 veriT_vr353) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr351 veriT_vr352 veriT_vr353. CSTATE veriT_vr351 veriT_vr352 veriT_vr353 ≠ CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353) ∨ (∀veriT_vr351 veriT_vr352 veriT_vr353. ¬ CSTATE veriT_vr351 (veriT_vr352 [ -=i 0]) veriT_vr353 ∨ CSTATE veriT_vr351 veriT_vr352 veriT_vr353)"
    by auto
  then have "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  then have f4: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f5: "((∃veriT_vr82 veriT_vr83. nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 ≠ nextHTDDataPending veriT_vr82 veriT_vr83) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1) ∨ nextHTDDataPending (T [ -=i 0]) 1 ∧ ¬ nextHTDDataPending T 1"
    by auto
  have f6: "((∃veriT_vr82 veriT_vr83. nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 ≠ nextHTDDataPending veriT_vr82 veriT_vr83) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1) ∨ (∀veriT_vr82 veriT_vr83. nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 = nextHTDDataPending veriT_vr82 veriT_vr83)"
    by auto
  have f7: "(∃veriT_vr82 veriT_vr83. nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 ∧ ¬ nextHTDDataPending veriT_vr82 veriT_vr83) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by auto
  have "(∃veriT_vr82 veriT_vr83. nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 ≠ nextHTDDataPending veriT_vr82 veriT_vr83) ∨ (∀veriT_vr82 veriT_vr83. ¬ nextHTDDataPending (veriT_vr82 [ -=i 0]) veriT_vr83 ∨ nextHTDDataPending veriT_vr82 veriT_vr83)"
    by auto
  then have "(∃t n. nextHTDDataPending (t [ -=i 0]) n ≠ nextHTDDataPending t n) ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    using f5 f6 f7 by metis
  then have f8: "¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by (metis nextHTDDataPending_general_rule_12_0)
  have "nextHTDDataPending (T [ -=i 0]) 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1 ∨ nextHTDDataPending T 1"
    by auto
  then have "nextHTDDataPending (T [ -=i 0]) 1 ⟶ nextHTDDataPending T 1"
    using f8 by metis
  moreover
  { assume aa1: "nextHTDDataPending T 1"
    have "(CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1) ∨ ¬ nextHTDDataPending T 1"
      by auto
    then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1"
      using aa1 by metis
    then have ff2: "¬ CSTATE Modified T 0 ∧ ([] = dthdatas2 T ∨ nextSnpRespIs RspSFwdM T 1 ∨ HSTATE SD T)"
      by (metis i463)
    have "(CSTATE Modified T 0 ∨ [] ≠ dthdatas2 T ∧ ¬ nextSnpRespIs RspSFwdM T 1 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      using ff2 by metis }
  moreover
  { assume aa1: "¬ nextHTDDataPending (T [ -=i 0]) 1"
    have "(¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ nextHTDDataPending (T [ -=i 0]) 1"
      by auto
    then have ff2: "¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1"
      using aa1 by metis
    have "(CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1"
      by auto
    then have "(¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1"
      have "(CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
        by auto
      then have "CSTATE Modified (T [ -=i 0]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified (T [ -=i 0]) 1"
        using f4 by metis
      have "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
        by (metis i72) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis }
  ultimately have f9: "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    by metis
  have f10: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) = (CSTATE Modified T 0 ∧ nextLoad T 0 ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  have f11: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ CSTATE ISD (T [ -=i 0]) 0 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE ISD (T [ -=i 0]) 1 ∨ ¬ nextHTDDataPending (T [ -=i 0]) 1) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (CSTATE ISD (T [ -=i 0]) 0 ∧ nextHTDDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE ISD (T [ -=i 0]) 1 ∧ nextHTDDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f9 f10 f11 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i23 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i23 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_ISAGO_otherside_invariant2 CSTATE_assign_rule_2 CSTATE_disj1 HSTATE_ISAGO_invariant
    ISADGO'_HSTATE_neg ISAGO_nextHTDDataPending_otherside MESI_State.distinct(11,221,3) i106)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_ISAGO_otherside_invariant2 by moura
  then have f3: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have f4: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  then have f5: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f7: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f8: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f9: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f10: "ISA ≠ ISAD"
    using MESI_State.distinct(221) by moura
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "CSTATE ISA T 0 ∧ HSTATE SAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f10 f9 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume "¬ CSTATE ISA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f11 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f11 by metis
      then have "¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_remove_op dthdatas1_perform_instr i73 i897 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f3: "dthdatas1 T = [] ∨ ¬ CSTATE Modified T 0"
    using i897 by moura
  have f4: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f5: "∀t n. dthdatas1 t = dthdatas1 (t [ -=i n])"
    using dthdatas1_perform_instr by moura
  have f6: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
      by moura }
  moreover
  { assume "¬ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 0"
    then have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (HSTATE SAD (T [ -=i 0]) ∧ nextDTHDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ (HSTATE SAD (T [ -=i 0]) ∧ nextDTHDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(101,3) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_oppo_def SMAGO_nextDTHDataPending_sameside
    SMAGO_nextHTDDataPending_otherside i13 nextGOPending_yes_reqresp_rule_4_1 nextReqIs_SMAGO)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextHTDDataPending_otherside by moura
  then have f5: "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SMAGO_nextDTHDataPending_sameside by moura
  then have f6: "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have f8: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f7 f6 f5 f4 f3 by metis
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f9 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f9 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f9 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    using f8 by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_remove_op dthdatas1_perform_instr i73 i897 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f3: "dthdatas1 T = [] ∨ ¬ CSTATE Modified T 0"
    using i897 by moura
  have f4: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f5: "∀t n. dthdatas1 t = dthdatas1 (t [ -=i n])"
    using dthdatas1_perform_instr by moura
  have f6: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 0"
    then have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (¬ CSTATE Modified (T [ -=i 0]) 0 ∨ ¬ HSTATE SAD (T [ -=i 0]) ∨ ¬ nextDTHDataPending (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (HSTATE SAD (T [ -=i 0]) ∧ nextDTHDataPending (T [ -=i 0]) 0 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∧ (HSTATE SAD (T [ -=i 0]) ∧ nextDTHDataPending (T [ -=i 0]) 1 ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op C_not_C_msg_def i49 i72 nextGOPending_DeviceModifiedStore) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
SH Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_oppo_def H_msg_P_same_def ISADGO'_HSTATE_neg
    SMAGO_nextSnpRespIs_otherside SMAGO_nextSnpRespIs_sameside i14 i15 nextReqIs_SMAGO)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f4: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextSnpRespIs_otherside by moura
  then have f5: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SMAGO_nextSnpRespIs_sameside by moura
  then have f6: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  then have f9: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f8 f7 f6 f5 f4 f3 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    using f9 by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_7 HSTATE_XYAGO1 ISADGO'_HSTATE_neg
    MESI_State.distinct(3) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5 i22)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f4: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_otherside_rule_7 by moura
  have f5: "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_XYAGO1 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f8: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f9: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f1 f4 by metis
  have "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using f1 f5 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f9 f8 f7 f6 f3 f2 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i22 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op C_not_C_msg_def i49 i72 nextGOPending_DeviceModifiedStore) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 i72 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SMAGO_invariant H_msg_P_same_def ISADGO'_HSTATE_neg SMAGO_nextSnpRespIs_otherside
    SMAGO_nextSnpRespIs_sameside i14 i15 nextReqIs_SMAGO)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SMAGO_nextSnpRespIs_otherside by moura
  then have f4: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SMAGO_nextSnpRespIs_sameside by moura
  then have f5: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SMAGO by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SMAGO_invariant by moura
  then have f7: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  then have f8: "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f7 f6 f5 f4 f3 by metis
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f9 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f9 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IMA T 0 ∨ ¬ nextGOPending T 0"
    using f8 by metis
  then show "CSTATE IMA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Modified] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i22 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 i72 remove_instr_HSTATE) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_7 HSTATE_XYAGO1 ISADGO'_HSTATE_neg
    MESI_State.distinct(3) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5 i22)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f4: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_otherside_rule_7 by moura
  have f5: "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_XYAGO1 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f8: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f9: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f1 f4 by metis
  have "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using f1 f5 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f9 f8 f7 f6 f3 f2 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this: apply (metis HSTATE_ISAGO_invariant ISADGO'_HSTATE_neg i747 nextGOPending_DeviceISAGO_other)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE ISA T 0 ∨ ¬ HSTATE ModifiedM T"
    using i747 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISA T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
310.627s elapsed time, 77.578s cpu time, 6.234s GC time 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_ISAGO_invariant ISAGO_nextHTDDataPending_otherside i747 nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 B_x. zz X1 B_x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE ISA T 0 ∨ ¬ HSTATE ModifiedM T"
    using i747 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISA T 0"
        using aa1 f3 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_general_rule_10_0 dthdatas1_perform_instr dthdatas2_remove_op i189 i73 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀h t. HSTATE h t ∨ ¬ HSTATE h (t [ -=i 0])"
    using HSTATE_general_rule_10_0 by moura
  have f3: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f4: "dthdatas1 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f5: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f6: "∀t n. dthdatas1 t = dthdatas1 (t [ -=i n])"
    using dthdatas1_perform_instr by moura
  have f7: "∀t. dthdatas2 t = dthdatas2 (t [ -=i 0])"
    using dthdatas2_remove_op by moura
  have f8: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ∧ HSTATE ModifiedM T ∧ dthdatas2 T = [] ⟶ ¬ nextDTHDataPending (T [ -=i 0]) 0 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 1"
    using f8 f7 f6 f5 f4 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ nextDTHDataPending (T [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∧ (¬ nextDTHDataPending (T [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending (T [ -=i 0]) 0 ∧ ¬ nextDTHDataPending (T [ -=i 0]) 1"
    then have "(¬ nextDTHDataPending (T [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∧ (¬ nextDTHDataPending (T [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "dthdatas2 T ≠ []"
    then have "¬ HSTATE ModifiedM T"
      using f3 by metis }
  ultimately have "HSTATE ModifiedM T ⟶ (¬ nextDTHDataPending (T [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∧ (¬ nextDTHDataPending (T [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM T"
    { have "¬ HSTATE ModifiedM (T [ -=i 0])"
        using aa1 f2 by metis }
    then have "(¬ nextDTHDataPending (T [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∧ (¬ nextDTHDataPending (T [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending (T [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∧ (¬ nextDTHDataPending (T [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending (T [ -=i 0]) 1) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending (T [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i489 i845 nextSnpRespIs_general_rule_13_0 nextSnpRespIs_property1 nextSnpRespIs_property2)

Isar proof:
proof -
  have f1: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f2: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have f3: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f4: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. ¬ nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∨ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f1 f2 f3 by metis
  then have f5: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f6: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T"
    by auto
  have f7: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  have f8: "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  have "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  then have f9: "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f6 f7 f8 by (metis nextSnpRespIs_property2)
  have f10: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f11: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f10 f11 f4 by metis
  then have f12: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f13: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T"
    by auto
  have f14: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  have f15: "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  have "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  then have f16: "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f13 f14 f15 by (metis nextSnpRespIs_property1)
  have "nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f16 by metis
  moreover
  { assume "[] ≠ snpresps1 T"
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by (metis i845) }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 0"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
      using f12 by metis
    have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      using ff1 by metis
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      by auto
    then have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
        by auto
      then have "nextSnpRespIs RspIFwdM T 1"
        using fff2 f5 by metis
      then have fff3: "(¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∧ nextSnpRespIs RspIFwdM T 1"
        using f9 by metis
      have "nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
        by auto
      then have fff4: "[] ≠ snpresps2 T"
        using fff3 by metis
      have "([] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T) ∨ [] = snpresps2 T"
        by auto
      then have "[] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T"
        using fff4 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
        by (metis i489) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by metis }
  ultimately have f17: "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    by metis
  have f18: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) = (CSTATE Modified T 0 ∧ nextStore T 0 ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0))"
    by auto
  have f19: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0) ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    using f17 f18 f19 by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_ISAGO_invariant ISAGO_nextSnpRespIs_otherside i747 nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have f3: "¬ CSTATE ISA T 0 ∨ ¬ HSTATE ModifiedM T"
    using i747 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISA T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i489 i845 nextSnpRespIs_general_rule_13_0 nextSnpRespIs_property1 nextSnpRespIs_property2)

Isar proof:
proof -
  have f1: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f2: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have f3: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f4: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. ¬ nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∨ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f1 f2 f3 by metis
  then have f5: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f6: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T"
    by auto
  have f7: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  have f8: "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  have "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  then have f9: "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f6 f7 f8 by (metis nextSnpRespIs_property2)
  have f10: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f11: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f10 f11 f4 by metis
  then have f12: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f13: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T"
    by auto
  have f14: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  have f15: "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  have "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  then have f16: "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f13 f14 f15 by (metis nextSnpRespIs_property1)
  have "nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f16 by metis
  moreover
  { assume "[] ≠ snpresps1 T"
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by (metis i845) }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 0"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
      using f12 by metis
    have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      using ff1 by metis
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      by auto
    then have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
        by auto
      then have "nextSnpRespIs RspIFwdM T 1"
        using fff2 f5 by metis
      then have fff3: "(¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∧ nextSnpRespIs RspIFwdM T 1"
        using f9 by metis
      have "nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
        by auto
      then have fff4: "[] ≠ snpresps2 T"
        using fff3 by metis
      have "([] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T) ∨ [] = snpresps2 T"
        by auto
      then have "[] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T"
        using fff4 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
        by (metis i489) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
      by metis }
  ultimately have f17: "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    by metis
  have f18: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) = (CSTATE Modified T 0 ∧ nextLoad T 0 ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0))"
    by auto
  have f19: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0)"
    using f17 f18 f19 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_ISAGO_invariant ISAGO_nextSnpRespIs_otherside i747 nextGOPending_yes_reqresp_rule_4_1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 x. zz X1 x = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have f3: "¬ CSTATE ISA T 0 ∨ ¬ HSTATE ModifiedM T"
    using i747 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_ISAGO_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE ISA T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i489 i845 nextSnpRespIs_general_rule_13_0 nextSnpRespIs_property1 nextSnpRespIs_property2)

Isar proof:
proof -
  have f1: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f2: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have f3: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f4: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. ¬ nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∨ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f1 f2 f3 by metis
  then have f5: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f6: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T"
    by auto
  have f7: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  have f8: "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  have "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  then have f9: "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f6 f7 f8 by (metis nextSnpRespIs_property1)
  have f10: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f11: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f10 f11 f4 by metis
  then have f12: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f13: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T"
    by auto
  have f14: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  have f15: "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  have "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  then have f16: "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f13 f14 f15 by (metis nextSnpRespIs_property2)
  have "nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f16 by metis
  moreover
  { assume aa1: "[] ≠ snpresps2 T"
    have "([] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T) ∨ [] = snpresps2 T"
      by auto
    then have "[] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T"
      using aa1 by metis
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by (metis i489) }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 1"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∧ ¬ nextSnpRespIs RspIFwdM T 1"
      using f12 by metis
    have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      using ff1 by metis
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      using ff2 by metis
    then have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "nextSnpRespIs RspIFwdM T 0"
        using fff2 f5 by metis
      then have fff3: "(¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∧ nextSnpRespIs RspIFwdM T 0"
        using f9 by metis
      have "nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
        by auto
      then have "[] ≠ snpresps1 T"
        using fff3 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
        by (metis i845) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by metis }
  ultimately have f17: "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    by metis
  have f18: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) = (CSTATE Modified T 0 ∧ nextStore T 0 ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1))"
    by auto
  have f19: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ≠ ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0) ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ∨ (CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) = ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    using f17 f18 f19 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) i489 i845 nextSnpRespIs_general_rule_13_0 nextSnpRespIs_property1 nextSnpRespIs_property2)

Isar proof:
proof -
  have f1: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f2: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have f3: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f4: "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. ¬ nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∨ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f1 f2 f3 by metis
  then have f5: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f6: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T"
    by auto
  have f7: "((∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  have f8: "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    by auto
  have "(∃veriT_vr448 veriT_vr449. nextSnpRespIs veriT_vr448 veriT_vr449 0 ∧ [] = snpresps1 veriT_vr449) ∨ (∀veriT_vr448 veriT_vr449. ¬ nextSnpRespIs veriT_vr448 veriT_vr449 0 ∨ [] ≠ snpresps1 veriT_vr449)"
    by auto
  then have f9: "¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
    using f6 f7 f8 by (metis nextSnpRespIs_property1)
  have f10: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1"
    by auto
  have f11: "((∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ≠ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∨ (∀veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 = nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277)"
    by auto
  have "(∃veriT_vr275 veriT_vr276 veriT_vr277. nextSnpRespIs veriT_vr275 (veriT_vr276 [ -=i 0]) veriT_vr277 ∧ ¬ nextSnpRespIs veriT_vr275 veriT_vr276 veriT_vr277) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by auto
  then have "(∃s t n. nextSnpRespIs s (t [ -=i 0]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    using f10 f11 f4 by metis
  then have f12: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
    by (metis nextSnpRespIs_general_rule_13_0)
  have f13: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T"
    by auto
  have f14: "((∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  have f15: "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  have "(∃veriT_vr464 veriT_vr465. nextSnpRespIs veriT_vr464 veriT_vr465 1 ∧ [] = snpresps2 veriT_vr465) ∨ (∀veriT_vr464 veriT_vr465. ¬ nextSnpRespIs veriT_vr464 veriT_vr465 1 ∨ [] ≠ snpresps2 veriT_vr465)"
    by auto
  then have f16: "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f13 f14 f15 by (metis nextSnpRespIs_property2)
  have "nextSnpRespIs RspIFwdM T 1 ∧ [] = snpresps2 T ∨ ¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    by auto
  then have "¬ nextSnpRespIs RspIFwdM T 1 ∨ [] ≠ snpresps2 T"
    using f16 by metis
  moreover
  { assume aa1: "[] ≠ snpresps2 T"
    have "([] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T) ∨ [] = snpresps2 T"
      by auto
    then have "[] ≠ snps2 T ∨ [] ≠ snpresps2 T ∨ [] ≠ reqresps1 T ∨ [] ≠ htddatas1 T"
      using aa1 by metis
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by (metis i489) }
  moreover
  { assume "¬ nextSnpRespIs RspIFwdM T 1"
    then have ff1: "(¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1) ∧ ¬ nextSnpRespIs RspIFwdM T 1"
      using f12 by metis
    have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM T 1 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1 ∨ nextSnpRespIs RspIFwdM T 1"
      by auto
    then have ff2: "¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      using ff1 by metis
    have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1"
      using ff2 by metis
    then have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
      have "(HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∨ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
        by auto
      then have fff2: "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0"
        using aaa1 by metis
      have "nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "nextSnpRespIs RspIFwdM T 0"
        using fff2 f5 by metis
      then have fff3: "(¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T) ∧ nextSnpRespIs RspIFwdM T 0"
        using f9 by metis
      have "nextSnpRespIs RspIFwdM T 0 ∧ [] = snpresps1 T ∨ ¬ nextSnpRespIs RspIFwdM T 0 ∨ [] ≠ snpresps1 T"
        by auto
      then have "[] ≠ snpresps1 T"
        using fff3 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
        by (metis i845) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
      by metis }
  ultimately have f17: "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    by metis
  have f18: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) = (CSTATE Modified T 0 ∧ nextLoad T 0 ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1))"
    by auto
  have f19: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ≠ ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 0) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ ((¬ HSTATE ModifiedM (T [ -=i 0]) ∨ ¬ nextReqIs RdShared (T [ -=i 0]) 1) ∨ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) ∨ (CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)) = ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0 ∨ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1) ∧ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 0) ∧ (HSTATE ModifiedM (T [ -=i 0]) ∧ nextReqIs RdShared (T [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM (T [ -=i 0]) 1)"
    using f17 f18 f19 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_2 CSTATE_inequality_invariant CSTATE_otherside_rule_7 HSTATE_XYAGO1
    ISADGO'_HSTATE_neg MESI_State.distinct(3) i23)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f3: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_otherside_rule_7 by moura
  have f4: "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_XYAGO1 by moura
  have f5: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f8: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f1 f3 by metis
  have f9: "∀h t z m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0])"
    using f1 f4 by metis
  have "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f5 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f9 f8 f7 f6 f2 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE ISA T 0 ∨ ¬ nextGOPending T 0"
    by metis
  then show "CSTATE ISA T 0 ∧ nextGOPending T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Shared] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
276.167s elapsed time, 63.984s cpu time, 6.000s GC time 
METHOD Future: starting 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this: apply (smt (verit) HSTATE_general_rule_10_0 i23 i72 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have f3: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. ¬ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∨ CSTATE veriT_vr335 veriT_vr336 veriT_vr337)"
    by auto
  then have f4: "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T"
    by auto
  have f6: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ (∀veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) = HSTATE veriT_vr224 veriT_vr225)"
    by auto
  have f7: "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∧ ¬ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ (∀veriT_vr224 veriT_vr225. ¬ HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∨ HSTATE veriT_vr224 veriT_vr225)"
    by auto
  then have f8: "(∃h t. HSTATE h (t [ -=i 0]) ≠ HSTATE h t) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f5 f6 f7 by metis
  have f9: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f4 by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f10: "¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f8 by (metis HSTATE_general_rule_10_0)
  have "HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  then have "HSTATE SD (T [ -=i 0]) ⟶ HSTATE SD T"
    using f10 by metis
  moreover
  { assume "HSTATE SD T"
    then have ff1: "¬ CSTATE Modified T 0 ∧ ¬ CSTATE Modified T 1"
      by (metis i23)
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      using ff1 by metis }
  moreover
  { assume aa1: "¬ HSTATE SD (T [ -=i 0])"
    have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
      by auto
    then have ff2: "¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])"
      using aa1 by metis
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1"
      have "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
        by auto
      then have "CSTATE Modified (T [ -=i 0]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified (T [ -=i 0]) 1"
        using f9 by metis
      have "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
        by (metis i72) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis }
  ultimately have f11: "¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    by metis
  have f12: "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextStore T 0) ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextStore T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextStore T 0 ⟶ (CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f11 f12 by metis
next 
verit found a proof... 
verit: Try this: apply (smt (verit) HSTATE_general_rule_10_0 i23 i72 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have f3: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. ¬ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∨ CSTATE veriT_vr335 veriT_vr336 veriT_vr337)"
    by auto
  then have f4: "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr226 veriT_vr227. HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) ≠ HSTATE veriT_vr226 veriT_vr227) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T"
    by auto
  have f6: "((∃veriT_vr226 veriT_vr227. HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) ≠ HSTATE veriT_vr226 veriT_vr227) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ (∀veriT_vr226 veriT_vr227. HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) = HSTATE veriT_vr226 veriT_vr227)"
    by auto
  have f7: "(∃veriT_vr226 veriT_vr227. HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) ∧ ¬ HSTATE veriT_vr226 veriT_vr227) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr226 veriT_vr227. HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) ≠ HSTATE veriT_vr226 veriT_vr227) ∨ (∀veriT_vr226 veriT_vr227. ¬ HSTATE veriT_vr226 (veriT_vr227 [ -=i 0]) ∨ HSTATE veriT_vr226 veriT_vr227)"
    by auto
  then have f8: "(∃h t. HSTATE h (t [ -=i 0]) ≠ HSTATE h t) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f5 f6 f7 by metis
  have f9: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f4 by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f10: "¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f8 by (metis HSTATE_general_rule_10_0)
  have "HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  then have "HSTATE SD (T [ -=i 0]) ⟶ HSTATE SD T"
    using f10 by metis
  moreover
  { assume "HSTATE SD T"
    then have ff1: "¬ CSTATE Modified T 0 ∧ ¬ CSTATE Modified T 1"
      by (metis i23)
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      using ff1 by metis }
  moreover
  { assume aa1: "¬ HSTATE SD (T [ -=i 0])"
    have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
      by auto
    then have ff2: "¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])"
      using aa1 by metis
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff2 by metis
    then have "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1"
      have "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
        by auto
      then have "CSTATE Modified (T [ -=i 0]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified (T [ -=i 0]) 1"
        using f9 by metis
      have "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
        by (metis i72) }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
      by metis }
  ultimately have f11: "¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    by metis
  have f12: "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Modified T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextLoad T 0 ⟶ (CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f11 f12 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
236.770s elapsed time, 60.891s cpu time, 7.641s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
230.103s elapsed time, 58.984s cpu time, 7.594s GC time 
SH Future: starting 
Sledgehammering... 
user method didnt solve goal 
METHOD Future: result = fail 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_def CSTATE_disj4' CSTATE_inequality_invariant CSTATE_various_forms1 CSTATE_various_forms2
    MESI_State.distinct(5,95) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_def CSTATE_inequality_invariant CSTATE_various_forms1 CSTATE_various_forms2
    MESI_State.distinct(5,95) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 MESI_State.distinct(139,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method didnt solve goal 
METHOD Future: result = fail 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 MESI_State.distinct(139,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5) 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SIAGO_WritePullDrop_otherside_invariant2 CSTATE_disj1 MESI_State.distinct(139,5,7)
    SIAGO_WritePullDrop_CSTATE_aux SMAGO_nextGOPendingIs_otherside SharedSnpInv'_CSTATE_invariant5
    nextGOPendingIs_XIAGOWPD_otherside1)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X4. zz X1 X4 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SIAGO_WritePullDrop_otherside_invariant2 by moura
  then have f3: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have f4: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f5: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f6: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f7: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f8: "Invalid ≠ ISD"
    using MESI_State.distinct(139) by moura
  have "Modified ≠ ISD"
    using MESI_State.distinct(7) by moura
  then have f9: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f8 f7 f6 f5 f4 f3 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE ISD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    using f9 by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE ISD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextHTDDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SIAGO_WritePullDrop_otherside_invariant2 C_msg_P_same_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextHTDDataPending_sameside SMAGO_nextHTDDataPending_otherside i23 i329 i35
    remove_instr_HSTATE)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f4: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SIAGO_WritePullDrop_otherside_invariant2 by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f3 by metis
  have "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_nextHTDDataPending_sameside by moura
  then have f6: "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f3 by metis
  have f7: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f9: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f2 f7 by metis
  have f10: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextDTHDataPending t n) T"
    using i329 by moura
  then have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ∧ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f10 f9 f8 f6 f5 f3 f4 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f8 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f8 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SIAGO_WritePullDrop_otherside_invariant2 C_msg_P_same_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextHTDDataPending_sameside SMAGO_nextHTDDataPending_otherside i23 i35 remove_instr_HSTATE)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f4: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SIAGO_WritePullDrop_otherside_invariant2 by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f3 by metis
  have "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_nextHTDDataPending_sameside by moura
  then have f6: "∀t m. nextDTHDataPending t 0 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f3 by metis
  have f7: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f8: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f9: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f2 f7 by metis
  have f10: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextDTHDataPending t n) T"
    using i35 by moura
  then have "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE IIA T 0 ∧ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f10 f9 f8 f6 f5 f3 f4 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f8 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f8 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_2 CSTATE_disj1 CSTATE_inequality_invariant CSTATE_otherside_rule_4_0 CSTATE_remove_op
    ISADGO'_HSTATE_neg MESI_State.distinct(11,289,5) hstate_invariants(14,2,24) i106 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f10: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_4_0 by moura
  have f11: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f12: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f13: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f14: "ISAD ≠ SIA"
    using MESI_State.distinct(289) by moura
  have f15: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f2 by metis
  have f16: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f9 by metis
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f10 by metis
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ (∃m. SIA ≠ m ∧ CSTATE m T 0) ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f16 f15 f14 f13 f12 f11 f8 f7 f6 f5 f4 by metis
  moreover
  { assume aa1: "∃m. SIA ≠ m ∧ CSTATE m T 0"
    { have "¬ CSTATE SIA T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_2 CSTATE_disj1 CSTATE_inequality_invariant CSTATE_otherside_rule_6 CSTATE_remove_op
    ISADGO'_HSTATE_neg MESI_State.distinct(11,277,5) hstate_invariants(14,2,24) i106 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f10: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_6 by moura
  have f11: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f12: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f13: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f14: "ISAD ≠ IIA"
    using MESI_State.distinct(277) by moura
  have f15: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f2 by metis
  have f16: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f9 by metis
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f10 by metis
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ (∃m. IIA ≠ m ∧ CSTATE m T 0) ∨ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f16 f15 f14 f13 f12 f11 f8 f7 f6 f5 f4 by metis
  moreover
  { assume aa1: "∃m. IIA ≠ m ∧ CSTATE m T 0"
    { have "¬ CSTATE IIA T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(143,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
user method didnt solve goal 
METHOD Future: result = fail 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(143,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_2 CSTATE_inequality_invariant CSTATE_otherside_rule_4_0 CSTATE_remove_op
    ISADGO'_HSTATE_neg MESI_State.distinct(5) hstate_invariants(14,2,24) i22 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f10: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_4_0 by moura
  have f11: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f12: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f3 by metis
  have f13: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f9 by metis
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f10 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f13 f12 f11 f8 f7 f6 f5 f4 f2 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SIAGO_WritePullDrop_otherside_invariant2 CSTATE_disj1 CSTATE_otherside_rule_6 CSTATE_remove_op
    C_msg_P_same_def C_msg_state_def ISADGO'_HSTATE_neg SIAGO_WritePullDrop_CSTATE_aux SMAGO_nextGOPendingIs_otherside
    SharedSnpInv'_CSTATE_invariant5 i22 i34 i47 nextReqIs_general_rule_6_0 nextReqIs_remove_op remove_instr_HSTATE)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zz B_X x = Some B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f3: "∀X1 X6. zza X1 X6 = X1"
    by moura
  have f4: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SIAGO_WritePullDrop_otherside_invariant2 by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz ma) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have f6: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_CSTATE_aux by moura
  have f7: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f8: "∀X0. zza (Some X0) = zz X0"
    by moura
  then have f9: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zza z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f3 f7 by metis
  have f10: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f11: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f12: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f13: "∀r t n na. nextReqIs r t n ∨ ¬ nextReqIs r (t [ -=i na]) n"
    using nextReqIs_remove_op by moura
  have f14: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ]) n"
    using nextReqIs_general_rule_6_0 by moura
  then have f15: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza z) t [ 0 s= m] [ 0 -=reqresp ]) n"
    using f3 by metis
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_6 by moura
  then have f16: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f3 by metis
  have "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i34 by moura
  then have f17: "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  have f18: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f19: "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have "∀z m. zza (zz m z) = zz m"
    using f8 f2 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE IIA T 0 ∧ HSTATE SharedM ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f19 f18 f17 f1 f16 f15 f14 f13 f12 f11 f10 f9 f6 f5 f4 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f8 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f8 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SharedM ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f8 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_2 CSTATE_inequality_invariant CSTATE_otherside_rule_4_0 CSTATE_remove_op
    ISADGO'_HSTATE_neg MESI_State.distinct(5) hstate_invariants(14,2,24) i22 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using CSTATE_assign_rule_2 by moura
  have f4: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀m t n na. CSTATE m t n ∨ ¬ CSTATE m (t [ -=i na]) n"
    using CSTATE_remove_op by moura
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=reqresp ])"
    using hstate_invariants(14) by moura
  have f9: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f10: "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using CSTATE_otherside_rule_4_0 by moura
  have f11: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f12: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f1 f3 by metis
  have f13: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f9 by metis
  have "∀m t z ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [ 0 s= ma] [ 0 -=reqresp ]) 1"
    using f1 f10 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f13 f12 f11 f8 f7 f6 f5 f4 f2 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_SIAGO_WritePullDrop_otherside_invariant2 CSTATE_disj1 C_msg_P_same_def C_msg_state_def
    H_C_state_msg_same_def ISADGO'_HSTATE_neg SMAGO_nextGOPendingIs_otherside i22 i325 i327 i36 i47 i510 i676 i699 i702
    nextReqIs_SIAGO_WritePullDrop)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have "H_C_state_msg_same ModifiedM Modified (λt n. ¬ nextReqIs RdShared t n) T"
    using i36 by moura
  then have f4: "H_C_state_msg_same ModifiedM Modified bb T"
    using f1 by metis
  have "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t⦇buffer1 := Some ma⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using CSTATE_SIAGO_WritePullDrop_otherside_invariant2 by moura
  then have f5: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f3 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f3 by metis
  have f7: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f8: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i325 by moura
  then have f9: "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  have f10: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE InvalidM T"
    using i676 by moura
  have f11: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SB T"
    using i702 by moura
  have f12: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE IB T"
    using i699 by moura
  have f13: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f14: "HSTATE SharedM T ∨ HSTATE IB T ∨ HSTATE ID T ∨ HSTATE ModifiedM T ∨ HSTATE SB T ∨ HSTATE InvalidM T ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0 ∨ ¬ CSTATE SIA T 0"
    using i327 by moura
  have f15: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE ID T"
    using i510 by moura
  have "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  then have f16: "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM T ∧ ¬ HSTATE IB T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE SB T ∧ ¬ HSTATE InvalidM T"
    using f15 f13 f12 f11 f10 f9 f8 f7 f6 f5 f4 f1 by metis
  have f17: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f17 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f17 by metis
      then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SharedM T ∧ ¬ HSTATE IB T ∧ ¬ HSTATE ID T ∧ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE SB T ∧ ¬ HSTATE InvalidM T"
    then have "¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      using f14 by metis }
  ultimately have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ⟶ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    using f16 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 C_msg_P_same_def C_msg_state_def H_C_state_msg_oppo_def ISADGO'_HSTATE_neg
    SMAGO_nextGOPendingIs_otherside i34 i36 i41 i47 nextReqIs_SIAGO_WritePullDrop nextReqIs_general_rule_6_0
    nextReqIs_remove_op remove_instr_HSTATE)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zz B_X x = Some B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f3: "∀X1 X6. zza X1 X6 = X1"
    by moura
  have "H_C_state_msg_oppo ModifiedM IIA (λt n. ¬ nextReqIs RdShared t n) T"
    using i41 by moura
  then have f4: "H_C_state_msg_oppo ModifiedM IIA bb T"
    using f1 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f5: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have f6: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f7: "∀X0. zza (Some X0) = zz X0"
    by moura
  then have f8: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zza z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f3 f6 by metis
  have f9: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f10: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f11: "∀r t n na. nextReqIs r t n ∨ ¬ nextReqIs r (t [ -=i na]) n"
    using nextReqIs_remove_op by moura
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ]) n"
    using nextReqIs_general_rule_6_0 by moura
  then have f12: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza z) t [ 0 s= m] [ 0 -=reqresp ]) n"
    using f3 by metis
  have "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i34 by moura
  then have f13: "C_msg_P_same IIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  have f14: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE IIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f14 f13 f12 f11 f10 f9 f8 f7 f5 f2 f4 f1 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f7 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zza (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f7 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant C_msg_P_same_def C_msg_state_def
    SIAGO_WritePullDrop_nextHTDDataPending_otherside i13 i325 i329 i47 nextDTHDataPending_general_rule_1_0
    nextGOPendingIs_XYAGO_other1 nextReqIs_SIAGO_WritePullDrop)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X B_x. zz B_X B_x = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f5: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f3 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have "∀t n z m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextDTHDataPending_general_rule_1_0 by moura
  then have f7: "∀t n z m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i325 by moura
  then have f8: "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bb T"
    using f1 by metis
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextDTHDataPending t n) T"
    using i329 by moura
  then have f9: "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bba T"
    using f4 by metis
  have f10: "C_msg_state RdShared ISAD T"
    using i47 by moura
  have f11: "∀r t m. ¬ nextReqIs r t 0 ∨ CSTATE m t 0 ∨ ¬ C_msg_state r m t"
    using C_msg_state_def by moura
  have f12: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f3 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ⟶ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f11 f10 f9 f8 f1 f7 f6 f5 f4 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f12 by metis
      then have "¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_C_state_msg_oppo_def H_msg_P_oppo_def ISADGO'_HSTATE SIAGO_WritePullDrop_nextHTDDataPending_otherside
    i13 i41 nextGOPendingIs_XYAGO_other1 nextReqIs_SIAGO_WritePullDrop nextReqIs_general_rule_4_0
    nextReqIs_general_rule_6_0 nextReqIs_remove_op remove_instr_HSTATE)

Isar proof:
proof -
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f1: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X B_x. zz B_X B_x = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f3: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  have "H_C_state_msg_oppo ModifiedM IIA (λt n. ¬ nextReqIs RdShared t n) T"
    using i41 by moura
  then have f5: "H_C_state_msg_oppo ModifiedM IIA bba T"
    using f4 by metis
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f6: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f1 by metis
  have "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SIAGO_WritePullDrop_nextHTDDataPending_otherside by moura
  then have f7: "∀t m. nextDTHDataPending t 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f3 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f8: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f3 by metis
  have f9: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f10: "∀r t n na. nextReqIs r t n ∨ ¬ nextReqIs r (t [ -=i na]) n"
    using nextReqIs_remove_op by moura
  have "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ])"
    using ISADGO'_HSTATE by moura
  then have f11: "∀h t z n m na. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ])"
    using f2 by metis
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ]) n"
    using nextReqIs_general_rule_6_0 by moura
  then have f12: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ]) n"
    using f2 by metis
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_general_rule_4_0 by moura
  then have f13: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have f14: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f3 by metis
  then have "CSTATE IIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f13 f12 f11 f10 f9 f8 f7 f6 f1 f5 f4 by metis
  moreover
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f14 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f2 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f14 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f2 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f14 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f2 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis C_msg_P_same_def HSTATE_SIAGO_WritePullDrop_invariant H_msg_P_oppo_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextSnpRespIs_otherside SIAGO_WritePullDrop_nextSnpRespIs_sameside i14 i325
    nextReqIs_SIAGO_WritePullDrop nextReqIs_general_rule_4_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f5: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_nextSnpRespIs_sameside by moura
  then have f6: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_general_rule_4_0 by moura
  then have f9: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f1 by metis
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i325 by moura
  then have f10: "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bba T"
    using f4 by metis
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f10 f4 f9 f8 f7 f6 f5 f3 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f11 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f11 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f11 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant H_C_state_msg_oppo_def H_msg_P_oppo_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextSnpRespIs_otherside i14 i41 nextReqIs_SIAGO_WritePullDrop)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  have "H_C_state_msg_oppo ModifiedM IIA (λt n. ¬ nextReqIs RdShared t n) T"
    using i41 by moura
  then have f5: "H_C_state_msg_oppo ModifiedM IIA bba T"
    using f4 by metis
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i14 by moura
  then have f6: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SIAGO_WritePullDrop_nextSnpRespIs_otherside by moura
  then have f7: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f8: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  then have f9: "CSTATE IIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f8 f7 f6 f3 f5 f4 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    using f9 by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant H_C_state_msg_oppo_def H_msg_P_same_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextSnpRespIs_otherside SIAGO_WritePullDrop_nextSnpRespIs_sameside i14 i15 i41
    nextReqIs_SIAGO_WritePullDrop)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  have "H_C_state_msg_oppo ModifiedM IIA (λt n. ¬ nextReqIs RdShared t n) T"
    using i41 by moura
  then have f5: "H_C_state_msg_oppo ModifiedM IIA bba T"
    using f4 by metis
  have "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using SIAGO_WritePullDrop_nextSnpRespIs_sameside by moura
  then have f6: "∀s t m. nextSnpRespIs s t 0 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f7: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f8: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  then have f9: "CSTATE IIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f8 f7 f6 f3 f5 f4 by metis
  have f10: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume "¬ CSTATE IIA T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f10 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f10 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    using f9 by metis
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis C_msg_P_same_def HSTATE_SIAGO_WritePullDrop_invariant H_msg_P_same_def ISADGO'_HSTATE_neg
    SIAGO_WritePullDrop_nextSnpRespIs_otherside i14 i15 i325 nextReqIs_SIAGO_WritePullDrop nextReqIs_general_rule_4_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ nextSnpRespIs RspIFwdM X1 B_X)"
    by moura
  obtain bba :: "Type1State ⇒ nat ⇒ bool" where
    f4: "∀X1 B_X. bba X1 B_X = (¬ nextReqIs RdShared X1 B_X)"
    by moura
  have "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using SIAGO_WritePullDrop_nextSnpRespIs_otherside by moura
  then have f5: "∀s t m. nextSnpRespIs s t 1 ∨ ¬ nextSnpRespIs s ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1"
    using f2 by metis
  have "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_SIAGO_WritePullDrop by moura
  then have f6: "∀r t n m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) n"
    using f2 by metis
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f7: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have "H_msg_P_same ModifiedM (nextReqIs RdShared) (λt n. ¬ nextSnpRespIs RspIFwdM t n) T"
    using i15 by moura
  then have f8: "H_msg_P_same ModifiedM (nextReqIs RdShared) bb T"
    using f3 by metis
  have "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using nextReqIs_general_rule_4_0 by moura
  then have f9: "∀r t n z m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ] [ -=i 0]) n"
    using f1 by metis
  have "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) (λt n. ¬ nextReqIs RdShared t n) T"
    using i325 by moura
  then have f10: "C_msg_P_same SIA (nextGOPendingIs GO_WritePullDrop) bba T"
    using f4 by metis
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "nextGOPendingIs GO_WritePullDrop T 0 ∧ CSTATE SIA T 0 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    using f10 f4 f9 f8 f7 f6 f5 f3 by metis
  moreover
  { assume "¬ nextGOPendingIs GO_WritePullDrop T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextSnpRespIs RspIFwdM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f11 by metis
      then have "¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
    { have "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using aa1 f11 by metis
      then have "¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using aa1 f11 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by metis
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 ISADGO'_HSTATE_neg MESI_State.distinct(147,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
      ff1: "∀X1 X6. zz X1 X6 = X1"
      by moura
    have ff2: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
      using SIAGO_WritePullDrop_CSTATE_aux by moura
    have ff3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff4: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff5: "Modified ≠ Invalid"
      using MESI_State.distinct(5) by moura
    have ff6: "Invalid ≠ IMAD"
      using MESI_State.distinct(147) by moura
    have "∀m t ma. m = ma ∨ ¬ CSTATE ma ( t [ 0 s= m]) 0"
      using ff4 ff3 by metis
    then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
      using ff6 ff5 ff2 by metis
    then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
      using ff1 by metis }
  then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE SIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by moura
  then show "CSTATE SIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
286.953s elapsed time, 67.000s cpu time, 7.328s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant ISADGO'_HSTATE_neg MESI_State.distinct(147,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
      ff1: "∀X1 X6. zz X1 X6 = X1"
      by moura
    have ff2: "∀m t. CSTATE m t 0 ∨ ¬ CSTATE m (t [ 0 -=reqresp ] [ -=i 0]) 0"
      using SIAGO_WritePullDrop_CSTATE_aux by moura
    have ff3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
      using CSTATE_inequality_invariant by moura
    have ff4: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff5: "Modified ≠ Invalid"
      using MESI_State.distinct(5) by moura
    have "Invalid ≠ IMAD"
      using MESI_State.distinct(147) by moura
    then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
      using ff5 ff4 ff3 ff2 by metis
    then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0"
      using ff1 by metis }
  then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextGOPendingIs GO_WritePullDrop T 0"
    by moura
  then show "CSTATE IIA T 0 ∧ nextGOPendingIs GO_WritePullDrop T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
294.294s elapsed time, 67.969s cpu time, 5.688s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
382.385s elapsed time, 85.734s cpu time, 7.750s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_otherside_rule_8 CSTATE_various_forms1 CSTATE_various_forms4 SMDData_Modified i644) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(203,31) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(215,43) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_otherside_rule_5_0 i642 i921 nextHTDDataPending_otherside_rule_2_0
    nextHTDDataPending_various_forms1)

Isar proof:
proof -
  have f1: "((∃veriT_vr1507. nextHTDDataPending veriT_vr1507 0 ≠ ([] ≠ htddatas1 veriT_vr1507)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f2: "((∃veriT_vr1507. nextHTDDataPending veriT_vr1507 0 ≠ ([] ≠ htddatas1 veriT_vr1507)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1507. nextHTDDataPending veriT_vr1507 0 = ([] ≠ htddatas1 veriT_vr1507))"
    by auto
  have f3: "(∃veriT_vr1507. nextHTDDataPending veriT_vr1507 0 ∧ [] = htddatas1 veriT_vr1507) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1507. nextHTDDataPending veriT_vr1507 0 ≠ ([] ≠ htddatas1 veriT_vr1507)) ∨ (∀veriT_vr1507. ¬ nextHTDDataPending veriT_vr1507 0 ∨ [] ≠ htddatas1 veriT_vr1507)"
    by auto
  then have f4: "(∃t. nextHTDDataPending t 0 ≠ ([] ≠ htddatas1 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f6: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr38 veriT_vr39 1)"
    by auto
  have f7: "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr38 veriT_vr39 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr38 veriT_vr39 1) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41. ¬ CSTATE veriT_vr38 ( veriT_vr39 [ 0 s= veriT_vr40] [ 0 :=dd veriT_vr41] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr38 veriT_vr39 1)"
    by auto
  then have f8: "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f5 f6 f7 by metis
  have f9: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f4 by (metis nextHTDDataPending_various_forms1)
  have f10: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f8 by (metis CSTATE_otherside_rule_5_0)
  have f11: "((∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1) ∨ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending T 1"
    by auto
  have f12: "((∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1) ∨ (∀veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 = nextHTDDataPending veriT_vr17 1)"
    by auto
  have f13: "(∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending veriT_vr17 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by auto
  have "(∃veriT_vr17 veriT_vr18 veriT_vr19. nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending veriT_vr17 1) ∨ (∀veriT_vr17 veriT_vr18 veriT_vr19. ¬ nextHTDDataPending ( veriT_vr17 [ 0 s= veriT_vr18] [ 0 :=dd veriT_vr19] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending veriT_vr17 1)"
    by auto
  then have "(∃t m ma. nextHTDDataPending ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) 1 ≠ nextHTDDataPending t 1) ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    using f11 f12 f13 by metis
  then have f14: "¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by (metis nextHTDDataPending_otherside_rule_2_0)
  have "nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextHTDDataPending T 1"
    by auto
  then have "nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ nextHTDDataPending T 1"
    using f14 by metis
  moreover
  { assume aa1: "nextHTDDataPending T 1"
    have "(CSTATE ISA T 1 ∨ nextHTDDataPending T 1) ∨ ¬ nextHTDDataPending T 1"
      by auto
    then have "CSTATE ISA T 1 ∨ nextHTDDataPending T 1"
      using aa1 by metis
    then have ff2: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by (metis i642)
    have "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by auto
    then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      using ff2 by metis }
  moreover
  { assume aa1: "¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    have "(¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have ff2: "¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      using aa1 by metis
    have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    then have "(¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      using ff2 by metis
    then have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      have "(CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using aaa1 by metis
      then have fff2: "(¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using f10 by metis
      have "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
        by auto
      then have "CSTATE Modified T 1"
        using fff2 by metis
      then have "[] = htddatas1 T"
        by (metis i921)
      then have fff3: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f9 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff3 by metis }
    ultimately have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f15: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f16: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f17: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE ISD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextHTDDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f15 f16 f17 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this: apply (smt (verit) HOST_State.distinct(141,143,147,175,7,9) HSTATE_invariant3 HSTATE_rule_6 i366)

Isar proof:
proof -
  have f1: "((∃veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. HSTATE veriT_vr392 veriT_vr393 ≠ HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T"
    by auto
  have f2: "((∃veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. HSTATE veriT_vr392 veriT_vr393 ≠ HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ (∀veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. HSTATE veriT_vr392 veriT_vr393 = HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr392 veriT_vr393) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. HSTATE veriT_vr392 veriT_vr393 ≠ HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr392 veriT_vr393 veriT_vr394 veriT_vr395. ¬ HSTATE veriT_vr392 ( veriT_vr393 [ 0 s= veriT_vr394] [ 0 :=dd veriT_vr395] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr392 veriT_vr393)"
    by auto
  then have "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    using f1 f2 f3 by metis
  then have f4: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by (metis HSTATE_rule_6)
  have f5: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ MAD ≠ SAD ∧ MAD ≠ SAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have f6: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  have f7: "(∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. HSTATE veriT_vr140 veriT_vr138 ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141 ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  have f8: "(∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141 ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  then have f9: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f5 f6 f7 by metis
  have "HSTATE SD T ∧ MAD ≠ SAD ∧ SD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f10: "HSTATE SD T ∧ MAD ≠ SAD ∧ SD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SD T ∨ ¬ HSTATE MAD T"
    by (metis HOST_State.distinct(147,175))
  have f11: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T) ∨ HSTATE SD T ∧ SA ≠ SAD ∧ SA ≠ SAD ∧ SD ≠ SAD ∧ HSTATE SAD T"
    by auto
  have f12: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  have "(∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. HSTATE veriT_vr140 veriT_vr138 ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141 ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    by auto
  then have f13: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    using f11 f12 f8 by metis
  have "HSTATE SD T ∧ SA ≠ SAD ∧ SD ≠ SAD ∧ HSTATE SAD T ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    by auto
  then have f14: "HSTATE SD T ∧ SA ≠ SAD ∧ SD ≠ SAD ∧ HSTATE SAD T ∨ ¬ HSTATE SD T ∨ ¬ HSTATE SAD T"
    by (metis HOST_State.distinct(141,143))
  have f15: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ SAD ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have f16: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  have "(∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. HSTATE veriT_vr140 veriT_vr138 ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141 ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f17: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f15 f16 f8 by metis
  have "HSTATE SD T ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f18: "HSTATE SD T ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SD T ∨ ¬ HSTATE ModifiedM T"
    by (metis HOST_State.distinct(7,9))
  have f19: "¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ (¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) = (¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T)"
    by auto
  have "¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f20: "¬ HSTATE SD T ∨ MAD = SAD ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f19 by metis
  have f21: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ MAD ≠ SAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f20 f21 f9 by metis
  then have f22: "¬ HSTATE SD T ∨ MAD = SAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by (metis HSTATE_invariant3)
  have f23: "¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T ⟶ (¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T) = (¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T)"
    by auto
  have "¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T ⟶ ¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    by auto
  then have f24: "¬ HSTATE SD T ∨ SA = SAD ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T ⟶ ¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    using f23 by metis
  have f25: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T) ∨ HSTATE SD T ∧ SA ≠ SAD ∧ SD ≠ SAD ∧ HSTATE SAD T"
    by auto
  have "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    using f24 f25 f13 by metis
  then have f26: "¬ HSTATE SD T ∨ SA = SAD ∨ SD = SAD ∨ ¬ HSTATE SAD T"
    by (metis HSTATE_invariant3)
  have f27: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ (¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) = (¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T)"
    by auto
  have "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f28: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f27 by metis
  have f29: "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have "((∃veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. ((HSTATE veriT_vr137 veriT_vr138 ∨ HSTATE veriT_vr139 veriT_vr138 ∨ HSTATE veriT_vr140 veriT_vr138) ∧ veriT_vr137 ≠ veriT_vr141 ∧ veriT_vr139 ≠ veriT_vr141 ∧ veriT_vr140 ≠ veriT_vr141) ∧ HSTATE veriT_vr141 veriT_vr138) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr137 veriT_vr138 veriT_vr139 veriT_vr140 veriT_vr141. (¬ HSTATE veriT_vr137 veriT_vr138 ∧ ¬ HSTATE veriT_vr139 veriT_vr138 ∧ ¬ HSTATE veriT_vr140 veriT_vr138 ∨ veriT_vr137 = veriT_vr141 ∨ veriT_vr139 = veriT_vr141 ∨ veriT_vr140 = veriT_vr141) ∨ ¬ HSTATE veriT_vr141 veriT_vr138)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f28 f29 f17 by metis
  then have f30: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by (metis HSTATE_invariant3)
  have "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T ∨ HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE SAD T"
    by auto
  then have "HSTATE ModifiedM T ∨ HSTATE SAD T ∨ HSTATE MAD T ∨ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
    by metis
  moreover
  { assume "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
    then have ff1: "(¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0) ∧ (¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∧ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0)"
      by (metis i366)
    have "(CSTATE SMA T 0 ∧ nextGOPending T 0 ∨ CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by auto
    then have ff2: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
      using ff1 by metis
    have "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
      by auto
    then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      using ff2 by metis }
  moreover
  { assume "HSTATE MAD T"
    then have "¬ HSTATE SD T"
      using f22 f10 by metis }
  moreover
  { assume "HSTATE SAD T"
    then have "¬ HSTATE SD T"
      using f26 f14 by metis }
  moreover
  { assume "HSTATE ModifiedM T"
    then have "¬ HSTATE SD T"
      using f30 f18 by metis }
  ultimately have "HSTATE SD T ⟶ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE SD T"
    have "HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
      by auto
    then have ff2: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      using aa1 f4 by metis
    have ff3: "(HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      by auto
    have ff4: "(¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      by auto
    have ff5: "(HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      by auto
    have "(¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      by auto
    then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
      using ff2 ff3 ff4 ff5 by metis }
  ultimately have f31: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by metis
  have f32: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = (CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  have f33: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ≠ ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ ((¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ ((¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) ∨ (CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    by auto
  have "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)) = ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1))"
    by auto
  then show "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ (HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextDTHDataPending ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1)"
    using f31 f32 f33 by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(289,43) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(277,31) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_SMDData_otherside C_not_C_msg_def i337 i465 i478 i640 nextGOPending_DeviceSMDData) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SMDData_HSTATE i654) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SMDData_HSTATE i654) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
SH Future: starting 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 HSTATE_rule_6 MESI_State.distinct(265,331) i100 i417 i419 i456 i462 i577 i642
    i778 i833 i852 nextHTDDataPending_various_forms1 nextReqIs_general_rule_7_0 nextReqIs_nonempty_reqs1
    nextSnpRespIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ nextHTDDataPending T 0 ∧ [] = htddatas1 T"
    by auto
  have f2: "((∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∨ (∀veriT_vr1599. nextHTDDataPending veriT_vr1599 0 = ([] ≠ htddatas1 veriT_vr1599))"
    by auto
  have f3: "(∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ∧ [] = htddatas1 veriT_vr1599) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    by auto
  have "(∃veriT_vr1599. nextHTDDataPending veriT_vr1599 0 ≠ ([] ≠ htddatas1 veriT_vr1599)) ∨ (∀veriT_vr1599. ¬ nextHTDDataPending veriT_vr1599 0 ∨ [] ≠ htddatas1 veriT_vr1599)"
    by auto
  then have f4: "(∃t. nextHTDDataPending t 0 ≠ ([] ≠ htddatas1 t)) ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 = nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  have f7: "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∧ ¬ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have f8: "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. ¬ nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∨ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  then have f9: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f10: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f11: "((∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 = HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f12: "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr504 veriT_vr505) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. HSTATE veriT_vr504 veriT_vr505 ≠ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr504 veriT_vr505 veriT_vr506 veriT_vr507. ¬ HSTATE veriT_vr504 ( veriT_vr505 [ 0 s= veriT_vr506] [ 0 :=dd veriT_vr507] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr504 veriT_vr505)"
    by auto
  then have f13: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f10 f11 f12 by metis
  have f14: "¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
    using f4 by (metis nextHTDDataPending_various_forms1)
  have f15: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
    using f9 by (metis nextReqIs_general_rule_7_0)
  have f16: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
    using f13 by (metis HSTATE_rule_6)
  have f17: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f18: "((∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  have f19: "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1586 veriT_vr1587. nextReqIs veriT_vr1586 veriT_vr1587 0 ∧ [] = reqs1 veriT_vr1587) ∨ (∀veriT_vr1586 veriT_vr1587. ¬ nextReqIs veriT_vr1586 veriT_vr1587 0 ∨ [] ≠ reqs1 veriT_vr1587)"
    by auto
  then have f20: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f17 f18 f19 by (metis nextReqIs_nonempty_reqs1)
  have f21: "((∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f22: "((∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 = nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545)"
    by auto
  have f23: "(∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ∧ ¬ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ≠ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545) ∨ (∀veriT_vr541 veriT_vr542 veriT_vr543 veriT_vr544 veriT_vr545. ¬ nextSnpRespIs veriT_vr541 ( veriT_vr542 [ 0 s= veriT_vr543] [ 0 :=dd veriT_vr544] [ -=i 0] [ 0 -=devd ]) veriT_vr545 ∨ nextSnpRespIs veriT_vr541 veriT_vr542 veriT_vr545)"
    by auto
  then have f24: "(∃s t m ma n. nextSnpRespIs s ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f21 f22 f23 by metis
  have f25: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f26: "((∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ≠ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 = nextReqIs veriT_vr521 veriT_vr522 veriT_vr525)"
    by auto
  have "(∃veriT_vr521 veriT_vr522 veriT_vr523 veriT_vr524 veriT_vr525. nextReqIs veriT_vr521 ( veriT_vr522 [ 0 s= veriT_vr523] [ 0 :=dd veriT_vr524] [ -=i 0] [ 0 -=devd ]) veriT_vr525 ∧ ¬ nextReqIs veriT_vr521 veriT_vr522 veriT_vr525) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  then have f27: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f25 f26 f8 by metis
  have f28: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f24 by (metis nextSnpRespIs_general_rule_7_0)
  have f29: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
    using f27 by (metis nextReqIs_general_rule_7_0)
  have f30: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE IMD T 0 ∧ IMD ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f31: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. (¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175) ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  have f32: "(∃veriT_vr173 veriT_vr174 veriT_vr175. CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175 ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have f33: "(∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. ¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175 ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f30 f31 f32 by metis
  then have f34: "¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have f35: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ CSTATE IMD T 0 ∧ IMD ≠ IMAD ∧ CSTATE IMAD T 0"
    by auto
  have f36: "((∃veriT_vr173 veriT_vr174 veriT_vr175. (CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175) ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0) ∨ (∀veriT_vr173 veriT_vr174 veriT_vr175. (¬ CSTATE veriT_vr173 veriT_vr174 0 ∨ veriT_vr173 = veriT_vr175) ∨ ¬ CSTATE veriT_vr175 veriT_vr174 0)"
    by auto
  have "(∃veriT_vr173 veriT_vr174 veriT_vr175. CSTATE veriT_vr173 veriT_vr174 0 ∧ veriT_vr173 ≠ veriT_vr175 ∧ CSTATE veriT_vr175 veriT_vr174 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    using f35 f36 f33 by metis
  then have f37: "¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE IMD T 0 ∧ IMD ≠ IMAD ∧ CSTATE IMAD T 0 ∨ ¬ CSTATE IMD T 0 ∨ IMD = IMAD ∨ ¬ CSTATE IMAD T 0"
    by auto
  then have "CSTATE IMAD T 0 ⟶ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f37 by (metis MESI_State.distinct(331))
  moreover
  { assume aa1: "¬ CSTATE IMAD T 0"
    have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0"
      by auto
    then have "CSTATE Invalid T 0 ∨ CSTATE IIA T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE ISDI T 0 ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      using aa1 by metis
    moreover
    { assume "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      then have fff1: "¬ nextSnpRespIs RspIFwdM T 0 ∧ ¬ nextSnpRespIs RspIHitSE T 0"
        by (metis i456)
      have "(nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIHitSE T 0) ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "¬ nextSnpRespIs RspIFwdM T 0"
        using fff1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
        using f28 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff3: "¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using fff3 by metis }
    moreover
    { assume "CSTATE ISDI T 0"
      then have fff1: "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
        by (metis i778)
      have "HSTATE ModifiedM T ∧ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 1"
        by auto
      then have "¬ nextReqIs RdShared T 1 ∨ ¬ HSTATE ModifiedM T"
        using fff1 by metis
      moreover
      { assume "¬ nextReqIs RdShared T 1"
        then have ffff1: "(¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
          using f29 by metis
        have "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdShared T 1"
          by auto
        then have ffff2: "¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          using ffff1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          by auto
        then have "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
          using ffff2 by metis }
      ultimately have "HSTATE ModifiedM T ⟶ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by metis }
    moreover
    { assume "CSTATE ISAD T 0"
      then have fff1: "(¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∧ CSTATE ISAD T 0"
        using f34 by metis
      have "CSTATE IMD T 0 ∧ IMD ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
        by auto
      then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff1 by (metis MESI_State.distinct(265)) }
    moreover
    { assume aaa1: "CSTATE IIA T 0"
      have "CSTATE IIA T 0 ∧ HSTATE ModifiedM T ∨ ¬ CSTATE IIA T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i419) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    moreover
    { assume aaa1: "CSTATE Invalid T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have fff2: "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ (CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        using fff2 by metis
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i417) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ (¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      by metis
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using aaa1 f16 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using fff2 by metis }
    moreover
    { assume "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      then have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ CSTATE Modified T 1 ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ ¬ CSTATE Modified T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        by metis
      moreover
      { assume aaaa1: "(CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ ¬ CSTATE Modified T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by auto
        then have "CSTATE MIA T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE IMA T 0 ∧ ¬ CSTATE SMA T 0 ∧ ¬ nextHTDDataPending T 0"
          by (metis i577)
        have "(CSTATE IMA T 0 ∨ CSTATE SMA T 0 ∨ nextHTDDataPending T 0) ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      moreover
      { assume aaaa1: "CSTATE Modified T 1"
        have "(CSTATE Modified T 1 ∨ dthdatas1 T ≠ [] ∧ ¬ nextSnpRespIs RspSFwdM T 0 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 1"
          by auto
        then have "CSTATE Modified T 1 ∨ dthdatas1 T ≠ [] ∧ ¬ nextSnpRespIs RspSFwdM T 0 ∧ ¬ HSTATE SD T"
          using aaaa1 by metis
        then have "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
          by (metis i462) }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1"
        have ffff2: "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ nextGOPending T 1"
          by auto
        have ffff3: "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        have ffff4: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        have ffff5: "CSTATE SMA T 1 ∧ nextGOPending T 1 ∨ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1"
          by auto
        have "CSTATE IMA T 1 ∧ nextGOPending T 1 ∨ ¬ CSTATE IMA T 1 ∨ ¬ nextGOPending T 1"
          by auto
        then have "CSTATE SMA T 1 ∧ nextGOPending T 1 ∨ CSTATE IMA T 1 ∧ nextGOPending T 1"
          using aaaa1 ffff2 ffff3 ffff4 ffff5 by metis
        moreover
        { assume "CSTATE IMA T 1 ∧ nextGOPending T 1"
          then have "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
            by (metis i833) }
        moreover
        { assume "CSTATE SMA T 1 ∧ nextGOPending T 1"
          then have "[] = htddatas1 T"
            by (metis i852) }
        ultimately have "[] = htddatas1 T ∨ (¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
          by metis }
      ultimately have "[] = htddatas1 T ∨ nextHTDDataPending T 1 ∨ (¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume aaaa1: "(¬ CSTATE ISAD T 0 ∨ ¬ nextGOPending T 0) ∧ ¬ CSTATE ISA T 0 ∧ ¬ nextHTDDataPending T 0 ∧ ¬ CSTATE Shared T 0"
        have "(CSTATE ISAD T 0 ∧ nextGOPending T 0 ∨ CSTATE ISA T 0 ∨ nextHTDDataPending T 0 ∨ CSTATE Shared T 0) ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "nextHTDDataPending T 1"
        have "(CSTATE ISA T 1 ∨ nextHTDDataPending T 1) ∨ ¬ nextHTDDataPending T 1"
          by auto
        then have "CSTATE ISA T 1 ∨ nextHTDDataPending T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by (metis i642)
        have "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      ultimately have "[] = htddatas1 T ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ [] = htddatas1 T ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
      have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using aaa1 by metis }
    ultimately have "((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ [] = htddatas1 T ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
      then have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume aaaa1: "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        have "(HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          by auto
        then have ffff2: "HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          using aaaa1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          by auto
        then have ffff3: "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
          using ffff2 by metis
        have "nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ nextReqIs RdShared T 0"
          by auto
        then have "nextReqIs RdShared T 0"
          using ffff3 f15 by metis
        then have ffff4: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
          using f20 by metis
        have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
          by auto
        then have "[] ≠ reqs1 T"
          using ffff4 by metis
        then have "[] = htddatas1 T"
          by (metis i100) }
      ultimately have "[] = htddatas1 T ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "[] = htddatas1 T ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume "[] = htddatas1 T"
      then have fff1: "(¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T) ∧ [] = htddatas1 T"
        using f14 by metis
      have "nextHTDDataPending T 0 ∧ [] = htddatas1 T ∨ ¬ nextHTDDataPending T 0 ∨ [] ≠ htddatas1 T"
        by auto
      then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using fff1 by metis }
    ultimately have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f38: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f39: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = (CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  have f40: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ ¬ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ⟶ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ nextReqIs RdShared ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f38 f39 f40 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_invariant3 HSTATE_rule_16 i479 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    using i479 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h z t s ta m ma. HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) ∨ ¬ HSTATE h t"
    using HSTATE_rule_16 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t. ModifiedM ≠ h ∨ ¬ HSTATE h t ∨ ¬ HSTATE SAD t"
    using f4 f2 by metis
  have f10: "∀h z t s ta m ma. HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) ∨ ¬ HSTATE h t"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    using f10 f9 f8 f5 f3 by metis
  moreover
  { assume "¬ CSTATE MIA T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpData T 0"
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i479 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    using i479 by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. SAD ≠ h ∧ HSTATE h T)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. SAD ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE SAD T"
      using f3 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      using f2 by metis
    moreover
    { assume "¬ CSTATE MIA T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
        by moura }
    ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
Sledgehammering... 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_otherside_rule_5_0 HOST_State.distinct(175,7,85,9) HSTATE_invariant3
    HSTATE_rule_6 MESI_State.distinct(265) i106 i23 i366 i495 nextReqIs_general_rule_7_0)

Isar proof:
proof -
  have f1: "((∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T"
    by auto
  have f2: "((∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T) ∨ (∀veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 = HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]))"
    by auto
  have f3: "(∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE veriT_vr448 veriT_vr449) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. HSTATE veriT_vr448 veriT_vr449 ≠ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ])) ∨ (∀veriT_vr448 veriT_vr449 veriT_vr450 veriT_vr451. ¬ HSTATE veriT_vr448 ( veriT_vr449 [ 0 s= veriT_vr450] [ 0 :=dd veriT_vr451] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE veriT_vr448 veriT_vr449)"
    by auto
  then have f4: "(∃h t m ma. HSTATE h t ≠ HSTATE h ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ])) ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f6: "((∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 = CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  have f7: "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE veriT_vr60 veriT_vr61 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE veriT_vr60 veriT_vr61 1) ∨ (∀veriT_vr60 veriT_vr61 veriT_vr62 veriT_vr63. ¬ CSTATE veriT_vr60 ( veriT_vr61 [ 0 s= veriT_vr62] [ 0 :=dd veriT_vr63] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE veriT_vr60 veriT_vr61 1)"
    by auto
  then have f8: "(∃m t ma mb. CSTATE m ( t [ 0 s= ma] [ 0 :=dd mb] [ -=i 0] [ 0 -=devd ]) 1 ≠ CSTATE m t 1) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    using f4 by (metis HSTATE_rule_6)
  have f10: "¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    using f8 by (metis CSTATE_otherside_rule_5_0)
  have f11: "CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f12: "HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ∨ HSTATE SD T"
    by auto
  have f13: "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
    by auto
  have f14: "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    by auto
  have f15: "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∨ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    by auto
  have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
    by auto
  then have f16: "CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
    using f10 f11 f9 f12 f13 f14 f15 by (metis i23)
  have f17: "((∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∨ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdOwn T 1"
    by auto
  have f18: "((∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∨ (∀veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 = nextReqIs veriT_vr465 veriT_vr466 veriT_vr469)"
    by auto
  have f19: "(∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ∧ ¬ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    by auto
  have "(∃veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ≠ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469) ∨ (∀veriT_vr465 veriT_vr466 veriT_vr467 veriT_vr468 veriT_vr469. ¬ nextReqIs veriT_vr465 ( veriT_vr466 [ 0 s= veriT_vr467] [ 0 :=dd veriT_vr468] [ -=i 0] [ 0 -=devd ]) veriT_vr469 ∨ nextReqIs veriT_vr465 veriT_vr466 veriT_vr469)"
    by auto
  then have f20: "(∃r t m ma n. nextReqIs r ( t [ 0 s= m] [ 0 :=dd ma] [ -=i 0] [ 0 -=devd ]) n ≠ nextReqIs r t n) ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    using f17 f18 f19 by metis
  have f21: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ SharedM ≠ MAD ∧ SharedM ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have f22: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  have f23: "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. HSTATE veriT_vr136 veriT_vr134 ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137 ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  have f24: "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137 ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have f25: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f21 f22 f23 by metis
  have f26: "¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
    using f20 by (metis nextReqIs_general_rule_7_0)
  have f27: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ SAD ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have f28: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  have "(∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. HSTATE veriT_vr136 veriT_vr134 ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137 ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f29: "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f27 f28 f24 by metis
  have f30: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE IMD T 0 ∧ IMD ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f31: "((∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. (¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159) ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  have f32: "(∃veriT_vr157 veriT_vr158 veriT_vr159. CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159 ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr157 veriT_vr158 veriT_vr159. (CSTATE veriT_vr157 veriT_vr158 0 ∧ veriT_vr157 ≠ veriT_vr159) ∧ CSTATE veriT_vr159 veriT_vr158 0) ∨ (∀veriT_vr157 veriT_vr158 veriT_vr159. ¬ CSTATE veriT_vr157 veriT_vr158 0 ∨ veriT_vr157 = veriT_vr159 ∨ ¬ CSTATE veriT_vr159 veriT_vr158 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f30 f31 f32 by metis
  then have f33: "¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have f34: "¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ (¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) = (¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T)"
    by auto
  have "¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by auto
  then have f35: "¬ HSTATE SD T ∨ SharedM = MAD ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T ⟶ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f34 by metis
  have f36: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ HSTATE SD T ∧ SharedM ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T"
    by auto
  have "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    using f35 f36 f25 by metis
  then have f37: "¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
    by (metis HSTATE_invariant3)
  have f38: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ (¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) = (¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T)"
    by auto
  have "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by auto
  then have f39: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T ⟶ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f38 by metis
  have f40: "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ HSTATE SD T ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T"
    by auto
  have "((∃veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. ((HSTATE veriT_vr133 veriT_vr134 ∨ HSTATE veriT_vr135 veriT_vr134 ∨ HSTATE veriT_vr136 veriT_vr134) ∧ veriT_vr133 ≠ veriT_vr137 ∧ veriT_vr135 ≠ veriT_vr137 ∧ veriT_vr136 ≠ veriT_vr137) ∧ HSTATE veriT_vr137 veriT_vr134) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∨ (∀veriT_vr133 veriT_vr134 veriT_vr135 veriT_vr136 veriT_vr137. (¬ HSTATE veriT_vr133 veriT_vr134 ∧ ¬ HSTATE veriT_vr135 veriT_vr134 ∧ ¬ HSTATE veriT_vr136 veriT_vr134 ∨ veriT_vr133 = veriT_vr137 ∨ veriT_vr135 = veriT_vr137 ∨ veriT_vr136 = veriT_vr137) ∨ ¬ HSTATE veriT_vr137 veriT_vr134)"
    by auto
  then have "(∃h t ha hb hc. ((HSTATE h t ∨ HSTATE ha t ∨ HSTATE hb t) ∧ h ≠ hc ∧ ha ≠ hc ∧ hb ≠ hc) ∧ HSTATE hc t) ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    using f39 f40 f29 by metis
  then have f41: "¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
    by (metis HSTATE_invariant3)
  have "CSTATE IMD T 0 ∧ IMD ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE IMD T 0 ∨ IMD = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f33 by (metis MESI_State.distinct(265))
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0"
    have "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ CSTATE ISAD T 1"
      by auto
    then have "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1 ∨ CSTATE ISAD T 1"
      using aa1 by metis
    moreover
    { assume aaa1: "CSTATE ISAD T 1"
      have "(CSTATE ISAD T 1 ∨ CSTATE Invalid T 1) ∨ ¬ CSTATE ISAD T 1"
        by auto
      then have "CSTATE ISAD T 1 ∨ CSTATE Invalid T 1"
        using aaa1 by metis
      then have "¬ nextReqIs RdOwn T 1"
        by (metis i495)
      then have fff2: "(¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1) ∧ ¬ nextReqIs RdOwn T 1"
        using f26 by metis
      have "nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ ¬ nextReqIs RdOwn T 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ nextReqIs RdOwn T 1"
        by auto
      then have fff3: "¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        using fff2 by metis
      have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1"
        by auto
      then have "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        using fff3 by metis }
    moreover
    { assume "¬ CSTATE ISAD T 0 ∧ ¬ CSTATE ISAD T 1"
      then have fff1: "¬ HSTATE SAD T"
        by (metis i106)
      have "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T ∨ HSTATE ModifiedM T ∨ HSTATE MAD T ∨ HSTATE SAD T"
        by auto
      then have "HSTATE ModifiedM T ∨ HSTATE MAD T ∨ ¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
        using fff1 by metis
      moreover
      { assume "¬ HSTATE ModifiedM T ∧ ¬ HSTATE MAD T ∧ ¬ HSTATE SAD T"
        then have ffff1: "(¬ CSTATE SMA T 0 ∨ ¬ nextGOPending T 0) ∧ (¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∧ (¬ CSTATE SMD T 0 ∨ ¬ nextHTDDataPending T 0)"
          by (metis i366)
        have "(CSTATE SMA T 0 ∧ nextGOPending T 0 ∨ CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ CSTATE SMD T 0 ∧ nextHTDDataPending T 0) ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have ffff2: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
          using ffff1 by metis
        have "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0"
          by auto
        then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
          using ffff2 by metis }
      moreover
      { assume "HSTATE MAD T"
        then have ffff1: "(¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T) ∧ HSTATE MAD T"
          using f37 by metis
        have "HSTATE SD T ∧ SharedM ≠ MAD ∧ SD ≠ MAD ∧ HSTATE MAD T ∨ ¬ HSTATE SD T ∨ SharedM = MAD ∨ SD = MAD ∨ ¬ HSTATE MAD T"
          by auto
        then have "¬ HSTATE SD T"
          using ffff1 by (metis HOST_State.distinct(175,85)) }
      moreover
      { assume "HSTATE ModifiedM T"
        then have ffff1: "(¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          using f41 by metis
        have "HSTATE SD T ∧ ModifiedM ≠ SAD ∧ SD ≠ ModifiedM ∧ HSTATE ModifiedM T ∨ ¬ HSTATE SD T ∨ ModifiedM = SAD ∨ SD = ModifiedM ∨ ¬ HSTATE ModifiedM T"
          by auto
        then have "¬ HSTATE SD T"
          using ffff1 by (metis HOST_State.distinct(7,9)) }
      ultimately have "HSTATE SD T ⟶ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis
      moreover
      { assume "¬ HSTATE SD T"
        then have ffff1: "¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          using f9 f12 by metis
        have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          by auto
        then have "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
          using ffff1 by metis }
      ultimately have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        by metis }
    ultimately have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis
    moreover
    { assume aaa1: "¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
      have "(CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0) ∨ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])"
        by auto
      then have "(¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0"
        using aaa1 by metis
      then have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
        using f16 by metis }
    ultimately have "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
      by metis }
  ultimately have f42: "¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0 ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by metis
  have f43: "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ≠ ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ ((¬ CSTATE IMD T 0 ∨ ¬ nextHTDDataPending T 0) ∨ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ ((¬ CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ ¬ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∨ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) ∨ (CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    by auto
  have "((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)) = ((CSTATE IMD T 0 ∧ nextHTDDataPending T 0) ∧ ((CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∨ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ])) ∧ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0))"
    by auto
  then show "CSTATE IMD T 0 ∧ nextHTDDataPending T 0 ⟶ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1) ∧ (CSTATE IMAD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ nextReqIs RdOwn ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 1 ∧ HSTATE SD ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) ⟶ ¬ CSTATE Modified ( T [ 0 s= Modified] [ 0 :=dd getHTDDataOrMakeup T 0] [ -=i 0] [ 0 -=devd ]) 0)"
    using f42 f43 by metis
next 
SH Future: starting 
Done 
Sledgehammering... 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
307.907s elapsed time, 74.266s cpu time, 2.406s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
292.866s elapsed time, 75.750s cpu time, 2.391s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= SIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
298.994s elapsed time, 75.484s cpu time, 2.391s GC time 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method didnt solve goal 
METHOD Future: result = fail 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(121,31) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_def CSTATE_inequality_invariant CSTATE_various_forms1 CSTATE_various_forms2
    MESI_State.distinct(5,95) SIAGO_WritePull_CSTATE_aux SharedSnpInv'_CSTATE_invariant5 nat_to_id.simps(1)) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
vampire found a proof... 
vampire: Try this:
  apply (metis CSTATE_def CSTATE_various_forms1 CSTATE_various_forms2 MESI_State.distinct(121,3,31)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 nat_to_id.simps(1))
Warning: Isar proof construction failed 
METHOD Future: starting 
zipperposition: Try this:
  apply (metis CSTATE_def CSTATE_inequality_invariant CSTATE_various_forms2 CSTATE_various_forms6
    CXL_SPG_used_general_rule_6_0 MESI_State.distinct(105,15,339) SharedSnpInv'_MAD_CSTATE_invariant2
    SharedSnpInv'_MAD_CSTATE_invariant4 SharedSnpInv'_MAD_CSTATE_invariant5 cache_state_invariant(1)
    devcache2_buffer1_invariant i586 nat_to_id.simps(1))

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀x X6. zz x X6 = x"
    by moura
  have f2: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have f3: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f4: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have f5: "∀m t. CLEntry.block_state (devcache2 t) = m ∨ ¬ CSTATE m t 1"
    using CSTATE_various_forms6 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t n na s ta. CSTATE m t n ∨ ¬ CSTATE m ( t [na +=snpresp s ta]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant2 by moura
  have f8: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f9: "∀t n. CLEntry.block_state (devcache2 t) = CLEntry.block_state (devcache2 ( t [n -=snp ]))"
    using cache_state_invariant(1) by moura
  have f10: "∀n t m. (if n = 0 then CLEntry.block_state (devcache1 t) = m else if n = 1 then CLEntry.block_state (devcache2 t) = m else False) ∨ ¬ CSTATE m t n"
    using CSTATE_def by moura
  have f11: "CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    using i586 by moura
  have "∀t m. devcache2 ((t::Type1State)⦇buffer1 := Some m⦈) = devcache2 t"
    using devcache2_buffer1_invariant by moura
  then have f12: "∀t m. devcache2 (buffer1_update (zz (Some m)) (t::Type1State)) = devcache2 t"
    using f1 by metis
  have f13: "Modified ≠ IMAD"
    using MESI_State.distinct(15) by moura
  have f14: "Shared ≠ IMAD"
    using MESI_State.distinct(105) by moura
  have f15: "IMAD ≠ MIA"
    using MESI_State.distinct(339) by moura
  have f16: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f17: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f18: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "(∃m. m ≠ IMAD ∧ CSTATE m T 1) ∨ (∃m. m ≠ MIA ∧ CSTATE m T 0) ∨ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
    using f18 f17 f15 f14 f13 f12 f10 f9 f8 f7 f5 f4 f3 f2 by metis
  moreover
  { assume aa1: "CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
    { have "CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
        using aa1 f16 by metis
      then have "CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
        using f1 by metis }
    then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume "∃m. m ≠ MIA ∧ CSTATE m T 0"
    then have "¬ CSTATE MIA T 0"
      using f6 by metis }
  moreover
  { assume "∃m. m ≠ IMAD ∧ CSTATE m T 1"
    then have "¬ CSTATE IMAD T 1"
      using f6 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      using f11 by metis
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
        by moura }
    ultimately have "CSTATE MIA T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by metis }
  ultimately have "CSTATE MIA T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  moreover
  { assume "¬ CSTATE MIA T 0"
    then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared)"
    by metis
next 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_disj4' CSTATE_various_forms2 MESI_State.distinct(121,27,31)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(203,31) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_different1 CSTATE_inequality_invariant MESI_State.distinct(203,31)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 CSTATE_disj2 MESI_State.distinct(139,31,5) SIAGO_WritePullDrop_CSTATE_aux
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SMAGO_nextHTDDataPending_otherside
    hstate_invariants(9) i779 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f4: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f5: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  then have "HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE SD T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∧ (HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(177,197) HSTATE_invariant3 hstate_invariants(12,2,24,7) i502
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f5: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f6: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have f8: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have f9: "SD ≠ IB"
    using HOST_State.distinct(197) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f6 by metis
  then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using f9 f8 f7 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
398.544s elapsed time, 105.047s cpu time, 3.203s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant HSTATE_invariant_ModifiedSnpInv MESI_State.distinct(261)
    hstate_invariants(9) i106 i147 i576 i586 i600 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    using i586 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE ISAD T 0"
    using i147 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ CSTATE MIA T 0"
    using i576 by moura
  have f10: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE MIA T 0"
    using i576 by moura
  have f11: "¬ CSTATE SMA T 1 ∨ ¬ CSTATE MIA T 0"
    using i576 by moura
  have "ISAD ≠ IMAD"
    using MESI_State.distinct(261) by moura
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ HSTATE MA T ∧ CSTATE ISAD T 0 ∨ HSTATE MA T ∨ (∃m. m ≠ IMAD ∧ CSTATE m T 1)"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume "¬ HSTATE MA T ∧ CSTATE ISAD T 0"
    then have "¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "HSTATE MA T"
    then have "nextSnoopIs SnpInv T 0 ⟶ CSTATE IMA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE SMA T 1"
      using f8 by metis
    moreover
    { assume "CSTATE IMA T 1"
      then have "¬ CSTATE MIA T 0"
        using f9 by metis }
    moreover
    { assume "nextHTDDataPending T 1"
      then have "¬ CSTATE MIA T 0"
        using f10 by metis }
    moreover
    { assume "CSTATE SMA T 1"
      then have "¬ CSTATE MIA T 0"
        using f11 by metis }
    ultimately have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by metis }
  moreover
  { assume "∃m. m ≠ IMAD ∧ CSTATE m T 1"
    then have "¬ CSTATE IMAD T 1"
      using f3 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      using f2 by metis }
  ultimately have "CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  moreover
  { assume "¬ CSTATE MIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SMAGO_nextHTDDataPending_otherside
    hstate_invariants(9) i859 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE SAD T"
    using i859 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f4: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f5: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  then have "HSTATE SAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE SAD T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SAD T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∧ (HSTATE SAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1)"
    by metis
next 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_def CSTATE_disj4' CSTATE_various_forms1 CSTATE_various_forms2 MESI_State.distinct(95)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 i592) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(149) HSTATE_invariant3 hstate_invariants(12,2,24,7) i502
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f5: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f6: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have f8: "SAD ≠ MA"
    using HOST_State.distinct(149) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f6 by metis
  then have "HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ (∃h. MA ≠ h ∧ HSTATE h T)"
    using f8 f5 f4 f3 by metis
  moreover
  { assume "∃h. MA ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE MA T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      using f7 by metis
    moreover
    { assume "¬ CSTATE SIA T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(277,31) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_4 CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(143,5)
    SMAGO_nextGOPendingIs_otherside SharedSnpInv'_MAD_CSTATE_invariant5 consumeGOSendDataPerform_def
    consumeGOSendData_def consumeGO_def nextGOPendingIs_XYAGO_other1)

Isar proof:
proof -
  { obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
      ff1: "∀B_X X4. zz B_X X4 = B_X"
      by moura
    obtain zza :: "Message ⇒ Message option ⇒ Message option" where
      ff2: "∀B_X x. zza B_X x = Some B_X"
      by moura
    have ff3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
      using CSTATE_inequality_invariant by moura
    have ff4: "∀m t n na. CSTATE m (t [ -=i n]) na ∨ ¬ CSTATE m t na"
      using CSTATE_remove_op by moura
    have ff5: "∀m t d ma n. CSTATE m (t [ d +=d2hd ma]) n ∨ ¬ CSTATE m t n"
      using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
    have "∀m z t. CSTATE m ( t⦇buffer1 := z⦈ [ 0 s= m] [ 0 -=reqresp ]) 0"
      using CSTATE_assign_rule_4 by moura
    then have ff6: "∀m z t. CSTATE m ( buffer1_update (zz z) t [ 0 s= m] [ 0 -=reqresp ]) 0"
      using ff1 by metis
    have ff7: "Modified ≠ Invalid"
      using MESI_State.distinct(5) by moura
    have ff8: "Invalid ≠ ISAD"
      using MESI_State.distinct(143) by moura
    have "∀n t m. consumeGOSendDataPerform n m t = (if n = 0 then t⦇buffer1 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n] else t⦇buffer2 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n])"
      using consumeGOSendDataPerform_def by moura
    then have ff9: "∀n t m. consumeGOSendDataPerform n m t = (if n = 0 then buffer1_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n] else buffer2_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n])"
      using ff1 by metis
    have "∀n t m. consumeGOSendData n m t = (if n = 0 then t⦇buffer1 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 0] else t⦇buffer2 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 1])"
      using consumeGOSendData_def by moura
    then have ff10: "∀n t m. consumeGOSendData n m t = (if n = 0 then buffer1_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 0] else buffer2_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 1])"
      using ff1 by metis
    have "∀n t m. consumeGO n m t = (if n = 0 then t⦇buffer1 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ] else t⦇buffer2 := Some (nextGO t n)⦈ [ n s= m] [ n -=reqresp ])"
      using consumeGO_def by moura
    then have ff11: "∀n t m. consumeGO n m t = (if n = 0 then buffer1_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ] else buffer2_update (zz (Some (nextGO t n))) t [ n s= m] [ n -=reqresp ])"
      using ff1 by metis
    have ff12: "∀t ta. (if True then t::Type1State else ta) = t"
      using if_True by moura
    have ff13: "∀X0. zz (Some X0) = zza X0"
      by moura
    then have ff14: "∀n t m. consumeGO n m t = (if n = 0 then buffer1_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ] else buffer2_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ])"
      using ff11 by metis
    have ff15: "∀n t m. consumeGOSendDataPerform n m t = (if n = 0 then buffer1_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n] else buffer2_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i n])"
      using ff9 ff13 by metis
    have ff16: "∀n t m. consumeGOSendData n m t = (if n = 0 then buffer1_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 0] else buffer2_update (zza (nextGO t n)) t [ n s= m] [ n -=reqresp ] [ nat_to_id n +=d2hd D2HData (nextGOID t n) (read_dev_value n t) (clock t)] [ -=i 1])"
      using ff10 ff13 by metis
    have "∀z m. zz (zza m z) = zza m"
      using ff13 ff2 by metis
    then have "¬ CSTATE Modified ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ ¬ CSTATE ISAD ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0"
      using ff16 ff15 ff14 ff12 ff8 ff7 ff6 ff5 ff4 ff3 by metis
    then have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ ¬ CSTATE ISAD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0"
      using ff13 by metis
    then have "¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0"
      using ff1 by metis }
  then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by moura
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (CSTATE ISAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∧ nextGOPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj3 CSTATE_inequality_invariant CSTATE_remove_op Invalid_not_eq_MIA
    MESI_State.distinct(143,167,5) SIAGO_WritePullDrop_CSTATE_aux SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj4' CSTATE_inequality_invariant MESI_State.distinct(139,5)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(277,31) SharedSnpInv'_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i23
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i353 i502 i506 i600 i653 i657 i659 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f3: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f4: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i506 by moura
  have f5: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f6: "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f9: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f10: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i353 by moura
  have "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i353 by moura
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    using f10 f9 f8 f6 f5 f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis
    moreover
    { assume "¬ HSTATE MA T"
      then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
        using f2 by metis }
    ultimately have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      using f4 by metis }
  ultimately have "CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis ISADGO'_HSTATE_neg SMAGO_nextGOPendingIs_otherside hstate_invariants(9) i796 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have f3: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE SharedM T"
    using i796 by moura
  have f4: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f5: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f6: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f1 f4 by metis
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀z m. zz (zza m z) = zza m"
    using f5 f2 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f8 f7 f6 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 f5 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i660 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SharedM T"
    using i660 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant HSTATE_invariant_ModifiedSnpInv MESI_State.distinct(11,261)
    SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i106 i477 i5 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f3: "∀X1 B_X. bb X1 B_X = (¬ CSTATE Modified X1 B_X)"
    by moura
  have f4: "CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    using i477 by moura
  have f5: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f6: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f7: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f8: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f9: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f10: "ISAD ≠ IMAD"
    using MESI_State.distinct(261) by moura
  have f11: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f12: "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  have "∀n t m. m = Modified ∨ ¬ CSTATE m t n ∨ bb t n"
    using f5 f3 by metis
  then have "HSTATE SAD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ bb T 0 ∨ (∃m. m ≠ IMAD ∧ CSTATE m T 1)"
    using f12 f10 f9 f8 f7 f6 by metis
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SAD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f11 by metis
      then have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume "bb T 0"
    then have "¬ CSTATE Modified T 0"
      using f3 by metis }
  moreover
  { assume "∃m. m ≠ IMAD ∧ CSTATE m T 1"
    then have "¬ CSTATE IMAD T 1"
      using f5 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      using f4 by metis
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv i353 i502 i506 i600 i653 i657 i659 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f3: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f4: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i506 by moura
  have f5: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f6: "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f9: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f10: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMA T 1"
    using i353 by moura
  have "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMA T 1"
    using i353 by moura
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    using f10 f9 f8 f6 f5 f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis
    moreover
    { assume "¬ HSTATE MA T"
      then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
        using f2 by metis }
    ultimately have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      using f4 by metis }
  ultimately have "CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis ISADGO'_HSTATE_neg SMAGO_nextGOPendingIs_otherside hstate_invariants(9) i796 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have f3: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE SharedM T"
    using i796 by moura
  have f4: "∀h z t n m na. ¬ HSTATE h ( t⦇buffer1 := z⦈ [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using ISADGO'_HSTATE_neg by moura
  have f5: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have f6: "∀h z t n m na. ¬ HSTATE h ( buffer1_update (zz z) t [ n s= m] [ na -=reqresp ]) ∨ HSTATE h t"
    using f1 f4 by metis
  have f7: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f8: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀z m. zz (zza m z) = zza m"
    using f5 f2 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE SharedM T"
    using f8 f7 f6 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 f5 by metis
      then have "¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (HSTATE SharedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj4' CSTATE_inequality_invariant MESI_State.distinct(143,5)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_16 CSTATE_disj1 CSTATE_otherside_rule_9_0 MESI_State.distinct(31) i595
    nat_to_id.simps(1) nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ CSTATE Modified T 1"
    using i595 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "Modified ≠ IIA"
    using MESI_State.distinct(31) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀m z t s ta ma. CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) 0"
    using CSTATE_assign_rule_16 by moura
  have f7: "∀m t z s ta ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma] [ Dev1 +=d2hd mb]) 1"
    using CSTATE_otherside_rule_9_0 by moura
  have f8: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f9: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f10: "∀m z t s ta ma. CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) 0"
    using f1 f6 by metis
  have f11: "∀m t z s ta ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma] [ Dev1 +=d2hd mb]) 1"
    using f1 f7 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f8 by metis
  then have "CSTATE MIA T 0 ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    using f11 f10 f9 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE MIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SMAGO_nextGOPendingIs_otherside
    hstate_invariants(9) i313 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE ModifiedM T"
    using i313 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz (Some m)) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f1 by metis
  have f4: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f6: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have f7: "∀X0. zz (Some X0) = x_l_lift3 X0"
    by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (x_l_lift3 m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f3 by metis
  then have "HSTATE ModifiedM ( buffer1_update (x_l_lift3 (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (x_l_lift3 (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 f7 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i22
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(17) HSTATE_invariant3 hstate_invariants(12,2,24,7) i502
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f5: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f6: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have f8: "ModifiedM ≠ MA"
    using HOST_State.distinct(17) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f6 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ (∃h. MA ≠ h ∧ HSTATE h T)"
    using f8 f5 f4 f3 by metis
  moreover
  { assume "∃h. MA ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE MA T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
      using f7 by metis
    moreover
    { assume "¬ CSTATE SIA T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i22
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SIAGO_WritePullDrop_nextHTDDataPending_otherside
    hstate_invariants(9) i313 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 B_X. zza X1 B_X = Some X1"
    by moura
  have f3: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE ModifiedM T"
    using i313 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f4: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f5: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f3 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ nextDTHDataPending ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(15) HSTATE_invariant3 HSTATE_rule_16 i584 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE MAD T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    using i584 by moura
  have f4: "ModifiedM ≠ MAD"
    using HOST_State.distinct(15) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_rule_16 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t. ModifiedM ≠ h ∨ ¬ HSTATE h t ∨ ¬ HSTATE MAD t"
    using f4 f2 by metis
  have f10: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    using f10 f9 f8 f5 f3 by metis
  moreover
  { assume "¬ CSTATE MIA T 0"
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis H_msg_P_oppo_def SMADSnpInv_nextReqIs hstate_invariants(12,2,24,7) i13
    nextDTHDataPending_general_rule_6_0 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain bb :: "Type1State ⇒ nat ⇒ bool" where
    f2: "∀X1 B_X. bb X1 B_X = (¬ nextDTHDataPending X1 B_X)"
    by moura
  have "H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λt n. ¬ nextDTHDataPending t n) T"
    using i13 by moura
  then have f3: "H_msg_P_oppo ModifiedM (nextReqIs RdShared) bb T"
    using f2 by metis
  have "∀t n z s ta m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m]) n"
    using nextDTHDataPending_general_rule_6_0 by moura
  then have f4: "∀t n z s ta m. nextDTHDataPending t n ∨ ¬ nextDTHDataPending ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m]) n"
    using f1 by metis
  have f5: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f7: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  then have f8: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 by metis
  have "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( t ⦇buffer1 := z⦈ [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using SMADSnpInv_nextReqIs by moura
  then have "∀r t n z na s ta m. nextReqIs r t n ∨ ¬ nextReqIs r ( buffer1_update (zz z) t [na +=snpresp s ta] [na -=snp ] [ na s= m]) n"
    using f1 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0"
    using f8 f7 f6 f5 f4 f3 f2 by metis
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1"
    { have "¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0"
    { have "¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextDTHDataPending ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1"
    { have "¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextReqIs RdShared ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0"
    { have "¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 SMADSnpInv_nextSnoopIs_otherside
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 i592 i72 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have f4: "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Invalid T 0"
    using i592 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f5: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f8: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "CSTATE Modified T 0 ⟶ CSTATE Modified T 1 ∨ CSTATE Invalid T 0 ∨ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    using f8 f7 f6 f5 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE Modified T 0"
      using f3 by metis }
  moreover
  { assume aa1: "CSTATE Invalid T 0"
    { have "¬ nextSnoopIs SnpInv T 0"
        using aa1 f4 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SIAGO_WritePullDrop_nextSnpRespIs_otherside
    hstate_invariants(9) i313 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X x. zza B_X x = Some B_X"
    by moura
  have f3: "¬ nextGOPendingIs GO_WritePull T 0 ∨ ¬ HSTATE ModifiedM T"
    using i313 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f4: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f2 by metis
  have f5: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f6: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE ModifiedM T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ nextGOPendingIs GO_WritePull T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (HSTATE ModifiedM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∧ nextReqIs RdShared ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_SIAGO_WritePullDrop_invariant ISADGO'_HSTATE_neg SMAGO_nextGOPendingIs_otherside
    hstate_invariants(9) i779 remove_instr_HSTATE)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X6. zz X1 X6 = X1"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( t⦇buffer1 := Some m⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using HSTATE_SIAGO_WritePullDrop_invariant by moura
  then have f3: "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz (Some m)) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f1 by metis
  have f4: "∀h t n. HSTATE h (t [ -=i n]) ∨ ¬ HSTATE h t"
    using remove_instr_HSTATE by moura
  have f5: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ -=i n])"
    using remove_instr_HSTATE by moura
  have f6: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have f7: "∀X0. zz (Some X0) = x_l_lift1 X0"
    by moura
  then have "∀h t m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (x_l_lift1 m) t [ 0 s= Invalid] [ 0 -=reqresp ] [ -=i 0])"
    using f3 by metis
  then have "HSTATE SD ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ HSTATE SD T"
    using f6 f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (x_l_lift1 (nextGO T 0)) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextGO T 0))) T [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using aa1 f7 by metis
      then have "¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∨ ¬ CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∨ ¬ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ∨ ¬ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextGOPendingIs GO_WritePull T 0"
    by metis
  then show "CSTATE MIA T 0 ∧ nextGOPendingIs GO_WritePull T 0 ⟶ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1) ∧ (CSTATE IMAD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∧ nextReqIs RdOwn ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 1 ∧ HSTATE SD ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) ⟶ ¬ CSTATE Modified ( T⦇buffer1 := Some (nextGO T 0)⦈ [ 0 s= Invalid] [ 0 -=reqresp ] [ nat_to_id 0 +=d2hd D2HData (nextGOID T 0) (read_dev_value 0 T) (clock T)] [ -=i 0]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
1162.069s elapsed time, 117.578s cpu time, 11.531s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i779 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE MIA T 0 ∨ ¬ HSTATE SD T"
    using i779 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE MIA T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE MIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE MIA T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= IIA] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
1186.700s elapsed time, 123.141s cpu time, 11.562s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
e found a proof... 
e: Try this:
  apply (metis HOST_State.distinct(15,37) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i475
    nat_to_id.simps(1))

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option" where
    f1: "∀X1958. zz X1958 = Some (nextSnoop T 0)"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    "∀X1986 X8. zza X8 X1986 = X8"
    by moura
  then have f2: "∀t n ta z s h m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    by (metis HSTATE_invariant_ModifiedSnpInv)
  have "∃h ha. ModifiedM ≠ h ∧ ModifiedM ≠ ha"
    by (metis HOST_State.distinct(37))
  then have "HSTATE MAD T ⟶ (∃h ha hb. hb ≠ ModifiedM ∧ ModifiedM ≠ ha ∧ ModifiedM ≠ h ∧ HSTATE hb T)"
    by (metis HOST_State.distinct(15))
  moreover
  { assume "∃h ha hb. hb ≠ ModifiedM ∧ ModifiedM ≠ ha ∧ ModifiedM ≠ h ∧ HSTATE hb T"
    then have "∃z. ¬ HSTATE ModifiedM T ∧ zza z = zz"
      by (metis HSTATE_invariant3)
    then have "¬ HSTATE ModifiedM ( buffer1_update zz T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid])"
      using f2 by metis
    then have "¬ HSTATE ModifiedM ( buffer1_update zz T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
      by (metis hstate_invariants(9))
    then have "¬ HSTATE ModifiedM ( buffer1_update zz T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
      by (metis nat_to_id.simps(1))
    then have "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
      using f1 by metis }
  moreover
  { assume "¬ HSTATE MAD T"
    then have "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
      by (metis i475) }
  ultimately show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(141,177) HSTATE_invariant3 hstate_invariants(12,2,24,7) i502
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n. HSTATE h t ∨ ¬ HSTATE h ( t [n -=snp ])"
    using hstate_invariants(12) by moura
  have f5: "∀h t n s ta. HSTATE h t ∨ ¬ HSTATE h ( t [n +=snpresp s ta])"
    using hstate_invariants(7) by moura
  have f6: "∀h t z. HSTATE h t ∨ ¬ HSTATE h (t⦇buffer1 := z⦈)"
    using hstate_invariants(2) by moura
  have f7: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using i502 by moura
  have f8: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have f9: "SAD ≠ SD"
    using HOST_State.distinct(141) by moura
  have "∀h t z. HSTATE h t ∨ ¬ HSTATE h (buffer1_update (zz z) t)"
    using f1 f6 by metis
  then have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE SIA T 0"
    using f9 f8 f7 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE SIA T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ nextReqIs DirtyEvict T 0 ∨ ¬ CSTATE SIA T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE SIA T 0 ∧ nextSnoopIs SnpInv T 0 ∧ ¬ nextReqIs DirtyEvict T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= IIA]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
1186.727s elapsed time, 126.281s cpu time, 11.984s GC time 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_various_forms5 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def
    HostInvalidRdShared'_devcache_invariant2 IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def
    IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def
    MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def
    MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def
    OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i493
    numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i23
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_def CSTATE_various_forms1 CSTATE_various_forms6 CXL_SPG_used_general_rule_6_0
    MESI_State.distinct(101,11) SharedSnpInv'_MAD_CSTATE_invariant2 SharedSnpInv'_MAD_CSTATE_invariant4
    SharedSnpInv'_MAD_CSTATE_invariant5 cache_state_invariant(1) devcache2_buffer1_invariant i485 i72
    nat_to_id.simps(1))

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀x2 X6. zz x2 X6 = x2"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have f3: "∀m t. CLEntry.block_state (devcache1 t) = m ∨ ¬ CSTATE m t 0"
    using CSTATE_various_forms1 by moura
  have "∀t m. devcache2 ((t::Type1State)⦇buffer1 := Some m⦈) = devcache2 t"
    using devcache2_buffer1_invariant by moura
  then have f4: "∀t m. devcache2 (buffer1_update (zz (Some m)) (t::Type1State)) = devcache2 t"
    using f1 by metis
  have f5: "∀t n. CLEntry.block_state (devcache2 t) = CLEntry.block_state (devcache2 ( t [n -=snp ]))"
    using cache_state_invariant(1) by moura
  have f6: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f7: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have f8: "∀m t. CLEntry.block_state (devcache2 t) = m ∨ ¬ CSTATE m t 1"
    using CSTATE_various_forms6 by moura
  have f9: "∀n t m. (if n = 0 then CLEntry.block_state (devcache1 t) = m else if n = 1 then CLEntry.block_state (devcache2 t) = m else False) ∨ ¬ CSTATE m t n"
    using CSTATE_def by moura
  have f10: "∀m t n na s ta. CSTATE m t n ∨ ¬ CSTATE m ( t [na +=snpresp s ta]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant2 by moura
  have f11: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f12: "CSTATE ISAD T 1 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i485 by moura
  have f13: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f14: "Shared ≠ ISAD"
    using MESI_State.distinct(101) by moura
  have f15: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f16: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f17: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ∧ CSTATE ISAD T 1 ⟶ CSTATE Modified T 1 ∨ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
    using f17 f16 f14 f13 f11 f10 f9 f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE Modified T 0"
      using f2 by metis }
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f12 by metis
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "CSTATE Modified T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
    { have "CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
        using aa1 f15 by metis
      then have "CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified ∧ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared"
        using f1 by metis }
    then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "CSTATE Modified T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared)"
    by metis
next 
METHOD Future: starting 
Done 
Done 
SH Future: sledgehammer returned: success 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== EXIT my_hammer_or_method_away with result: success === 
1128.962s elapsed time, 109.094s cpu time, 11.312s GC time 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_various_forms1 CSTATE_various_forms2 CXL_SPG_used_general_rule_6_0 MESI_State.distinct(5,95)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 nat_to_id.simps(1))

Isar proof:
proof -
  { obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
      ff1: "∀x X6. zz x X6 = x"
      by moura
    have ff2: "∀m t. CLEntry.block_state (devcache1 t) = m ∨ ¬ CSTATE m t 0"
      using CSTATE_various_forms1 by moura
    have ff3: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
      using CSTATE_various_forms2 by moura
    have ff4: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff5: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
      using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
    have ff6: "Modified ≠ Invalid"
      using MESI_State.distinct(5) by moura
    have ff7: "Shared ≠ Invalid"
      using MESI_State.distinct(95) by moura
    have ff8: "nat_to_id 0 = Dev1"
      using nat_to_id.simps(1) by moura
    have "CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∧ CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified"
      using ff7 ff6 ff5 ff4 ff3 ff2 by metis
    then have "CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∧ CLEntry.block_state (devcache1 ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified"
      using ff8 by metis
    then have "CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∧ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified"
      using ff1 by metis }
  then have "(CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Modified) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by moura
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) = Modified ⟶ CLEntry.block_state (devcache1 ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])) ≠ Shared)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 i603 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj4' CSTATE_various_forms1 CSTATE_various_forms2 MESI_State.distinct(5,95)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_various_forms5 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def
    HostInvalidRdOwn'_devcache_invariant2 IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def
    IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def
    MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def
    MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def
    RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def
    SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i493 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i23 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f3: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(139,5) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 i603 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i23
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "∀z m. zz (zza m z) = zza m"
    using f2 by metis
  then have "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f5 f4 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 i665 i676 nextGOPending_HostInvalidRdShared
    numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
e found a proof... 
e: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_27 MESI_State.distinct(3)
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 i72 nat_to_id.simps(1))

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀X1946 B_X. zz B_X X1946 = B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option" where
    f2: "∀X1928. zza X1928 = Some (nextSnoop T 0)"
    by moura
  have f3: "∀z t s ta m ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma] [ Dev1 +=d2hd mb]) 1"
    using f1 by (metis CSTATE_otherside_rule_27)
  have "∀t m ma. m = ma ∨ ¬ CSTATE m ( t [ 0 s= ma]) 0"
    by (metis CSTATE_inequality_invariant SharedSnpInv'_CSTATE_invariant5)
  then have "¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared]) 0"
    by (metis MESI_State.distinct(3))
  then have "∃z. ¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ zz z = zza"
    by (metis SharedSnpInv'_MAD_CSTATE_invariant5)
  then have "CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ ¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1"
    using f3 by metis
  moreover
  { assume "¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ ¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ Dev1 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1"
    then have "¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update zza T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
      by (metis nat_to_id.simps(1))
    then have "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
      using f2 by metis }
  moreover
  { assume "CSTATE Modified T 1"
    then have "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
      by (metis i72) }
  ultimately show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_assign_rule_16 CSTATE_disj1 CSTATE_otherside_rule_9_0 MESI_State.distinct(3) i73
    nat_to_id.simps(1) nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f3: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f4: "Modified ≠ Shared"
    using MESI_State.distinct(3) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀m z t s ta ma. CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) 0"
    using CSTATE_assign_rule_16 by moura
  have f7: "∀m t z s ta ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma] [ Dev1 +=d2hd mb]) 1"
    using CSTATE_otherside_rule_9_0 by moura
  have f8: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f9: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f10: "∀m z t s ta ma. CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma]) 0"
    using f1 f6 by metis
  have f11: "∀m t z s ta ma mb. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma] [ Dev1 +=d2hd mb]) 1"
    using f1 f7 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f8 by metis
  then have "CSTATE Modified T 0 ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    using f11 f10 f9 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 MESI_State.distinct(5)
    SMADSnpInv_nextSnoopIs_otherside SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 i72
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f4: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f5: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f6: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f8: "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ CSTATE Modified T 1"
    using f8 f7 f6 f5 f4 f2 by metis
  moreover
  { assume aa1: "CSTATE Modified T 1"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(101,3) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant5) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i22 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) HOST_State.distinct(3) HSTATE_invariant3 HostInvalidRdShared_HSTATE
    minus_req_nextReqIs_False_swmrp_rule_2_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
user method successfully solved goal 
METHOD Future: result = success 
METHOD won -> cancel SH 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i22
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f5 f4 f2 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: result = timeout 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i22 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i22
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SharedM T"
    using f5 f4 f2 by metis
  moreover
  { assume aa1: "HSTATE SharedM T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: result = timeout 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 HSTATE_invariant_ModifiedSnpInv
    SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5 hstate_invariants(9) i107 i72
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f4: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f5: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f6: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f7: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have f8: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "CSTATE Modified T 0 ∧ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ CSTATE Modified T 1"
    using f8 f7 f6 f5 f4 f3 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE Modified T 0"
      using f2 by metis }
  ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_otherside_rule_19 C_not_C_msg_def HSTATE_invariant_ModifiedSnpInv
    SMADSnpInv_nextSnoopIs_otherside SharedSnpInv'_CSTATE_invariant5 SharedSnpInv'_MAD_CSTATE_invariant5
    hstate_invariants(9) i417 i466 i485 i49 i592 i594 i72 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 0"
    using i72 by moura
  have "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using CSTATE_otherside_rule_19 by moura
  then have f4: "∀m t z s ta ma. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= ma]) 1"
    using f1 by metis
  have f5: "CSTATE ISAD T 1 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i485 by moura
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t n d ma. CSTATE m t n ∨ ¬ CSTATE m (t [ d +=d2hd ma]) n"
    using SharedSnpInv'_MAD_CSTATE_invariant5 by moura
  have f8: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have f9: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f10: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f11: "¬ CSTATE MIA T 1 ∨ ¬ CSTATE Modified T 0"
    using i594 by moura
  have f12: "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Invalid T 0"
    using i592 by moura
  have f13: "C_not_C_msg Modified ISAD nextGOPending T"
    using i49 by moura
  have f14: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "CSTATE Modified T 0 ∧ CSTATE ISAD T 1 ∧ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ CSTATE Modified T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∧ zip_tseitin_47 ∨ ¬ zip_tseitin_39 ∧ ¬ zip_tseitin_40 ∧ ¬ zip_tseitin_41 ∧ HSTATE ModifiedM T ∧ zip_tseitin_38 ∨ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    using f13 f12 f10 f9 f8 f7 f6 f4 f2 by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f5 by metis
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0 ∧ zip_tseitin_47"
    then have zip_tseitin_49
      by metis
    then have "¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume "¬ zip_tseitin_39 ∧ ¬ zip_tseitin_40 ∧ ¬ zip_tseitin_41 ∧ HSTATE ModifiedM T ∧ zip_tseitin_38"
    then have "CSTATE MIA T 1 ∨ CSTATE Modified T 1"
      by metis
    moreover
    { assume "CSTATE MIA T 1"
      then have "¬ CSTATE Modified T 0"
        using f11 by metis }
    ultimately have "CSTATE Modified T 0 ⟶ CSTATE Modified T 1"
      by metis }
  moreover
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using aa1 f14 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f14 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "CSTATE Modified T 0 ⟶ ((¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0) ∨ CSTATE Modified T 1"
    by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ CSTATE Modified T 0"
      using f3 by metis }
  ultimately have "CSTATE Modified T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i493 i676 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
132.805s elapsed time, 73.281s cpu time, 2.344s GC time 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_invariant3 HSTATE_rule_16 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_rule_16 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. HSTATE h T ∧ h ≠ SAD)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. HSTATE h T ∧ h ≠ SAD"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. SAD ≠ h ∧ HSTATE h T)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. SAD ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdOwn_otherside_invariant2 CSTATE_HostInvalidRdOwn_otherside_invariant3 i676
    i823 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
163.262s elapsed time, 68.703s cpu time, 5.531s GC time 
METHOD Future: result = timeout 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 CSTATE_various_forms2 CSTATE_various_forms4
    DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def
    GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def
    RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def
    SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HostInvalidRdShared'_devcache_invariant1
    HostInvalidRdShared'_devcache_invariant2 IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def
    IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def
    MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def
    MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def
    OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def SWMR_def
    i0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. HSTATE h T ∧ h ≠ SAD)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. HSTATE h T ∧ h ≠ SAD"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. SAD ≠ h ∧ HSTATE h T)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. SAD ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. HSTATE h T ∧ h ≠ SAD)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. HSTATE h T ∧ h ≠ SAD"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(7) HSTATE_general_rule_9_0 HSTATE_invariant3 i483 nat_to_id.simps(1)
    nextSnoopIs_otherside_rule_1_0 sendSnpRespAndData_def)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f3: "HSTATE SAD T ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    using i483 by moura
  have f4: "ModifiedM ≠ SAD"
    using HOST_State.distinct(7) by moura
  have f5: "nat_to_id 0 = Dev1"
    using nat_to_id.simps(1) by moura
  have f6: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using HSTATE_general_rule_9_0 by moura
  have f7: "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then t ⦇buffer1 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else t ⦇buffer2 := Some (nextSnoop t n)⦈ [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using sendSnpRespAndData_def by moura
  have f8: "∀t ta. (if True then t::Type1State else ta) = t"
    using if_True by moura
  have f9: "∀h t z s ta m ma. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= m] [ Dev1 +=d2hd ma])"
    using f1 f6 by metis
  have "∀n t s m. sendSnpRespAndData s m n t = (if n = 0 then buffer1_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)] else buffer2_update (zz (Some (nextSnoop t n))) t [n +=snpresp s nextSnoopID t n] [n -=snp ] [ n s= m] [ nat_to_id n +=d2hd D2HData (nextSnoopID t n) (read_dev_value n t) (clock t)])"
    using f1 f7 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ (∃h. SAD ≠ h ∧ HSTATE h T)"
    using f9 f8 f5 f4 by metis
  moreover
  { assume "∃h. SAD ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE SAD T"
      using f2 by metis
    then have "¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      using f3 by metis
    moreover
    { assume "¬ CSTATE Modified T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpData T 0"
      then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
        by moura }
    ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv hstate_invariants(9) i23 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  have f2: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f3: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  then have "HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f3 by metis
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspSFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Shared] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
277.109s elapsed time, 128.922s cpu time, 10.641s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HSTATE_invariant_ModifiedSnpInv SMADSnpInv_nextSnoopIs_otherside hstate_invariants(9) i23
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X5. zza X1 X5 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f4: "∀h t d m. HSTATE h t ∨ ¬ HSTATE h (t [ d +=d2hd m])"
    using hstate_invariants(9) by moura
  have "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  then have f5: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zz z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f1 by metis
  have f6: "∀X0. zz (Some X0) = zza X0"
    by moura
  then have "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ HSTATE SD T"
    using f5 f4 f2 by metis
  moreover
  { assume aa1: "HSTATE SD T"
    { have "¬ CSTATE Modified T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using aa1 f6 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpData T 0 ∨ ¬ CSTATE Modified T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Modified T 0 ∧ nextSnoopIs SnpData T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIFwdM nextSnoopID T 0] [0 -=snp ] [ 0 s= Invalid] [ nat_to_id 0 +=d2hd D2HData (nextSnoopID T 0) (read_dev_value 0 T) (clock T)]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HOST_State.distinct(3) HSTATE_invariant4
    HostShared_CleanEvict_NotLastDrop_HSTATE IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def
    IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def
    MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def
    MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def
    OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 CSTATE_various_forms2 CSTATE_various_forms4
    DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def
    GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def
    RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def
    SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
266.973s elapsed time, 127.938s cpu time, 10.312s GC time 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HOST_State.distinct(3) HSTATE_invariant3
    HostShared_CleanEvict_NotLastDrop_HSTATE IIA_ROW_def IMAD_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def
    IMD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPINV_COL_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(3) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ SharedM"
      using HOST_State.distinct(3) by moura
    then have "¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextDTHDataPending ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs RdShared T 0"
    by moura
  then show "HSTATE SharedM T ∧ nextReqIs RdShared T 0 ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HOST_State.distinct(3) HSTATE_invariant3
    HostShared_CleanEvict_NotLastDrop_HSTATE IIA_ROW_def IMAD_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def
    IMD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPINV_COL_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastDrop_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
108.533s elapsed time, 53.953s cpu time, 4.453s GC time 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostSide_rule_3_1 CSTATE_disj1 CSTATE_various_forms4 DATA_COL_def
    DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def
    HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MESI_State.distinct(163,175,179,5,95) MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def
    OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i556
    lastSharer_def numeral_One) 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_general_rule_3_0 CSTATE_various_forms2 CSTATE_various_forms4 i22)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have f4: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms4 by moura
  have "∀m t n h r ma ta. CSTATE m t n ∨ ¬ CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n"
    using CSTATE_general_rule_3_0 by moura
  then have "CSTATE Modified T 1 ∨ CSTATE Modified T 0 ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified ∧ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified"
    using f4 f3 by metis
  moreover
  { assume "CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified ∧ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified"
    then have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs CleanEvict T 0"
      by moura }
  moreover
  { assume "CSTATE Modified T 0"
    then have "¬ HSTATE SharedM T"
      using f1 by metis }
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ HSTATE SharedM T"
      using f2 by metis }
  ultimately have "HSTATE SharedM T ⟶ (CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs CleanEvict T 0"
    by metis
  moreover
  { assume "¬ HSTATE SharedM T"
    then have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs CleanEvict T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs CleanEvict T 0"
    by metis
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) = Modified ⟶ CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) = Modified ⟶ CLEntry.block_state (devcache1 ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(3) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ SharedM"
      using HOST_State.distinct(3) by moura
    then have "¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs RdShared T 0"
    by moura
  then show "HSTATE SharedM T ∧ nextReqIs RdShared T 0 ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 CSTATE_def
    CSTATE_various_forms1 CSTATE_various_forms2 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def
    IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MESI_State.distinct(137)
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 i946 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(3) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ SharedM"
      using HOST_State.distinct(3) by moura
    then have "¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs RdShared T 0"
    by moura
  then show "HSTATE SharedM T ∧ nextReqIs RdShared T 0 ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE ModifiedM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=hostdata nextReqID T 0] [ 5 sHost= SharedM] [ 0 +=reqresp GO Shared nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostInvalidRdShared_otherside_invariant2 CSTATE_HostInvalidRdShared_otherside_invariant3
    i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
161.669s elapsed time, 86.500s cpu time, 5.250s GC time 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
SH Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
METHOD Future: result = timeout 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostSide_rule_3_1 CSTATE_disj1 CSTATE_various_forms4 DATA_COL_def
    DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def
    HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MESI_State.distinct(179) MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def
    RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def
    SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i22 i518 i727
    lastSharer_def numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_not_def MESI_State.distinct(163,175,179) assms i26 i556 lastSharer_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 nextReqIs_otherside_rule_1_0)

Isar proof:
proof -
  have "∀veriT_vr37 veriT_vr36 veriT_vr35 veriT_vr34 veriT_vr33 veriT_vr32. (¬ nextReqIs veriT_vr33 ( veriT_vr32 [ 5 sHost= veriT_vr34] [ 0 +=reqresp veriT_vr35 veriT_vr36 veriT_vr37] [ 0 -=req ]) 0) = (¬ nextReqIs veriT_vr33 ( veriT_vr32 [ 5 sHost= veriT_vr34] [ 0 +=reqresp veriT_vr35 veriT_vr36 veriT_vr37] [ 0 -=req ]) 0)"
    by auto
  then have f1: "∀t r h ra m ta. SWMR_state_machine t ⟶ ¬ nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 0"
    by (metis minus_req_nextReqIs_False_swmrp_rule_1_0)
  have "∀veriT_vr980. (if CSTATE Invalid veriT_vr980 0 ∨ CSTATE Invalid veriT_vr980 1 then True else False) = (CSTATE Invalid veriT_vr980 0 ∨ CSTATE Invalid veriT_vr980 1)"
    by auto
  then have f2: "∀t. lastSharer t = (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)"
    by (metis lastSharer_def)
  have f3: "((∃veriT_vr981. lastSharer veriT_vr981 ≠ (CSTATE Invalid veriT_vr981 0 ∨ CSTATE Invalid veriT_vr981 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
    by auto
  have f4: "((∃veriT_vr981. lastSharer veriT_vr981 ≠ (CSTATE Invalid veriT_vr981 0 ∨ CSTATE Invalid veriT_vr981 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ (∀veriT_vr981. lastSharer veriT_vr981 = (CSTATE Invalid veriT_vr981 0 ∨ CSTATE Invalid veriT_vr981 1))"
    by auto
  have f5: "(∃veriT_vr981. lastSharer veriT_vr981 ∧ ¬ CSTATE Invalid veriT_vr981 0 ∧ ¬ CSTATE Invalid veriT_vr981 1) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr981. lastSharer veriT_vr981 ≠ (CSTATE Invalid veriT_vr981 0 ∨ CSTATE Invalid veriT_vr981 1)) ∨ (∀veriT_vr981. ¬ lastSharer veriT_vr981 ∨ CSTATE Invalid veriT_vr981 0 ∨ CSTATE Invalid veriT_vr981 1)"
    by auto
  then have "(∃t. lastSharer t ≠ (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f3 f4 f5 by metis
  then have f6: "¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f2 by metis
  have "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f7: "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by (metis assms)
  have f8: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. SWMR_state_machine veriT_vr38 ∧ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have f9: "((∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. SWMR_state_machine veriT_vr38 ∧ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. ¬ SWMR_state_machine veriT_vr38 ∨ ¬ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0)"
    by auto
  have f10: "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. SWMR_state_machine veriT_vr38 ∧ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have "(∃veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. SWMR_state_machine veriT_vr38 ∧ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0) ∨ (∀veriT_vr38 veriT_vr39 veriT_vr40 veriT_vr41 veriT_vr42 veriT_vr43. ¬ SWMR_state_machine veriT_vr38 ∨ ¬ nextReqIs veriT_vr39 ( veriT_vr38 [ 5 sHost= veriT_vr40] [ 0 +=reqresp veriT_vr41 veriT_vr42 veriT_vr43] [ 0 -=req ]) 0)"
    by auto
  then have "¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f8 f9 f10 f1 by metis
  then have f11: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f7 by metis
  have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f12: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f11 by metis
  have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f13: "HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
    using f12 by metis
  have f14: "((∃veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr298 veriT_vr299 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f15: "((∃veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr298 veriT_vr299 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 = nextReqIs veriT_vr298 veriT_vr299 1)"
    by auto
  have f16: "(∃veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 ∧ ¬ nextReqIs veriT_vr298 veriT_vr299 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr298 veriT_vr299 1) ∨ (∀veriT_vr298 veriT_vr299 veriT_vr300 veriT_vr301 veriT_vr302 veriT_vr303. ¬ nextReqIs veriT_vr298 ( veriT_vr299 [ 5 sHost= veriT_vr300] [ 0 +=reqresp veriT_vr301 veriT_vr302 veriT_vr303] [ 0 -=req ]) 1 ∨ nextReqIs veriT_vr298 veriT_vr299 1)"
    by auto
  then have "(∃r t h ra m ta. nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f14 f15 f16 by metis
  then have f17: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_otherside_rule_1_0)
  have f18: "((∃veriT_vr945 veriT_vr946 veriT_vr947. C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 ≠ ((nextReqIs veriT_vr945 veriT_vr947 0 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 0) ∧ (nextReqIs veriT_vr945 veriT_vr947 1 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1"
    by auto
  have f19: "((∃veriT_vr945 veriT_vr946 veriT_vr947. C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 ≠ ((nextReqIs veriT_vr945 veriT_vr947 0 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 0) ∧ (nextReqIs veriT_vr945 veriT_vr947 1 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ (∀veriT_vr945 veriT_vr946 veriT_vr947. C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 = ((nextReqIs veriT_vr945 veriT_vr947 0 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 0) ∧ (nextReqIs veriT_vr945 veriT_vr947 1 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 1)))"
    by auto
  have f20: "(∃veriT_vr945 veriT_vr946 veriT_vr947. C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 ∧ nextReqIs veriT_vr945 veriT_vr947 1 ∧ CSTATE veriT_vr946 veriT_vr947 1) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr945 veriT_vr946 veriT_vr947. C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 ≠ ((nextReqIs veriT_vr945 veriT_vr947 0 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 0) ∧ (nextReqIs veriT_vr945 veriT_vr947 1 ⟶ ¬ CSTATE veriT_vr946 veriT_vr947 1))) ∨ (∀veriT_vr945 veriT_vr946 veriT_vr947. ¬ C_msg_not veriT_vr945 veriT_vr946 veriT_vr947 ∨ ¬ nextReqIs veriT_vr945 veriT_vr947 1 ∨ ¬ CSTATE veriT_vr946 veriT_vr947 1)"
    by auto
  then have "(∃r m t. C_msg_not r m t ≠ ((nextReqIs r t 0 ⟶ ¬ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ ¬ CSTATE m t 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f18 f19 f20 by metis
  then have f21: "¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by (metis C_msg_not_def)
  have f22: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0"
    by auto
  have f23: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr703 veriT_vr704 veriT_vr705. (¬ CSTATE veriT_vr703 veriT_vr704 0 ∨ veriT_vr703 = veriT_vr705) ∨ ¬ CSTATE veriT_vr705 veriT_vr704 0)"
    by auto
  have f24: "(∃veriT_vr703 veriT_vr704 veriT_vr705. CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705 ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  have f25: "(∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ (∀veriT_vr703 veriT_vr704 veriT_vr705. ¬ CSTATE veriT_vr703 veriT_vr704 0 ∨ veriT_vr703 = veriT_vr705 ∨ ¬ CSTATE veriT_vr705 veriT_vr704 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    using f22 f23 f24 by metis
  then have f26: "¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    by (metis CSTATE_different1)
  have f27: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0"
    by auto
  have f28: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ (∀veriT_vr703 veriT_vr704 veriT_vr705. (¬ CSTATE veriT_vr703 veriT_vr704 0 ∨ veriT_vr703 = veriT_vr705) ∨ ¬ CSTATE veriT_vr705 veriT_vr704 0)"
    by auto
  have "(∃veriT_vr703 veriT_vr704 veriT_vr705. CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705 ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f27 f28 f25 by metis
  then have f29: "¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by (metis CSTATE_different1)
  have f30: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0"
    by auto
  have f31: "((∃veriT_vr703 veriT_vr704 veriT_vr705. (CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705) ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr703 veriT_vr704 veriT_vr705. (¬ CSTATE veriT_vr703 veriT_vr704 0 ∨ veriT_vr703 = veriT_vr705) ∨ ¬ CSTATE veriT_vr705 veriT_vr704 0)"
    by auto
  have "(∃veriT_vr703 veriT_vr704 veriT_vr705. CSTATE veriT_vr703 veriT_vr704 0 ∧ veriT_vr703 ≠ veriT_vr705 ∧ CSTATE veriT_vr705 veriT_vr704 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    using f30 f31 f25 by metis
  then have f32: "¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by (metis CSTATE_different1)
  have "CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "¬ CSTATE IIA T 0 ∨ ¬ CSTATE Invalid T 0"
    using f32 by (metis MESI_State.distinct(163))
  moreover
  { assume aa1: "¬ CSTATE IIA T 0"
    have "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ CSTATE IIA T 0 ∨ CSTATE SIAC T 0"
      by auto
    then have "CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ ¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      using aa1 by metis
    moreover
    { assume "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      then have fff1: "¬ nextReqIs CleanEvictNoData T 0 ∧ ¬ nextReqIs CleanEvict T 0"
        by (metis i556)
      have "(nextReqIs CleanEvictNoData T 0 ∨ nextReqIs CleanEvict T 0) ∨ ¬ nextReqIs CleanEvict T 0"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using fff1 by metis }
    moreover
    { assume "CSTATE SIA T 0"
      then have fff1: "(¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∧ CSTATE SIA T 0"
        using f26 by metis
      have "CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have "¬ CSTATE Invalid T 0"
        using fff1 by (metis MESI_State.distinct(175)) }
    moreover
    { assume "CSTATE SIAC T 0"
      then have fff1: "(¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∧ CSTATE SIAC T 0"
        using f29 by metis
      have "CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0 ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
        by auto
      then have "¬ CSTATE Invalid T 0"
        using fff1 by (metis MESI_State.distinct(179)) }
    ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      by metis }
  ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
  moreover
  { assume "¬ CSTATE Invalid T 0"
    then have "CSTATE Invalid T 1 ∨ (¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      using f6 by metis
    moreover
    { assume aaa1: "(¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      have "lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1 ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using aaa1 by metis }
    moreover
    { assume "CSTATE Invalid T 1"
      then have fff1: "(¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∧ CSTATE Invalid T 1"
        using f21 by metis
      have "C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1 ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
        by auto
      then have "¬ nextReqIs RdShared T 1"
        using fff1 by (metis i26)
      then have fff2: "(¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
        using f17 by metis
      have "nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
        by auto
      then have fff3: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff2 by metis
      have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have fff4: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff3 by metis
      have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using fff4 by metis
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using f13 by metis }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      by metis }
  ultimately have f33: "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
  have f34: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) = (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  have f35: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ≠ ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ ((¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2)) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by auto
  have "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) = ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    using f33 f34 f35 by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(35) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ SB"
      using HOST_State.distinct(35) by moura
    then have "¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE SharedM T ∨ lastSharer T ∨ CSTATE IIA T ((0 + 1) mod 2) ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ nextReqIs CleanEvict T 0"
    by moura
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ ¬ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ¬ CSTATE IIA T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_not_def MESI_State.distinct(163,175,179) assms i26 i556 lastSharer_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 nextReqIs_otherside_rule_1_0)

Isar proof:
proof -
  have "∀veriT_vr317 veriT_vr316 veriT_vr315 veriT_vr314 veriT_vr313 veriT_vr312. (¬ nextReqIs veriT_vr313 ( veriT_vr312 [ 5 sHost= veriT_vr314] [ 0 +=reqresp veriT_vr315 veriT_vr316 veriT_vr317] [ 0 -=req ]) 0) = (¬ nextReqIs veriT_vr313 ( veriT_vr312 [ 5 sHost= veriT_vr314] [ 0 +=reqresp veriT_vr315 veriT_vr316 veriT_vr317] [ 0 -=req ]) 0)"
    by auto
  then have f1: "∀t r h ra m ta. SWMR_state_machine t ⟶ ¬ nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 0"
    by (metis minus_req_nextReqIs_False_swmrp_rule_1_0)
  have "∀veriT_vr1184. (if CSTATE Invalid veriT_vr1184 0 ∨ CSTATE Invalid veriT_vr1184 1 then True else False) = (CSTATE Invalid veriT_vr1184 0 ∨ CSTATE Invalid veriT_vr1184 1)"
    by auto
  then have f2: "∀t. lastSharer t = (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)"
    by (metis lastSharer_def)
  have f3: "((∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
    by auto
  have f4: "((∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ (∀veriT_vr1185. lastSharer veriT_vr1185 = (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1))"
    by auto
  have f5: "(∃veriT_vr1185. lastSharer veriT_vr1185 ∧ ¬ CSTATE Invalid veriT_vr1185 0 ∧ ¬ CSTATE Invalid veriT_vr1185 1) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ (∀veriT_vr1185. ¬ lastSharer veriT_vr1185 ∨ CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)"
    by auto
  then have "(∃t. lastSharer t ≠ (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f3 f4 f5 by metis
  then have f6: "¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f2 by metis
  have "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f7: "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by (metis assms)
  have f8: "((∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have f9: "((∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ (∀veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. ¬ SWMR_state_machine veriT_vr318 ∨ ¬ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0)"
    by auto
  have f10: "(∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have "(∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ (∀veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. ¬ SWMR_state_machine veriT_vr318 ∨ ¬ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0)"
    by auto
  then have "¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f8 f9 f10 f1 by metis
  then have f11: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f7 by metis
  have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f12: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f11 by metis
  have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f13: "HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
    using f12 by metis
  have f14: "((∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f15: "((∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 = nextReqIs veriT_vr306 veriT_vr307 1)"
    by auto
  have f16: "(∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ∧ ¬ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ (∀veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. ¬ nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ∨ nextReqIs veriT_vr306 veriT_vr307 1)"
    by auto
  then have "(∃r t h ra m ta. nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f14 f15 f16 by metis
  then have f17: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_otherside_rule_1_0)
  have f18: "((∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1"
    by auto
  have f19: "((∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ (∀veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 = ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1)))"
    by auto
  have f20: "(∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ∧ nextReqIs veriT_vr1017 veriT_vr1019 1 ∧ CSTATE veriT_vr1018 veriT_vr1019 1) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ (∀veriT_vr1017 veriT_vr1018 veriT_vr1019. ¬ C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ∨ ¬ nextReqIs veriT_vr1017 veriT_vr1019 1 ∨ ¬ CSTATE veriT_vr1018 veriT_vr1019 1)"
    by auto
  then have f21: "(∃r m t. C_msg_not r m t ≠ ((nextReqIs r t 0 ⟶ ¬ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ ¬ CSTATE m t 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f18 f19 f20 by metis
  have f22: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0"
    by auto
  have f23: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have f24: "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  have f25: "(∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. ¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753 ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  then have f26: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    using f22 f23 f24 by metis
  have f27: "¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f21 by (metis C_msg_not_def)
  have f28: "¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    using f26 by (metis CSTATE_different1)
  have f29: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0"
    by auto
  have f30: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f29 f30 f25 by metis
  then have f31: "¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by (metis CSTATE_different1)
  have f32: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0"
    by auto
  have f33: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    using f32 f33 f25 by metis
  then have f34: "¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by (metis CSTATE_different1)
  have "CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "¬ CSTATE IIA T 0 ∨ ¬ CSTATE Invalid T 0"
    using f34 by (metis MESI_State.distinct(163))
  moreover
  { assume aa1: "¬ CSTATE IIA T 0"
    have "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ CSTATE IIA T 0 ∨ CSTATE SIAC T 0"
      by auto
    then have "CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ ¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      using aa1 by metis
    moreover
    { assume "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      then have fff1: "¬ nextReqIs CleanEvictNoData T 0 ∧ ¬ nextReqIs CleanEvict T 0"
        by (metis i556)
      have "(nextReqIs CleanEvictNoData T 0 ∨ nextReqIs CleanEvict T 0) ∨ ¬ nextReqIs CleanEvict T 0"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using fff1 by metis }
    moreover
    { assume "CSTATE SIA T 0"
      then have fff1: "(¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∧ CSTATE SIA T 0"
        using f28 by metis
      have "CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have "¬ CSTATE Invalid T 0"
        using fff1 by (metis MESI_State.distinct(175)) }
    moreover
    { assume "CSTATE SIAC T 0"
      then have fff1: "(¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∧ CSTATE SIAC T 0"
        using f31 by metis
      have "CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0 ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
        by auto
      then have "¬ CSTATE Invalid T 0"
        using fff1 by (metis MESI_State.distinct(179)) }
    ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      by metis }
  ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
  moreover
  { assume "¬ CSTATE Invalid T 0"
    then have "CSTATE Invalid T 1 ∨ (¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      using f6 by metis
    moreover
    { assume aaa1: "(¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      have "lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1 ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using aaa1 by metis }
    moreover
    { assume "CSTATE Invalid T 1"
      then have fff1: "(¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∧ CSTATE Invalid T 1"
        using f27 by metis
      have "C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1 ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
        by auto
      then have "¬ nextReqIs RdShared T 1"
        using fff1 by (metis i26)
      then have fff2: "(¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
        using f17 by metis
      have "nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
        by auto
      then have fff3: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff2 by metis
      have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have fff4: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff3 by metis
      have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using fff4 by metis
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using f13 by metis }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      by metis }
  ultimately have f35: "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
  have f36: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) = (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  have f37: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ≠ ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ ((¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2)) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by auto
  have "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)) = ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    using f35 f36 f37 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HOST_State.distinct(3) HSTATE_invariant3
    HostShared_CleanEvictNoData_NotLast_HSTATE IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def
    IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def
    MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def
    MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def
    OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2 DATA_COL_def
    DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def
    HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def
    RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def
    SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i22 i729
    nextGOPending_HostShared_CleanEvictNoData_Last numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def
    HostShared_CleanEvictNoData_NotLast_nextSnpRespIs_sameside IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def
    IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def
    MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def
    MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def
    M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def
    SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i950
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_not_def MESI_State.distinct(163,175,179) assms i26 i556 lastSharer_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 nextReqIs_otherside_rule_1_0)

Isar proof:
proof -
  have "∀veriT_vr317 veriT_vr316 veriT_vr315 veriT_vr314 veriT_vr313 veriT_vr312. (¬ nextReqIs veriT_vr313 ( veriT_vr312 [ 5 sHost= veriT_vr314] [ 0 +=reqresp veriT_vr315 veriT_vr316 veriT_vr317] [ 0 -=req ]) 0) = (¬ nextReqIs veriT_vr313 ( veriT_vr312 [ 5 sHost= veriT_vr314] [ 0 +=reqresp veriT_vr315 veriT_vr316 veriT_vr317] [ 0 -=req ]) 0)"
    by auto
  then have f1: "∀t r h ra m ta. SWMR_state_machine t ⟶ ¬ nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 0"
    by (metis minus_req_nextReqIs_False_swmrp_rule_1_0)
  have "∀veriT_vr1184. (if CSTATE Invalid veriT_vr1184 0 ∨ CSTATE Invalid veriT_vr1184 1 then True else False) = (CSTATE Invalid veriT_vr1184 0 ∨ CSTATE Invalid veriT_vr1184 1)"
    by auto
  then have f2: "∀t. lastSharer t = (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)"
    by (metis lastSharer_def)
  have f3: "((∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
    by auto
  have f4: "((∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ (∀veriT_vr1185. lastSharer veriT_vr1185 = (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1))"
    by auto
  have f5: "(∃veriT_vr1185. lastSharer veriT_vr1185 ∧ ¬ CSTATE Invalid veriT_vr1185 0 ∧ ¬ CSTATE Invalid veriT_vr1185 1) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1185. lastSharer veriT_vr1185 ≠ (CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)) ∨ (∀veriT_vr1185. ¬ lastSharer veriT_vr1185 ∨ CSTATE Invalid veriT_vr1185 0 ∨ CSTATE Invalid veriT_vr1185 1)"
    by auto
  then have "(∃t. lastSharer t ≠ (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f3 f4 f5 by metis
  then have f6: "¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f2 by metis
  have "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f7: "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by (metis assms)
  have f8: "((∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have f9: "((∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ (∀veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. ¬ SWMR_state_machine veriT_vr318 ∨ ¬ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0)"
    by auto
  have f10: "(∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have "(∃veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. SWMR_state_machine veriT_vr318 ∧ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0) ∨ (∀veriT_vr318 veriT_vr319 veriT_vr320 veriT_vr321 veriT_vr322 veriT_vr323. ¬ SWMR_state_machine veriT_vr318 ∨ ¬ nextReqIs veriT_vr319 ( veriT_vr318 [ 5 sHost= veriT_vr320] [ 0 +=reqresp veriT_vr321 veriT_vr322 veriT_vr323] [ 0 -=req ]) 0)"
    by auto
  then have "¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f8 f9 f10 f1 by metis
  then have f11: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f7 by metis
  have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f12: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f11 by metis
  have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f13: "HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f12 by metis
  have f14: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0"
    by auto
  have f15: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have f16: "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  have f17: "(∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. ¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753 ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  then have f18: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    using f14 f15 f16 by metis
  have f19: "((∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f20: "((∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 = nextReqIs veriT_vr306 veriT_vr307 1)"
    by auto
  have f21: "(∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ∧ ¬ nextReqIs veriT_vr306 veriT_vr307 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr306 veriT_vr307 1) ∨ (∀veriT_vr306 veriT_vr307 veriT_vr308 veriT_vr309 veriT_vr310 veriT_vr311. ¬ nextReqIs veriT_vr306 ( veriT_vr307 [ 5 sHost= veriT_vr308] [ 0 +=reqresp veriT_vr309 veriT_vr310 veriT_vr311] [ 0 -=req ]) 1 ∨ nextReqIs veriT_vr306 veriT_vr307 1)"
    by auto
  then have f22: "(∃r t h ra m ta. nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f19 f20 f21 by metis
  have "CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have f23: "CSTATE SIA T 0 ∧ Invalid ≠ SIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE SIA T 0 ∨ ¬ CSTATE Invalid T 0"
    by (metis MESI_State.distinct(175))
  have f24: "¬ CSTATE SIA T 0 ∨ Invalid = SIA ∨ ¬ CSTATE Invalid T 0"
    using f18 by (metis CSTATE_different1)
  have f25: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f22 by (metis nextReqIs_otherside_rule_1_0)
  have f26: "((∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1"
    by auto
  have f27: "((∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ (∀veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 = ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1)))"
    by auto
  have f28: "(∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ∧ nextReqIs veriT_vr1017 veriT_vr1019 1 ∧ CSTATE veriT_vr1018 veriT_vr1019 1) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1017 veriT_vr1018 veriT_vr1019. C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ≠ ((nextReqIs veriT_vr1017 veriT_vr1019 0 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 0) ∧ (nextReqIs veriT_vr1017 veriT_vr1019 1 ⟶ ¬ CSTATE veriT_vr1018 veriT_vr1019 1))) ∨ (∀veriT_vr1017 veriT_vr1018 veriT_vr1019. ¬ C_msg_not veriT_vr1017 veriT_vr1018 veriT_vr1019 ∨ ¬ nextReqIs veriT_vr1017 veriT_vr1019 1 ∨ ¬ CSTATE veriT_vr1018 veriT_vr1019 1)"
    by auto
  then have f29: "(∃r m t. C_msg_not r m t ≠ ((nextReqIs r t 0 ⟶ ¬ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ ¬ CSTATE m t 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f26 f27 f28 by metis
  have f30: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0"
    by auto
  have f31: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by auto
  then have f32: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f30 f31 f17 by metis
  have f33: "¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f29 by (metis C_msg_not_def)
  have f34: "¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f32 by (metis CSTATE_different1)
  have f35: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0"
    by auto
  have f36: "((∃veriT_vr751 veriT_vr752 veriT_vr753. (CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753) ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0) ∨ (∀veriT_vr751 veriT_vr752 veriT_vr753. (¬ CSTATE veriT_vr751 veriT_vr752 0 ∨ veriT_vr751 = veriT_vr753) ∨ ¬ CSTATE veriT_vr753 veriT_vr752 0)"
    by auto
  have "(∃veriT_vr751 veriT_vr752 veriT_vr753. CSTATE veriT_vr751 veriT_vr752 0 ∧ veriT_vr751 ≠ veriT_vr753 ∧ CSTATE veriT_vr753 veriT_vr752 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    using f35 f36 f17 by metis
  then have f37: "¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by (metis CSTATE_different1)
  have "CSTATE IIA T 0 ∧ Invalid ≠ IIA ∧ CSTATE Invalid T 0 ∨ ¬ CSTATE IIA T 0 ∨ Invalid = IIA ∨ ¬ CSTATE Invalid T 0"
    by auto
  then have "¬ CSTATE IIA T 0 ∨ ¬ CSTATE Invalid T 0"
    using f37 by (metis MESI_State.distinct(163))
  moreover
  { assume aa1: "¬ CSTATE IIA T 0"
    have "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ CSTATE IIA T 0 ∨ CSTATE SIAC T 0"
      by auto
    then have "CSTATE SIAC T 0 ∨ CSTATE SIA T 0 ∨ ¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      using aa1 by metis
    moreover
    { assume "¬ CSTATE SIA T 0 ∧ ¬ CSTATE IIA T 0 ∧ ¬ CSTATE SIAC T 0"
      then have fff1: "¬ nextReqIs CleanEvictNoData T 0 ∧ ¬ nextReqIs CleanEvict T 0"
        by (metis i556)
      have "(nextReqIs CleanEvictNoData T 0 ∨ nextReqIs CleanEvict T 0) ∨ ¬ nextReqIs CleanEvict T 0"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using fff1 by metis }
    moreover
    { assume "CSTATE SIA T 0"
      then have "¬ CSTATE Invalid T 0"
        using f24 f23 by metis }
    moreover
    { assume "CSTATE SIAC T 0"
      then have fff1: "(¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∧ CSTATE SIAC T 0"
        using f34 by metis
      have "CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0 ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
        by auto
      then have "¬ CSTATE Invalid T 0"
        using fff1 by (metis MESI_State.distinct(179)) }
    ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  ultimately have "CSTATE Invalid T 0 ⟶ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
  moreover
  { assume "¬ CSTATE Invalid T 0"
    then have "CSTATE Invalid T 1 ∨ (¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      using f6 by metis
    moreover
    { assume aaa1: "(¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      have "lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1 ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using aaa1 by metis }
    moreover
    { assume "CSTATE Invalid T 1"
      then have fff1: "(¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∧ CSTATE Invalid T 1"
        using f33 by metis
      have "C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1 ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
        by auto
      then have "¬ nextReqIs RdShared T 1"
        using fff1 by (metis i26)
      then have fff2: "(¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
        using f25 by metis
      have "nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
        by auto
      then have fff3: "¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff2 by metis
      have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have fff4: "¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff3 by metis
      have "(HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
        using fff4 by metis
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using f13 by metis }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  ultimately have f38: "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
  have f39: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  have f40: "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ≠ ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ ((¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvict T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2)) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ (HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by auto
  have "((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = ((HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvict T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE ModifiedM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= IB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    using f38 f39 f40 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def HOST_State.distinct(3) HSTATE_invariant3
    HostShared_CleanEvictNoData_NotLast_HSTATE HostShared_CleanEvictNoData_NotLast_nextSnpRespIs_sameside IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i950 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
156.043s elapsed time, 78.812s cpu time, 5.812s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_NotLast_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
110.419s elapsed time, 50.562s cpu time, 5.266s GC time 
SH Future: starting 
Done 
Sledgehammering... 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 CSTATE_def
    CSTATE_various_forms1 CSTATE_various_forms2 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def
    IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MESI_State.distinct(121)
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_general_rule_3_0 CSTATE_various_forms2 CSTATE_various_forms6 i22)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f2: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f3: "∀m t. CSTATE m t 0 ∨ CLEntry.block_state (devcache1 t) ≠ m"
    using CSTATE_various_forms2 by moura
  have f4: "∀m t. CSTATE m t 1 ∨ CLEntry.block_state (devcache2 t) ≠ m"
    using CSTATE_various_forms6 by moura
  have "∀m t n h r ma ta. CSTATE m t n ∨ ¬ CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n"
    using CSTATE_general_rule_3_0 by moura
  then have "CSTATE Modified T 1 ∨ CSTATE Modified T 0 ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified ∧ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified"
    using f4 f3 by metis
  moreover
  { assume "CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified ∧ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified"
    then have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
      by moura }
  moreover
  { assume "CSTATE Modified T 0"
    then have "¬ HSTATE SharedM T"
      using f1 by metis }
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ HSTATE SharedM T"
      using f2 by metis }
  ultimately have "HSTATE SharedM T ⟶ (CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
    by metis
  moreover
  { assume "¬ HSTATE SharedM T"
    then have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
      by moura }
  ultimately have "(CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared ∨ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Modified) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
    by metis
  then show "HSTATE SharedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE IIA T 0 ⟶ (CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) = Modified ⟶ CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared) ∧ (CLEntry.block_state (devcache2 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) = Modified ⟶ CLEntry.block_state (devcache1 ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])) ≠ Shared)"
    by metis
next 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvict_Last_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
136.008s elapsed time, 73.500s cpu time, 5.766s GC time 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostModified_DirtyEvict_otherside_invariant2 CSTATE_various_forms4 DATA_COL_def
    DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def
    HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def
    ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def
    MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def
    MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def
    RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def
    SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def STORE_COL_def i107 i595 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_not_def MESI_State.distinct(179) assms i26 i946 lastSharer_def
    minus_req_nextReqIs_False_swmrp_rule_1_0 nextReqIs_otherside_rule_1_0)

Isar proof:
proof -
  have "∀veriT_vr187 veriT_vr186 veriT_vr185 veriT_vr184 veriT_vr183 veriT_vr182. (¬ nextReqIs veriT_vr183 ( veriT_vr182 [ 5 sHost= veriT_vr184] [ 0 +=reqresp veriT_vr185 veriT_vr186 veriT_vr187] [ 0 -=req ]) 0) = (¬ nextReqIs veriT_vr183 ( veriT_vr182 [ 5 sHost= veriT_vr184] [ 0 +=reqresp veriT_vr185 veriT_vr186 veriT_vr187] [ 0 -=req ]) 0)"
    by auto
  then have f1: "∀t r h ra m ta. SWMR_state_machine t ⟶ ¬ nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 0"
    by (metis minus_req_nextReqIs_False_swmrp_rule_1_0)
  have "∀veriT_vr1216. (if CSTATE Invalid veriT_vr1216 0 ∨ CSTATE Invalid veriT_vr1216 1 then True else False) = (CSTATE Invalid veriT_vr1216 0 ∨ CSTATE Invalid veriT_vr1216 1)"
    by auto
  then have f2: "∀t. lastSharer t = (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)"
    by (metis lastSharer_def)
  have f3: "((∃veriT_vr1217. lastSharer veriT_vr1217 ≠ (CSTATE Invalid veriT_vr1217 0 ∨ CSTATE Invalid veriT_vr1217 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
    by auto
  have f4: "((∃veriT_vr1217. lastSharer veriT_vr1217 ≠ (CSTATE Invalid veriT_vr1217 0 ∨ CSTATE Invalid veriT_vr1217 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ (∀veriT_vr1217. lastSharer veriT_vr1217 = (CSTATE Invalid veriT_vr1217 0 ∨ CSTATE Invalid veriT_vr1217 1))"
    by auto
  have f5: "(∃veriT_vr1217. lastSharer veriT_vr1217 ∧ ¬ CSTATE Invalid veriT_vr1217 0 ∧ ¬ CSTATE Invalid veriT_vr1217 1) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1217. lastSharer veriT_vr1217 ≠ (CSTATE Invalid veriT_vr1217 0 ∨ CSTATE Invalid veriT_vr1217 1)) ∨ (∀veriT_vr1217. ¬ lastSharer veriT_vr1217 ∨ CSTATE Invalid veriT_vr1217 0 ∨ CSTATE Invalid veriT_vr1217 1)"
    by auto
  then have "(∃t. lastSharer t ≠ (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f3 f4 f5 by metis
  then have f6: "¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f2 by metis
  have "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f7: "SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by (metis assms)
  have f8: "((∃veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. SWMR_state_machine veriT_vr188 ∧ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ SWMR_state_machine T ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have f9: "((∃veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. SWMR_state_machine veriT_vr188 ∧ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ (∀veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. ¬ SWMR_state_machine veriT_vr188 ∨ ¬ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0)"
    by auto
  have f10: "(∃veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. SWMR_state_machine veriT_vr188 ∧ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0) ∨ ¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  have "(∃veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. SWMR_state_machine veriT_vr188 ∧ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0) ∨ (∀veriT_vr188 veriT_vr189 veriT_vr190 veriT_vr191 veriT_vr192 veriT_vr193. ¬ SWMR_state_machine veriT_vr188 ∨ ¬ nextReqIs veriT_vr189 ( veriT_vr188 [ 5 sHost= veriT_vr190] [ 0 +=reqresp veriT_vr191 veriT_vr192 veriT_vr193] [ 0 -=req ]) 0)"
    by auto
  then have "¬ SWMR_state_machine T ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f8 f9 f10 f1 by metis
  then have f11: "¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f7 by metis
  have "(¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f12: "¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    using f11 by metis
  have "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
    by auto
  then have f13: "HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
    using f12 by metis
  have f14: "((∃veriT_vr571 veriT_vr572 veriT_vr573. (CSTATE veriT_vr571 veriT_vr572 0 ∧ veriT_vr571 ≠ veriT_vr573) ∧ CSTATE veriT_vr573 veriT_vr572 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0"
    by auto
  have f15: "((∃veriT_vr571 veriT_vr572 veriT_vr573. (CSTATE veriT_vr571 veriT_vr572 0 ∧ veriT_vr571 ≠ veriT_vr573) ∧ CSTATE veriT_vr573 veriT_vr572 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ (∀veriT_vr571 veriT_vr572 veriT_vr573. (¬ CSTATE veriT_vr571 veriT_vr572 0 ∨ veriT_vr571 = veriT_vr573) ∨ ¬ CSTATE veriT_vr573 veriT_vr572 0)"
    by auto
  have f16: "(∃veriT_vr571 veriT_vr572 veriT_vr573. CSTATE veriT_vr571 veriT_vr572 0 ∧ veriT_vr571 ≠ veriT_vr573 ∧ CSTATE veriT_vr573 veriT_vr572 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by auto
  have "(∃veriT_vr571 veriT_vr572 veriT_vr573. (CSTATE veriT_vr571 veriT_vr572 0 ∧ veriT_vr571 ≠ veriT_vr573) ∧ CSTATE veriT_vr573 veriT_vr572 0) ∨ (∀veriT_vr571 veriT_vr572 veriT_vr573. ¬ CSTATE veriT_vr571 veriT_vr572 0 ∨ veriT_vr571 = veriT_vr573 ∨ ¬ CSTATE veriT_vr573 veriT_vr572 0)"
    by auto
  then have f17: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f14 f15 f16 by metis
  have f18: "((∃veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr212 veriT_vr213 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f19: "((∃veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr212 veriT_vr213 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 = nextReqIs veriT_vr212 veriT_vr213 1)"
    by auto
  have f20: "(∃veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 ∧ ¬ nextReqIs veriT_vr212 veriT_vr213 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr212 veriT_vr213 1) ∨ (∀veriT_vr212 veriT_vr213 veriT_vr214 veriT_vr215 veriT_vr216 veriT_vr217. ¬ nextReqIs veriT_vr212 ( veriT_vr213 [ 5 sHost= veriT_vr214] [ 0 +=reqresp veriT_vr215 veriT_vr216 veriT_vr217] [ 0 -=req ]) 1 ∨ nextReqIs veriT_vr212 veriT_vr213 1)"
    by auto
  then have f21: "(∃r t h ra m ta. nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f18 f19 f20 by metis
  have f22: "¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f17 by (metis CSTATE_different1)
  have f23: "¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f21 by (metis nextReqIs_otherside_rule_1_0)
  have f24: "((∃veriT_vr787 veriT_vr788 veriT_vr789. C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 ≠ ((nextReqIs veriT_vr787 veriT_vr789 0 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 0) ∧ (nextReqIs veriT_vr787 veriT_vr789 1 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1"
    by auto
  have f25: "((∃veriT_vr787 veriT_vr788 veriT_vr789. C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 ≠ ((nextReqIs veriT_vr787 veriT_vr789 0 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 0) ∧ (nextReqIs veriT_vr787 veriT_vr789 1 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ (∀veriT_vr787 veriT_vr788 veriT_vr789. C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 = ((nextReqIs veriT_vr787 veriT_vr789 0 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 0) ∧ (nextReqIs veriT_vr787 veriT_vr789 1 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 1)))"
    by auto
  have f26: "(∃veriT_vr787 veriT_vr788 veriT_vr789. C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 ∧ nextReqIs veriT_vr787 veriT_vr789 1 ∧ CSTATE veriT_vr788 veriT_vr789 1) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr787 veriT_vr788 veriT_vr789. C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 ≠ ((nextReqIs veriT_vr787 veriT_vr789 0 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 0) ∧ (nextReqIs veriT_vr787 veriT_vr789 1 ⟶ ¬ CSTATE veriT_vr788 veriT_vr789 1))) ∨ (∀veriT_vr787 veriT_vr788 veriT_vr789. ¬ C_msg_not veriT_vr787 veriT_vr788 veriT_vr789 ∨ ¬ nextReqIs veriT_vr787 veriT_vr789 1 ∨ ¬ CSTATE veriT_vr788 veriT_vr789 1)"
    by auto
  then have "(∃r m t. C_msg_not r m t ≠ ((nextReqIs r t 0 ⟶ ¬ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ ¬ CSTATE m t 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f24 f25 f26 by metis
  then have f27: "¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by (metis C_msg_not_def)
  have "C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1 ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  then have "¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f27 by (metis i26)
  moreover
  { assume "¬ CSTATE Invalid T 1"
    then have "CSTATE Invalid T 0 ∨ (¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      using f6 by metis
    moreover
    { assume aaa1: "(¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      have "lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1 ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        using aaa1 by metis }
    moreover
    { assume "CSTATE Invalid T 0"
      then have fff1: "(¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∧ CSTATE Invalid T 0"
        using f22 by metis
      have "CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0 ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
        by auto
      then have "¬ CSTATE SIAC T 0"
        using fff1 by (metis MESI_State.distinct(179))
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
        by (metis i946) }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      by metis }
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have ff1: "(¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
      using f23 by metis
    have "nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using ff1 by metis
    have "(¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have ff3: "¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using ff2 by metis
    have "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
      using ff3 by metis
    then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
      using f13 by metis }
  ultimately have f28: "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
  have f29: "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)) = (HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  have f30: "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)) ≠ ((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ ((¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2)) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)) ∨ (HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by auto
  have "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)) = ((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0))"
    by auto
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    using f28 f29 f30 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_HostModified_DirtyEvict_otherside_invariant2 i595 i75 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) HostShared_CleanEvictNoData_Last_nextSnpRespIs_sameside i950
    minus_req_nextReqIs_False_swmrp_rule_1_0 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_various_forms5 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def
    HostModifiedRdShared'_devcache_invariant1 HostModifiedRdShared'_devcache_invariant2 IIA_ROW_def IMAD_ROW_def
    IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def SWMR_def i0 i107 numeral_One one_mod_two_eq_one plus_nat.add_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this: apply (smt (verit) CSTATE_different1 CSTATE_general_rule_3_0 MESI_State.distinct(27) i595)

Isar proof:
proof -
  have f1: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ CSTATE Modified T 0"
    by auto
  have f2: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 = CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  have f3: "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∧ ¬ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    by auto
  have f4: "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. ¬ CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∨ CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  then have "(∃m t h r ma ta n. CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n ≠ CSTATE m t n) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    using f1 f2 f3 by metis
  then have f5: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    by (metis CSTATE_general_rule_3_0)
  have f6: "((∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∨ CSTATE MIA T 0 ∧ MIA ≠ Modified ∧ CSTATE Modified T 0"
    by auto
  have f7: "((∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∨ (∀veriT_vr397 veriT_vr398 veriT_vr399. (¬ CSTATE veriT_vr397 veriT_vr398 0 ∨ veriT_vr397 = veriT_vr399) ∨ ¬ CSTATE veriT_vr399 veriT_vr398 0)"
    by auto
  have f8: "(∃veriT_vr397 veriT_vr398 veriT_vr399. CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399 ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    by auto
  have "(∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ (∀veriT_vr397 veriT_vr398 veriT_vr399. ¬ CSTATE veriT_vr397 veriT_vr398 0 ∨ veriT_vr397 = veriT_vr399 ∨ ¬ CSTATE veriT_vr399 veriT_vr398 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    using f6 f7 f8 by metis
  then have f9: "¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    by (metis CSTATE_different1)
  have f10: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f11: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 = CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  have "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∧ ¬ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "(∃m t h r ma ta n. CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n ≠ CSTATE m t n) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    using f10 f11 f4 by metis
  then have f12: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_general_rule_3_0)
  have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ CSTATE Modified T 1"
    using f12 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by (metis i595) }
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
    have "(HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have "(¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using aa1 by metis
    then have "(HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
      have "(HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        by auto
      then have fff2: "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using aaa1 by metis
      have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
        by auto
      then have "CSTATE Modified T 0"
        using fff2 f5 by metis
      then have fff3: "(¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∧ CSTATE Modified T 0"
        using f9 by metis
      have "CSTATE MIA T 0 ∧ MIA ≠ Modified ∧ CSTATE Modified T 0 ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
        by auto
      then have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using fff3 by (metis MESI_State.distinct(27)) }
    ultimately have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  ultimately have f13: "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
  have f14: "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = (HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0 ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  have f15: "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ≠ ((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ ((¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0) ∨ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ (HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by auto
  have "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = ((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  then show "HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0 ⟶ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE SD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    using f13 f14 f15 by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModifiedRdShared_otherside_invariant3 CSTATE_X_rd_invariant1 i74 i75 numeral_One
    one_mod_two_eq_one plus_nat.add_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 C_msg_not_def MESI_State.distinct(179) i26 i946 i950 lastSharer_def
    nextReqIs_otherside_rule_1_0 nextSnpRespIs_general_rule_8_0)

Isar proof:
proof -
  have "∀veriT_vr1156. (if CSTATE Invalid veriT_vr1156 0 ∨ CSTATE Invalid veriT_vr1156 1 then True else False) = (CSTATE Invalid veriT_vr1156 0 ∨ CSTATE Invalid veriT_vr1156 1)"
    by auto
  then have f1: "∀t. lastSharer t = (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)"
    by (metis lastSharer_def)
  have f2: "((∃veriT_vr1157. lastSharer veriT_vr1157 ≠ (CSTATE Invalid veriT_vr1157 0 ∨ CSTATE Invalid veriT_vr1157 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
    by auto
  have f3: "((∃veriT_vr1157. lastSharer veriT_vr1157 ≠ (CSTATE Invalid veriT_vr1157 0 ∨ CSTATE Invalid veriT_vr1157 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∨ (∀veriT_vr1157. lastSharer veriT_vr1157 = (CSTATE Invalid veriT_vr1157 0 ∨ CSTATE Invalid veriT_vr1157 1))"
    by auto
  have f4: "(∃veriT_vr1157. lastSharer veriT_vr1157 ∧ ¬ CSTATE Invalid veriT_vr1157 0 ∧ ¬ CSTATE Invalid veriT_vr1157 1) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1157. lastSharer veriT_vr1157 ≠ (CSTATE Invalid veriT_vr1157 0 ∨ CSTATE Invalid veriT_vr1157 1)) ∨ (∀veriT_vr1157. ¬ lastSharer veriT_vr1157 ∨ CSTATE Invalid veriT_vr1157 0 ∨ CSTATE Invalid veriT_vr1157 1)"
    by auto
  then have f5: "(∃t. lastSharer t ≠ (CSTATE Invalid t 0 ∨ CSTATE Invalid t 1)) ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f2 f3 f4 by metis
  have f6: "((∃veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 ≠ nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f7: "((∃veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 ≠ nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 = nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261)"
    by auto
  have f8: "(∃veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 ∧ ¬ nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 ≠ nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261) ∨ (∀veriT_vr255 veriT_vr256 veriT_vr257 veriT_vr258 veriT_vr259 veriT_vr260 veriT_vr261. ¬ nextSnpRespIs veriT_vr255 ( veriT_vr256 [ 5 sHost= veriT_vr257] [ 0 +=reqresp veriT_vr258 veriT_vr259 veriT_vr260] [ 0 -=req ]) veriT_vr261 ∨ nextSnpRespIs veriT_vr255 veriT_vr256 veriT_vr261)"
    by auto
  then have f9: "(∃s t h r m ta n. nextSnpRespIs s ( t [ 5 sHost= h] [ 0 +=reqresp r m ta] [ 0 -=req ]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f6 f7 f8 by metis
  have f10: "¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
    using f5 f1 by metis
  have f11: "¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f9 by (metis nextSnpRespIs_general_rule_8_0)
  have f12: "((∃veriT_vr591 veriT_vr592 veriT_vr593. (CSTATE veriT_vr591 veriT_vr592 0 ∧ veriT_vr591 ≠ veriT_vr593) ∧ CSTATE veriT_vr593 veriT_vr592 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0"
    by auto
  have f13: "((∃veriT_vr591 veriT_vr592 veriT_vr593. (CSTATE veriT_vr591 veriT_vr592 0 ∧ veriT_vr591 ≠ veriT_vr593) ∧ CSTATE veriT_vr593 veriT_vr592 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∨ (∀veriT_vr591 veriT_vr592 veriT_vr593. (¬ CSTATE veriT_vr591 veriT_vr592 0 ∨ veriT_vr591 = veriT_vr593) ∨ ¬ CSTATE veriT_vr593 veriT_vr592 0)"
    by auto
  have f14: "(∃veriT_vr591 veriT_vr592 veriT_vr593. CSTATE veriT_vr591 veriT_vr592 0 ∧ veriT_vr591 ≠ veriT_vr593 ∧ CSTATE veriT_vr593 veriT_vr592 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    by auto
  have "(∃veriT_vr591 veriT_vr592 veriT_vr593. (CSTATE veriT_vr591 veriT_vr592 0 ∧ veriT_vr591 ≠ veriT_vr593) ∧ CSTATE veriT_vr593 veriT_vr592 0) ∨ (∀veriT_vr591 veriT_vr592 veriT_vr593. ¬ CSTATE veriT_vr591 veriT_vr592 0 ∨ veriT_vr591 = veriT_vr593 ∨ ¬ CSTATE veriT_vr593 veriT_vr592 0)"
    by auto
  then have f15: "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f12 f13 f14 by metis
  have f16: "((∃veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr228 veriT_vr229 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f17: "((∃veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr228 veriT_vr229 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 = nextReqIs veriT_vr228 veriT_vr229 1)"
    by auto
  have f18: "(∃veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 ∧ ¬ nextReqIs veriT_vr228 veriT_vr229 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 ≠ nextReqIs veriT_vr228 veriT_vr229 1) ∨ (∀veriT_vr228 veriT_vr229 veriT_vr230 veriT_vr231 veriT_vr232 veriT_vr233. ¬ nextReqIs veriT_vr228 ( veriT_vr229 [ 5 sHost= veriT_vr230] [ 0 +=reqresp veriT_vr231 veriT_vr232 veriT_vr233] [ 0 -=req ]) 1 ∨ nextReqIs veriT_vr228 veriT_vr229 1)"
    by auto
  then have f19: "(∃r t h ra m ta. nextReqIs r ( t [ 5 sHost= h] [ 0 +=reqresp ra m ta] [ 0 -=req ]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f16 f17 f18 by metis
  have f20: "¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
    using f15 by (metis CSTATE_different1)
  have f21: "¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
    using f19 by (metis nextReqIs_otherside_rule_1_0)
  have f22: "((∃veriT_vr1003 veriT_vr1004 veriT_vr1005. C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 ≠ ((nextReqIs veriT_vr1003 veriT_vr1005 0 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 0) ∧ (nextReqIs veriT_vr1003 veriT_vr1005 1 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1"
    by auto
  have f23: "((∃veriT_vr1003 veriT_vr1004 veriT_vr1005. C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 ≠ ((nextReqIs veriT_vr1003 veriT_vr1005 0 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 0) ∧ (nextReqIs veriT_vr1003 veriT_vr1005 1 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1) ∨ (∀veriT_vr1003 veriT_vr1004 veriT_vr1005. C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 = ((nextReqIs veriT_vr1003 veriT_vr1005 0 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 0) ∧ (nextReqIs veriT_vr1003 veriT_vr1005 1 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 1)))"
    by auto
  have f24: "(∃veriT_vr1003 veriT_vr1004 veriT_vr1005. C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 ∧ nextReqIs veriT_vr1003 veriT_vr1005 1 ∧ CSTATE veriT_vr1004 veriT_vr1005 1) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  have "(∃veriT_vr1003 veriT_vr1004 veriT_vr1005. C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 ≠ ((nextReqIs veriT_vr1003 veriT_vr1005 0 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 0) ∧ (nextReqIs veriT_vr1003 veriT_vr1005 1 ⟶ ¬ CSTATE veriT_vr1004 veriT_vr1005 1))) ∨ (∀veriT_vr1003 veriT_vr1004 veriT_vr1005. ¬ C_msg_not veriT_vr1003 veriT_vr1004 veriT_vr1005 ∨ ¬ nextReqIs veriT_vr1003 veriT_vr1005 1 ∨ ¬ CSTATE veriT_vr1004 veriT_vr1005 1)"
    by auto
  then have "(∃r m t. C_msg_not r m t ≠ ((nextReqIs r t 0 ⟶ ¬ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ ¬ CSTATE m t 1))) ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f22 f23 f24 by metis
  then have f25: "¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by (metis C_msg_not_def)
  have "C_msg_not RdShared Invalid T ∧ nextReqIs RdShared T 1 ∧ CSTATE Invalid T 1 ∨ ¬ C_msg_not RdShared Invalid T ∨ ¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    by auto
  then have "¬ nextReqIs RdShared T 1 ∨ ¬ CSTATE Invalid T 1"
    using f25 by (metis i26)
  moreover
  { assume "¬ CSTATE Invalid T 1"
    then have "CSTATE Invalid T 0 ∨ (¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      using f10 by metis
    moreover
    { assume aaa1: "(¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1) ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1"
      have "lastSharer T ∧ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE Invalid T 1 ∨ ¬ lastSharer T ∨ CSTATE Invalid T 0 ∨ CSTATE Invalid T 1"
        by auto
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using aaa1 by metis }
    moreover
    { assume "CSTATE Invalid T 0"
      then have fff1: "(¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0) ∧ CSTATE Invalid T 0"
        using f20 by metis
      have "CSTATE Invalid T 0 ∧ Invalid ≠ SIAC ∧ CSTATE SIAC T 0 ∨ ¬ CSTATE Invalid T 0 ∨ Invalid = SIAC ∨ ¬ CSTATE SIAC T 0"
        by auto
      then have "¬ CSTATE SIAC T 0"
        using fff1 by (metis MESI_State.distinct(179))
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        by (metis i946) }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have ff1: "(¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
      using f21 by metis
    have "nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ nextReqIs RdShared T 1"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using ff1 by metis
    have "(¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have ff3: "¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using ff2 by metis
    have "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using ff3 by metis
    then have "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
      have "(HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
        by auto
      then have "nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using aaa1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using f11 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "nextSnpRespIs RspIFwdM T 0"
        using fff2 by metis
      then have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        by (metis i950) }
    ultimately have "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  ultimately have f26: "¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
  have f27: "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)) = (HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  have f28: "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)) ≠ ((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ ((¬ HSTATE SharedM T ∨ ¬ nextReqIs CleanEvictNoData T 0 ∨ ¬ lastSharer T ∨ ¬ GTS T ((0 + 1) mod 2)) ∨ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ (HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by auto
  have "((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)) = ((HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2)) ∧ ((HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  then show "HSTATE SharedM T ∧ nextReqIs CleanEvictNoData T 0 ∧ lastSharer T ∧ GTS T ((0 + 1) mod 2) ⟶ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE ModifiedM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= InvalidM] [ 0 +=reqresp GO Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    using f26 f27 f28 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(141) HSTATE_equals_sHost bits_one_mod_two_eq_one comm_monoid_add_class.add_0
    hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have ff3: "SAD ≠ SD"
      using HOST_State.distinct(141) by moura
    have ff4: "1 mod 2 = 1"
      using bits_one_mod_two_eq_one by moura
    have "∀n. 0 + n = n"
      using comm_monoid_add_class.add_0 by moura
    then have "¬ HSTATE SD ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ])"
      using ff4 ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 1 ∨ ¬ HSTATE SD ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 1) ∧ (¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 0 ∨ ¬ HSTATE SD ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 0) ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdShared T 0"
    by moura
  then show "HSTATE ModifiedM T ∧ nextReqIs RdShared T 0 ⟶ (HSTATE SD ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 0) ∧ (HSTATE SD ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpData nextReqID T 0] [ 5 sHost= SAD] [ 0 -=req ]) 1)"
    by metis
next 
verit found a proof... 
verit: Try this: apply (smt (verit) CSTATE_different1 CSTATE_general_rule_3_0 MESI_State.distinct(27) i595)

Isar proof:
proof -
  have f1: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ CSTATE Modified T 0"
    by auto
  have f2: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 = CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  have f3: "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∧ ¬ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    by auto
  have f4: "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. ¬ CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∨ CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  then have "(∃m t h r ma ta n. CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n ≠ CSTATE m t n) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    using f1 f2 f3 by metis
  then have f5: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
    by (metis CSTATE_general_rule_3_0)
  have f6: "((∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∨ CSTATE MIA T 0 ∧ MIA ≠ Modified ∧ CSTATE Modified T 0"
    by auto
  have f7: "((∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∨ (∀veriT_vr397 veriT_vr398 veriT_vr399. (¬ CSTATE veriT_vr397 veriT_vr398 0 ∨ veriT_vr397 = veriT_vr399) ∨ ¬ CSTATE veriT_vr399 veriT_vr398 0)"
    by auto
  have f8: "(∃veriT_vr397 veriT_vr398 veriT_vr399. CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399 ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    by auto
  have "(∃veriT_vr397 veriT_vr398 veriT_vr399. (CSTATE veriT_vr397 veriT_vr398 0 ∧ veriT_vr397 ≠ veriT_vr399) ∧ CSTATE veriT_vr399 veriT_vr398 0) ∨ (∀veriT_vr397 veriT_vr398 veriT_vr399. ¬ CSTATE veriT_vr397 veriT_vr398 0 ∨ veriT_vr397 = veriT_vr399 ∨ ¬ CSTATE veriT_vr399 veriT_vr398 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    using f6 f7 f8 by metis
  then have f9: "¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
    by (metis CSTATE_different1)
  have f10: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f11: "((∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ≠ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 = CSTATE veriT_vr451 veriT_vr452 veriT_vr457)"
    by auto
  have "(∃veriT_vr451 veriT_vr452 veriT_vr453 veriT_vr454 veriT_vr455 veriT_vr456 veriT_vr457. CSTATE veriT_vr451 ( veriT_vr452 [ 5 sHost= veriT_vr453] [ 0 +=reqresp veriT_vr454 veriT_vr455 veriT_vr456] [ 0 -=req ]) veriT_vr457 ∧ ¬ CSTATE veriT_vr451 veriT_vr452 veriT_vr457) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "(∃m t h r ma ta n. CSTATE m ( t [ 5 sHost= h] [ 0 +=reqresp r ma ta] [ 0 -=req ]) n ≠ CSTATE m t n) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    using f10 f11 f4 by metis
  then have f12: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_general_rule_3_0)
  have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ CSTATE Modified T 1"
    using f12 by metis
  moreover
  { assume "CSTATE Modified T 1"
    then have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by (metis i595) }
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
    have "(HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
      by auto
    then have "(¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1"
      using aa1 by metis
    then have "(HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis
    moreover
    { assume aaa1: "(HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
      have "(HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        by auto
      then have fff2: "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0"
        using aaa1 by metis
      have "CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∧ ¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ CSTATE Modified T 0"
        by auto
      then have "CSTATE Modified T 0"
        using fff2 f5 by metis
      then have fff3: "(¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0) ∧ CSTATE Modified T 0"
        using f9 by metis
      have "CSTATE MIA T 0 ∧ MIA ≠ Modified ∧ CSTATE Modified T 0 ∨ ¬ CSTATE MIA T 0 ∨ MIA = Modified ∨ ¬ CSTATE Modified T 0"
        by auto
      then have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
        using fff3 by (metis MESI_State.distinct(27)) }
    ultimately have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
      by metis }
  ultimately have f13: "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
  have f14: "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = (HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0 ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  have f15: "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ≠ ((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ ((¬ HSTATE ModifiedM T ∨ ¬ nextReqIs DirtyEvict T 0 ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0) ∨ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ ((¬ HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∨ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) ∨ (HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by auto
  have "((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)) = ((HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0) ∧ ((HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1))"
    by auto
  then show "HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0 ⟶ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE SAD ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    using f13 f14 f15 by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant2
    CSTATE_HostShared_CleanEvictNoData_Last_otherside_invariant3 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def
    GHOST_REQ_def GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def
    IMAD_ROW_def IMAI_ROW_def IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def
    ISD_ROW_def ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def
    MEM_MD_ROW_def MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def
    MIAD_ROW_def MIA_ROW_def MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def
    RSPIHITSE_COL_def RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def
    SNPINV_COL_def STORE_COL_def i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
135.542s elapsed time, 59.531s cpu time, 5.766s GC time 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_X_rd_invariant1 CSTATE_general_rule_8_0 CSTATE_various_forms2
    CSTATE_various_forms4 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def GOI_COL_def
    GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def IIA_ROW_def IMAD_ROW_def IMAI_ROW_def
    IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def i107 mod_add_self1 mod_by_0 numeral_One one_mod_two_eq_one) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModified_DirtyEvict_otherside_invariant2
    CSTATE_HostModified_DirtyEvict_otherside_invariant3 C_not_C_msg_def i49 i595 nextGOPending_HostModifiedDirtyEvict
    numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModified_DirtyEvict_otherside_invariant2 i595 minus_req_nextReqIs_False_swmrp_rule_1_0
    numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostsModifiedRdOwn_otherside_invariant3 CSTATE_X_rd_invariant1 i74 i75 mod_add_self1
    mod_by_0 not_mod_2_eq_0_eq_1 numeral_One one_mod_two_eq_one) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModifiedRdShared_otherside_invariant3 CSTATE_X_rd_invariant1
    CSTATE_inequality_invariant C_msg_state_def C_not_C_msg_def i47 i49 i72 mod_add_self1 mod_by_0
    nextGOPending_General_rule_19_1 nextGOPending_HostModifiedRdShared numeral_One one_mod_two_eq_one) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModifiedRdShared_otherside_invariant2 CSTATE_inequality_invariant C_msg_state_def i47
    i72 minus_req_nextReqIs_False_swmrp_rule_3_0 nextReqIs_otherside_rule_4_0 numeral_One one_mod_two_eq_one
    plus_nat.add_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: starting 
SH Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModified_DirtyEvict_otherside_invariant2 i595 minus_req_nextReqIs_False_swmrp_rule_1_0
    numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModifiedRdShared_otherside_invariant3 CSTATE_inequality_invariant C_msg_state_def i47
    i72 minus_req_nextReqIs_False_swmrp_rule_3_0 nextReqIs_otherside_rule_4_0 numeral_One one_mod_two_eq_one
    plus_nat.add_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(35) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ SB"
      using HOST_State.distinct(35) by moura
    then have "¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE SharedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE IIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
    by moura
  then show "HSTATE SharedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE IIA T 0 ⟶ (HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∧ (HSTATE ModifiedM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 5 sHost= SB] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostModifiedRdShared_otherside_invariant2 CSTATE_inequality_invariant C_msg_state_def i47
    i72 minus_req_nextReqIs_False_swmrp_rule_3_0 nextReqIs_otherside_rule_4_0 numeral_One one_mod_two_eq_one
    plus_nat.add_0) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(13) HSTATE_equals_sHost HSTATE_invariant_reqresp hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n r m ta. HSTATE h t ∨ ¬ HSTATE h (t [ n +=reqresp r m ta])"
      using HSTATE_invariant_reqresp by moura
    have ff3: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have "ModifiedM ≠ ID"
      using HOST_State.distinct(13) by moura
    then have "¬ HSTATE ModifiedM ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ])"
      using ff3 ff2 ff1 by metis }
  then have "(¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0) ∨ ¬ HSTATE ModifiedM T ∨ ¬ GTS T ((0 + 1) mod 2) ∨ ¬ CSTATE MIA T 0 ∨ ¬ nextReqIs DirtyEvict T 0"
    by moura
  then show "HSTATE ModifiedM T ∧ nextReqIs DirtyEvict T 0 ∧ GTS T ((0 + 1) mod 2) ∧ CSTATE MIA T 0 ⟶ (HSTATE ModifiedM ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ 5 sHost= ID] [ 0 +=reqresp GO_WritePull Invalid nextReqID T 0] [ 0 -=req ]) 0)"
    by metis
next 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant2
    CSTATE_HostShared_CleanEvict_NotLastData_otherside_invariant3 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
156.075s elapsed time, 61.156s cpu time, 4.781s GC time 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
Done 
SH Future: starting 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: result = timeout 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostsModifiedRdOwn_otherside_invariant3 i494 i823 mod_add_self1 mod_by_0 numeral_One
    one_mod_two_eq_one) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
METHOD Future: starting 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: result = timeout 
SH Future: starting 
METHOD Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_HostsModifiedRdOwn_otherside_invariant3 i823 minus_req_nextReqIs_False_swmrp_rule_3_0
    mod_add_self1 mod_by_0 numeral_One one_mod_two_eq_one) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
No proof found 
SH Future: sledgehammer returned: fail 
SH Future: starting 
Sledgehammering... 
=== EXIT my_hammer_or_method_away with result: fail === 
230.758s elapsed time, 77.750s cpu time, 5.141s GC time 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(15) HSTATE_equals_sHost bits_one_mod_two_eq_one comm_monoid_add_class.add_0
    hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have ff3: "ModifiedM ≠ MAD"
      using HOST_State.distinct(15) by moura
    have ff4: "1 mod 2 = 1"
      using bits_one_mod_two_eq_one by moura
    have "∀n. 0 + n = n"
      using comm_monoid_add_class.add_0 by moura
    then have "¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ])"
      using ff4 ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1) ∧ (¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0) ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdOwn T 0"
    by moura
  then show "HSTATE ModifiedM T ∧ nextReqIs RdOwn T 0 ⟶ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ⟶ ¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0) ∧ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ⟶ ¬ CSTATE Modified ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1)"
    by metis
next 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
No proof found 
SH Future: sledgehammer returned: fail 
=== EXIT my_hammer_or_method_away with result: fail === 
266.536s elapsed time, 81.703s cpu time, 8.188s GC time 
e found a proof... 
e: Try this:
  apply (metis DIRTYEVICT_COL_def HOST_DEVNUM_def HOST_State.distinct(15) HSTATE_equals_sHost assms
    hstate_invariants(13) minus_req_nextReqIs_False_swmrp_rule_3_0 one_mod_two_eq_one plus_nat.add_0)

Isar proof:
proof -
  obtain bb :: bool where
    f1: "bb = (¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ∨ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1)"
    by moura
  obtain bba :: bool where
    f2: "bba = (¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ∨ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0)"
    by moura
  have f3: "1 mod HOST_DEVNUM = 1"
    by (metis HOST_DEVNUM_def one_mod_two_eq_one)
  have f4: "∀t r h s ta. ¬ nextReqIs r ( ta [ 1 +=snp s t] [ DIRTYEVICT_COL sHost= h] [ 0 -=req ]) 0 ∨ ¬ SWMR_state_machine ta"
    by (metis DIRTYEVICT_COL_def minus_req_nextReqIs_False_swmrp_rule_3_0)
  have "nextReqIs RdShared ( T [ 1 +=snp SnpInv nextReqID T 0] [ DIRTYEVICT_COL sHost= MAD] [ 0 -=req ]) 0 ∨ bb"
    using f3 f1 by (metis DIRTYEVICT_COL_def HOST_DEVNUM_def plus_nat.add_0)
  then have f5: bb
    using f4 by (metis assms)
  have f6: "HSTATE ModifiedM ( T [ 1 +=snp SnpInv nextReqID T 0] [ DIRTYEVICT_COL sHost= MAD] [ 0 -=req ]) ∨ bba"
    using f3 f2 by (metis DIRTYEVICT_COL_def HOST_DEVNUM_def plus_nat.add_0)
  have "¬ HSTATE ModifiedM ( T [ 1 +=snp SnpInv nextReqID T 0] [ DIRTYEVICT_COL sHost= MAD])"
    by (metis HOST_State.distinct(15) HSTATE_equals_sHost)
  then have "¬ HSTATE ModifiedM ( T [ 1 +=snp SnpInv nextReqID T 0] [ DIRTYEVICT_COL sHost= MAD] [ 0 -=req ])"
    by (metis hstate_invariants(13))
  then have bba
    using f6 by metis
  then have "¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdOwn T 0 ∨ bb ∧ bba"
    using f5 by metis
  then show "HSTATE ModifiedM T ∧ nextReqIs RdOwn T 0 ⟶ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0)"
    using f2 f1 by metis
next 
METHOD Future: starting 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(15) HSTATE_equals_sHost bits_one_mod_two_eq_one comm_monoid_add_class.add_0
    hstate_invariants(13))

Isar proof:
proof -
  { have ff1: "∀h ha t n. ha = h ∨ ¬ HSTATE ha ( t [ n sHost= h])"
      using HSTATE_equals_sHost by moura
    have ff2: "∀h t n. HSTATE h t ∨ ¬ HSTATE h (t [ n -=req ])"
      using hstate_invariants(13) by moura
    have ff3: "1 mod 2 = 1"
      using bits_one_mod_two_eq_one by moura
    have ff4: "∀n. 0 + n = n"
      using comm_monoid_add_class.add_0 by moura
    have "ModifiedM ≠ MAD"
      using HOST_State.distinct(15) by moura
    then have "¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ])"
      using ff4 ff3 ff2 ff1 by metis }
  then have "(¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ∨ ¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1) ∧ (¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ∨ ¬ HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∨ ¬ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0) ∨ ¬ HSTATE ModifiedM T ∨ ¬ nextReqIs RdOwn T 0"
    by moura
  then show "HSTATE ModifiedM T ∧ nextReqIs RdOwn T 0 ⟶ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0 ⟶ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1) ∧ (HSTATE ModifiedM ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) ∧ nextReqIs RdShared ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 1 ⟶ ¬ nextDTHDataPending ( T [ (0 + 1) mod 2 +=snp SnpInv nextReqID T 0] [ 5 sHost= MAD] [ 0 -=req ]) 0)"
    by metis
next 
METHOD Future: result = timeout 
SH Future: starting 
Sledgehammering... 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
METHOD Future: starting 
SH Future: starting 
Sledgehammering... 
METHOD Future: result = timeout 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CACHE_TRANS_def CLEANEVICTNODATA_COL_def CLEANEVICTNODATA_NOLAST_COL_def CLEANEVICT_LAST_COL_def
    CLEANEVICT_NOLAST_COL_def CSTATE_various_forms5 DATA_COL_def DIRTYEVICT_COL_def EVICT_COL_def GHOST_REQ_def
    GOI_COL_def GOWRITEPULLDROP_COL_def GOWRITEPULL_COL_def GO_COL_def HOST_DEVNUM_def
    HostInvalidRdOwn'_devcache_invariant1 HostInvalidRdOwn'_devcache_invariant2 IIA_ROW_def IMAD_ROW_def IMAI_ROW_def
    IMASI_ROW_def IMAS_ROW_def IMA_ROW_def IMD_ROW_def ISAD_ROW_def ISA_ROW_def ISDI_ROW_def ISD_ROW_def
    ISSUE_EVENT_ROW_def MEM_DATA_COL_def MEM_E_ROW_def MEM_ID_ROW_def MEM_MAD_ROW_def MEM_MA_ROW_def MEM_MD_ROW_def
    MEM_M_ROW_def MEM_RDO_COL_def MEM_SAD_ROW_def MEM_SA_ROW_def MEM_SD_ROW_def MEM_S_ROW_def MIAD_ROW_def MIA_ROW_def
    MID_ROW_def M_ROW_def OFFSET_def RSPIFWDM_COL_def RSPIHITI_COL_def RSPIHITSELAST_COL_def RSPIHITSE_COL_def
    RSPSFWDM_COL_def SHARED_ROW_def SIA_ROW_def SMAD_ROW_def SMAS_ROW_def SMA_ROW_def SNPD_COL_def SNPINV_COL_def
    STORE_COL_def SWMR_def i0 i22 numeral_One) 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 === 
Done 
SH Future: sledgehammer returned: success 
SH won -> cancel METHOD 
=== EXIT my_hammer_or_method_away with result: success === 
=== ENTER my_hammer_or_method_away for subgoal 1 ===
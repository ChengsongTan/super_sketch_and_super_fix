Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
Sledgehammering... 
user method didnt solve goal 
Sledgehammering... 
user method successfully solved goal 
user method successfully solved goal 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_various_forms1 SWMR_def devcache1_ISDIData_invariant_aux1 devcache2_copy_perform1_invariant
    i0) 
Done 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,187)) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(125,35) SharedStore'_CSTATE_sameside) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(137,47) SharedSnpInv'_CSTATE_invariant5) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11) i23) 
Done 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(3,97)) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(15) i23) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11,143) i106) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i23 remove_instr_HSTATE) 
Done 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(11,143,15) i106) 
Done 
Sledgehammering... 
No proof found 
now heaviest utility invoked
 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,11,3) i106
    remove_instr_HSTATE) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,261)) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,3)) 
Done 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
No proof found 
now heaviest utility invoked
 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) 
Done 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) InvalidStore'_CSTATE_otherside InvalidStore'_HSTATE MESI_State.distinct(15)
    SMADSnpInv_C_msg_not_half i22) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(101,11,35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i106) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) InvalidLoad'_CSTATE_otherside InvalidLoad'_HSTATE MESI_State.distinct(11)
    SMADSnpInv_C_msg_not_half i22) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_not_def InvalidStore'_CSTATE_sameside InvalidStore'_nextReqIs_invariant1
    MESI_State.distinct(15) i26) 
Done 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(281,35) SharedStore'_CSTATE_sameside) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_state_def InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE InvalidLoad'_nextReqIs_otherside i22 i47) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 C_msg_not_def C_msg_state_def InvalidStore'_CSTATE_otherside
    InvalidStore'_nextReqIs_invariant1 MESI_State.distinct(11) i26 i47) 
Done 
Sledgehammering... 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
No proof found 
now heaviest utility invoked
 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(35) SMADSnpInv_C_msg_not_half SharedStore'_CSTATE_otherside
    SharedStore'_HSTATE i22) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant C_msg_state_def InvalidLoad'_CSTATE_otherside
    InvalidLoad'_nextReqIs_otherside MESI_State.distinct(11) SMADSnpInv_C_msg_not_half i47) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj2 MESI_State.distinct(35) SharedStore'_CSTATE_otherside SharedStore'_CSTATE_sameside
    SharedStore'_HSTATE i22) 
Done 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different2 C_msg_state_def C_state_not_def InvalidStore'_nextReqIs_invariant_not_RdOwn
    InvalidX_HSTATE1 MESI_State.distinct(263,283) ReqType.distinct(1) i101 i31 i417 i47 i488 i68
    nextHTDDataPending_various_forms2 nextReqIs_not_various_forms1 nextReqIs_otherside_rule_2_0
    reqs2_empty_not_nextReqIs_general_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 = HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]))"
    by auto
  have f3: "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∧ ¬ HSTATE veriT_vr242 veriT_vr243) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. ¬ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∨ HSTATE veriT_vr242 veriT_vr243)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 = nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25)"
    by auto
  have f7: "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∧ ¬ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ ¬ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25)"
    by auto
  then have f8: "(∃r t n. RdOwn ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) n) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(1))
  have f11: "RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis InvalidStore'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ [] = reqs1 T ∧ nextReqIs RdShared T 0"
    by auto
  have f13: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  have f14: "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  then have f15: "[] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    using f12 f13 f14 by (metis nextReqIs_not_various_forms1)
  have f16: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f17: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 = nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  have f18: "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∧ ¬ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. ¬ nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∨ nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  then have "(∃r t ra m. nextReqIs r ( t [ 0 +=rdreq ra] [ 0 s= m]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    using f16 f17 f18 by metis
  then have f19: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_otherside_rule_2_0)
  have f20: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1"
    by auto
  have f21: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 = ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1)))"
    by auto
  have f22: "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∧ CSTATE veriT_vr507 veriT_vr509 1 ∧ nextReqIs RdShared veriT_vr509 1) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. ¬ C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∨ ¬ CSTATE veriT_vr507 veriT_vr509 1 ∨ ¬ nextReqIs RdShared veriT_vr509 1)"
    by auto
  then have f23: "(∃m r t. C_state_not m r t ≠ ((CSTATE m t 0 ⟶ ¬ nextReqIs RdShared t 0) ∧ (CSTATE m t 1 ⟶ ¬ nextReqIs RdShared t 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f20 f21 f22 by metis
  have f24: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1"
    by auto
  have f25: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 = ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1)))"
    by auto
  have f26: "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∧ nextReqIs veriT_vr501 veriT_vr503 1 ∧ ¬ CSTATE veriT_vr502 veriT_vr503 1) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    by auto
  have "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. ¬ C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∨ ¬ nextReqIs veriT_vr501 veriT_vr503 1 ∨ CSTATE veriT_vr502 veriT_vr503 1)"
    by auto
  then have f27: "(∃r m t. C_msg_state r m t ≠ ((nextReqIs r t 0 ⟶ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ CSTATE m t 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f24 f25 f26 by metis
  have f28: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ [] = reqs2 T ∧ nextReqIs RdShared T 1"
    by auto
  have f29: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  have f30: "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  then have f31: "[] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    using f28 f29 f30 by (metis reqs2_empty_not_nextReqIs_general_invariant)
  have f32: "¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f23 by (metis C_state_not_def)
  have f33: "¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f27 by (metis C_msg_state_def)
  have f34: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ nextHTDDataPending T 1 ∧ [] = htddatas2 T"
    by auto
  have f35: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ (∀veriT_vr1055. nextHTDDataPending veriT_vr1055 1 = ([] ≠ htddatas2 veriT_vr1055))"
    by auto
  have f36: "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ∧ [] = htddatas2 veriT_vr1055) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by auto
  have "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ (∀veriT_vr1055. ¬ nextHTDDataPending veriT_vr1055 1 ∨ [] ≠ htddatas2 veriT_vr1055)"
    by auto
  then have "(∃t. nextHTDDataPending t 1 ≠ ([] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    using f34 f35 f36 by metis
  then have f37: "¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by (metis nextHTDDataPending_various_forms2)
  have f38: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1"
    by auto
  have f39: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have f40: "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by auto
  have f41: "(∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. ¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185 ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    using f38 f39 f40 by metis
  then have f42: "¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by (metis CSTATE_different2)
  have f43: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1"
    by auto
  have f44: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    using f43 f44 f41 by metis
  then have f45: "¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by (metis CSTATE_different2)
  have "CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "¬ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1"
    using f45 by (metis MESI_State.distinct(283))
  moreover
  { assume aa1: "¬ CSTATE SMA T 1"
    have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
      by auto
    then have "CSTATE IMA T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      using aa1 by metis
    moreover
    { assume aaa1: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
        by auto
      then have fff2: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1"
        using aaa1 by metis
      have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by auto
      then have "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ CSTATE MIA T 1 ∨ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        using fff2 by metis
      moreover
      { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        then have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
          by (metis i417)
        then have "HSTATE ModifiedM T ⟶ (¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          by metis
        moreover
        { assume aaaaa1: "(¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0"
            using aaaaa1 by metis
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
            by auto
          then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
            using fffff2 by metis }
        moreover
        { assume aaaaa1: "¬ HSTATE ModifiedM T"
          have "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            using aaaaa1 f9 by metis
          have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            by auto
          then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
            using fffff2 by metis }
        ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
          by metis }
      moreover
      { assume "CSTATE Modified T 1"
        then have "[] = reqs2 T"
          by (metis i488) }
      moreover
      { assume "CSTATE MIA T 1"
        then have ffff1: "(¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∧ CSTATE MIA T 1"
          using f32 by metis
        have "C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1 ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by (metis i31) }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T ∨ nextHTDDataPending T 1"
        by metis
      moreover
      { assume "nextHTDDataPending T 1"
        then have ffff1: "(¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∧ nextHTDDataPending T 1"
          using f37 by metis
        have "nextHTDDataPending T 1 ∧ [] = htddatas2 T ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
          by auto
        then have "[] ≠ htddatas2 T"
          using ffff1 by metis
        then have "[] = reqs2 T"
          by (metis i101) }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T"
        by metis
      moreover
      { assume "[] = reqs2 T"
        then have ffff1: "([] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∧ [] = reqs2 T"
          using f31 by metis
        have "[] = reqs2 T ∧ nextReqIs RdShared T 1 ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
        by metis }
    moreover
    { assume "CSTATE IMA T 1"
      then have fff1: "(¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∧ CSTATE IMA T 1"
        using f42 by metis
      have "CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
        by auto
      then have "¬ CSTATE ISAD T 1"
        using fff1 by (metis MESI_State.distinct(263)) }
    ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by metis }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have ff1: "(¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∧ ¬ CSTATE ISAD T 1"
      using f33 by metis
    have "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1 ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
      by auto
    then have "¬ nextReqIs RdShared T 1"
      using ff1 by (metis i47) }
  ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have ff1: "(¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
      using f19 by metis
    have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff1 by metis
    have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff2 by metis }
  ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
      using aa1 by metis
    then have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have fff2: "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using aaa1 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using fff2 by metis
      then have "nextReqIs RdShared T 0"
        using f11 f10 by metis
      then have fff3: "([] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∧ nextReqIs RdShared T 0"
        using f15 by metis
      have "[] = reqs1 T ∧ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
        by auto
      then have "[] ≠ reqs1 T"
        using fff3 by metis
      then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
        by (metis i68) }
    ultimately have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis }
  ultimately have f46: "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  have f47: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = (CSTATE Invalid T 0 ∧ nextStore T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  have f48: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ≠ ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ((¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by auto
  have "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  then show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    using f46 f47 f48 by metis
next 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(293,47) SharedSnpInv'_CSTATE_invariant5) 
Done 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f2: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f3: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f4: "dthdatas1 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f5: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f6: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f7: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f8: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f9: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    using f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0)"
    by metis
next 
Sledgehammering... 
Sledgehammering... 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_otherside_rule_10 InvalidX_HSTATE1 MESI_State.distinct(47) SharedSnpInv_C_msg_not_half
    i22)

Isar proof:
proof -
  have f1: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f2: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  have f3: "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  then have f4: "(∃m ma r t. (m ≠ ma ∧ nextReqIs r ( t [ 0 s= m]) 0) ∧ CSTATE ma ( t [ 0 s= m]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T"
    by auto
  have f6: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 = HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]))"
    by auto
  have f7: "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∧ ¬ HSTATE veriT_vr166 veriT_vr167) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    by auto
  have "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. ¬ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∨ HSTATE veriT_vr166 veriT_vr167)"
    by auto
  then have f8: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f5 f6 f7 by metis
  have "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f9: "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by (metis MESI_State.distinct(47))
  have f10: "SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f4 by (metis SharedSnpInv_C_msg_not_half)
  have f11: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f8 by (metis InvalidX_HSTATE1)
  have f12: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f13: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f14: "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f10 f9 f12 f13 by metis
  have f15: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f16: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 = CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1)"
    by auto
  have f17: "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∧ ¬ CSTATE veriT_vr218 veriT_vr219 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. ¬ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∨ CSTATE veriT_vr218 veriT_vr219 1)"
    by auto
  then have "(∃m t r ma. CSTATE m t 1 ≠ CSTATE m ( t [ 0 +=rdreq r] [ 0 s= ma]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    using f15 f16 f17 by metis
  then have f18: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_10)
  have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ CSTATE Modified T 1"
    using f18 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have ff2: "¬ HSTATE SharedM T"
      by (metis i22)
    have "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
      by auto
    then have ff3: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      using ff2 f11 by metis
    have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      by auto
    then have ff4: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff3 by metis
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff4 by metis }
  ultimately have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    by metis
  then have f19: "¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f14 by metis
  have f20: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = (CSTATE Shared T 0 ∧ nextEvict T 0 ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  have f21: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ≠ ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ (CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f19 f20 f21 by metis
next 
Done 
Sledgehammering... 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) i107 remove_instr_HSTATE) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
Sledgehammering... 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
No proof found 
now heaviest utility invoked
 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedStore'_HSTATE i107) 
Done 
Sledgehammering... 
verit found a proof... 
verit: Try this: apply (smt (verit) HSTATE_general_rule_10_0 i23 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have f3: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f4: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. ¬ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∨ CSTATE veriT_vr335 veriT_vr336 veriT_vr337)"
    by auto
  then have f5: "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  have f6: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T"
    by auto
  have f7: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ (∀veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) = HSTATE veriT_vr224 veriT_vr225)"
    by auto
  have f8: "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∧ ¬ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ (∀veriT_vr224 veriT_vr225. ¬ HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∨ HSTATE veriT_vr224 veriT_vr225)"
    by auto
  then have f9: "(∃h t. HSTATE h (t [ -=i 0]) ≠ HSTATE h t) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f6 f7 f8 by metis
  have f10: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f5 by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f11: "¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f9 by (metis HSTATE_general_rule_10_0)
  have f12: "HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have f13: "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f14: "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
    by auto
  have f15: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
    by auto
  have f16: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])"
    by auto
  have "(¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
    by auto
  then have f17: "CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1"
    using f11 f12 f10 f13 f14 f15 f16 by (metis i23)
  have f18: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0) ∨ CSTATE Modified (T [ -=i 0]) 0 ∧ ¬ CSTATE Modified T 0"
    by auto
  have f19: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by auto
  then have "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    using f18 f19 f4 by metis
  then have f20: "¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have "CSTATE Modified (T [ -=i 0]) 0 ∧ ¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by auto
  then have "CSTATE Modified (T [ -=i 0]) 0 ⟶ CSTATE Modified T 0"
    using f20 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified (T [ -=i 0]) 0"
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE Modified (T [ -=i 0]) 0"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 0"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have "¬ HSTATE SD T"
      by (metis i23)
    then have ff2: "¬ HSTATE SD (T [ -=i 0])"
      using f11 f12 by metis
    have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
      by auto
    then have ff3: "¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])"
      using ff2 by metis
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff3 by metis }
  ultimately have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
    by metis
  then have f21: "¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f17 by metis
  have f22: "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ (CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f21 f22 by metis
next 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
Sledgehammering... 
Done 
197.126s elapsed time, 42.375s cpu time, 0.875s GC time 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) 
Done 
197.179s elapsed time, 42.016s cpu time, 0.875s GC time 
Sledgehammering... 
Sledgehammering... 
No proof found 
now heaviest utility invoked
 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside InvalidStore'_HSTATE
    InvalidStore'_nextReqIs_otherside i23 i824) 
Done 
230.891s elapsed time, 49.969s cpu time, 1.109s GC time 
No proof found 
Sledgehammering... 
now heaviest utility invoked
 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) HSTATE_X_Evict_invariant1 i107) 
Done 
user method successfully solved goal 
Sledgehammering... 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_disj1 InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside InvalidLoad'_HSTATE
    MESI_State.distinct(11) i23) 
Done 
238.059s elapsed time, 61.469s cpu time, 1.344s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(15,359,47) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant4)

Isar proof:
proof -
  have f1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f3: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f4: "Modified ≠ IMAD"
    using MESI_State.distinct(15) by moura
  have f5: "Modified ≠ SIAC"
    using MESI_State.distinct(47) by moura
  have "IMAD ≠ SIAC"
    using MESI_State.distinct(359) by moura
  then have "¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    using f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0)"
    by metis
next 
Done 
251.474s elapsed time, 60.719s cpu time, 1.344s GC time 
zipperposition found a proof... 
zipperposition: Try this: apply (metis CSTATE_disj1 MESI_State.distinct(215,43) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ SIA"
      using MESI_State.distinct(43) by moura
    have "ISD ≠ SIA"
      using MESI_State.distinct(215) by moura
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by moura
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next 
Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_HSTATE i23) 
Done 
Sledgehammering... 
Sledgehammering... 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside
    ModifiedEvict'_CSTATE_sameside i72) 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(5) SMADSnpInv_CSTATE SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv_HSTATE SharedSnpInv_nextSnoopIs_otherside i23 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X4. zza X1 X4 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f4: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := Some ma⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using SMADSnpInv_CSTATE by moura
  then have f5: "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  then have f8: "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    using f7 f6 f5 f4 f3 by metis
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f9 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Sledgehammering... 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(43)
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i23)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  then have "HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) C_not_C_msg_def ModifiedEvict'_CSTATE_otherside i49 i72 nextGOPending_DeviceModifiedEvict) 
Done 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_disj1 CSTATE_inequality_invariant CSTATE_starting_transaction_otherside_invariant1
    MESI_State.distinct(101,11,43) SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i106)

Isar proof:
proof -
  have f1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f7: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f8: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f9: "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  have "Shared ≠ ISAD"
    using MESI_State.distinct(101) by moura
  then have "HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ (∃m. m ≠ Shared ∧ CSTATE m T 0)"
    using f9 f8 f7 f6 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume aa1: "∃m. m ≠ Shared ∧ CSTATE m T 0"
    { have "¬ CSTATE Shared T 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_HSTATE i22) 
Done 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(149) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv
    SharedSnpInv_nextSnoopIs_otherside i384 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X4. zz X1 X4 = Some X1"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X6. zza B_X X6 = B_X"
    by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f4: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  have f5: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f6: "SAD ≠ MA"
    using HOST_State.distinct(149) by moura
  have f7: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f2 f4 by metis
  have "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "HSTATE SAD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ (∃h. MA ≠ h ∧ HSTATE h T)"
    using f7 f2 f1 f6 by metis
  moreover
  { assume "∃h. MA ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE MA T"
      using f3 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f5 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i22 i72) 
Done 
Sledgehammering... 
user method successfully solved goal 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(43) SMADSnpInv_C_msg_not_half SharedEvictData'_CSTATE_otherside
    SharedEvictData'_HSTATE i22) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside SMADSnpInv_C_msg_not_half i72) 
Done 
vampire found a proof... 
vampire: Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i22)

Isar proof:
proof -
  have f1: "∀m ma t. ¬ CSTATE m ( t [ 0 s= ma]) 0 ∨ m = ma"
    by (metis CSTATE_inequality_invariant SharedSnpInv'_CSTATE_invariant5)
  have "HSTATE SharedM T ⟶ HSTATE SharedM T"
    by metis
  moreover
  { assume "¬ HSTATE SharedM T"
    then have "¬ HSTATE SharedM (T [ 0 +=rdreq CleanEvict])"
      by (metis hstate_invariants(4))
    then have "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
      by (metis hstate_invariants(24)) }
  moreover
  { assume "HSTATE SharedM T"
    then have "¬ CSTATE Modified T 1"
      by (metis i22)
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1"
      by (metis SharedEvictData'_CSTATE_otherside)
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ Modified ≠ SIA"
      by (metis MESI_State.distinct(43))
    then have "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
      using f1 by metis }
  ultimately show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis CSTATE_inequality_invariant CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(43)
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i22)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SharedM T"
    using i22 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  then have "HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next 
Done 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i22) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(143,5) SharedSnpInv'_CSTATE_invariant5) 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 i73 i897 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f3: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f4: "dthdatas1 T = [] ∨ ¬ CSTATE Modified T 0"
    using i897 by moura
  have f5: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f6: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f7: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f8: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f9: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f10: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ∧ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    using f10 f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
next 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
Sledgehammering... 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) SharedEvictData'_HSTATE i107) 
Done 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i23) 
Done 
Sledgehammering... 
91.204s elapsed time, 36.766s cpu time, 0.703s GC time 
Done 
verit found a proof... 
verit: Try this:
  apply (smt (verit) CSTATE_different1 InvalidX_HSTATE1 MESI_State.distinct(11)
    ModifiedEvict'_nextReqIs_invariant_not_RdOwn ReqType.distinct(11) i339 i417 i419 i456 i463 i487 i594 i72 i841
    nextReqIs_nonempty_reqs1 nextSnpRespIs_general_rule_9_0 nextStore_nextEvict_exclusive)

Isar proof:
proof -
  have f1: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 = HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]))"
    by auto
  have f3: "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∧ ¬ HSTATE veriT_vr262 veriT_vr263) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. ¬ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∨ HSTATE veriT_vr262 veriT_vr263)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 = nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23)"
    by auto
  have f7: "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∧ ¬ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ ¬ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23)"
    by auto
  then have f8: "(∃r t n. DirtyEvict ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) n) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(11))
  have f11: "DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis ModifiedEvict'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f13: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  have f14: "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  then have f15: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f12 f13 f14 by (metis nextReqIs_nonempty_reqs1)
  have f16: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f17: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 = nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  have f18: "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∧ ¬ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∨ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  then have "(∃s t r m n. nextSnpRespIs s ( t [ 0 +=rdreq r] [ 0 s= m]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f16 f17 f18 by metis
  then have f19: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_9_0)
  have f20: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ nextEvict T 0 ∧ nextStore T 0"
    by auto
  have f21: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  have f22: "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    by auto
  have "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  then have f23: "¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    using f20 f21 f22 by (metis nextStore_nextEvict_exclusive)
  have f24: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f25: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. (¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199) ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  have f26: "(∃veriT_vr197 veriT_vr198 veriT_vr199. CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199 ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. ¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199 ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f24 f25 f26 by metis
  then have f27: "¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f27 by (metis MESI_State.distinct(11))
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0"
    have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0"
      by auto
    then have "CSTATE IMAD T 0 ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE IIA T 0"
      using aa1 by metis
    moreover
    { assume aaa1: "CSTATE IIA T 0"
      have "CSTATE IIA T 0 ∧ HSTATE ModifiedM T ∨ ¬ CSTATE IIA T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i419) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    moreover
    { assume aaa1: "CSTATE Invalid T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume aaa1: "CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE ISDI T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      then have fff1: "¬ nextSnpRespIs RspIFwdM T 0 ∧ ¬ nextSnpRespIs RspIHitSE T 0"
        by (metis i456)
      have "(nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIHitSE T 0) ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "¬ nextSnpRespIs RspIFwdM T 0"
        using fff1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
        using f19 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff3: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    moreover
    { assume "CSTATE IMAD T 0"
      then have "nextStore T 0"
        by (metis i339)
      then have fff1: "(¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∧ nextStore T 0"
        using f23 by metis
      have "nextEvict T 0 ∧ nextStore T 0 ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
        by auto
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        using fff1 by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      by metis
    moreover
    { assume aaa1: "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ (CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i417) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      by metis
    moreover
    { assume "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      then have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        by metis
      moreover
      { assume aaaa1: "(CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by auto
        then have "CSTATE MIA T 1 ∨ CSTATE Modified T 1"
          using aaaa1 by metis
        moreover
        { assume "CSTATE Modified T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i72) }
        moreover
        { assume "CSTATE MIA T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i594) }
        ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by metis }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1"
        have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have ffff2: "CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          using aaaa1 by metis
        have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have "CSTATE SMA T 1 ∨ CSTATE IMA T 1"
          using ffff2 by metis
        moreover
        { assume aaaaa1: "CSTATE IMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE IMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        moreover
        { assume aaaaa1: "CSTATE SMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE SMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        ultimately have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
          by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i841) }
      ultimately have "nextHTDDataPending T 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "nextHTDDataPending T 1"
        have "(CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1) ∨ ¬ nextHTDDataPending T 1"
          by auto
        then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE Modified T 0 ∧ ([] = dthdatas2 T ∨ nextSnpRespIs RspSFwdM T 1 ∨ HSTATE SD T)"
          by (metis i463)
        have "(CSTATE Modified T 0 ∨ [] ≠ dthdatas2 T ∧ ¬ nextSnpRespIs RspSFwdM T 1 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 0"
          by auto
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          using ffff2 by metis }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        using aaa1 f9 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        by auto
      then have fff3: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    ultimately have "((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis
    moreover
    { assume "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      then have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have ffff2: "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using aaaa1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have "nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using ffff2 by metis
        then have "nextReqIs RdShared T 0"
          using f11 f10 by metis
        then have ffff3: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
          using f15 by metis
        have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
          by auto
        then have "[] ≠ reqs1 T"
          using ffff3 by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i487) }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis }
  ultimately have f28: "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
  have f29: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = (CSTATE Modified T 0 ∧ nextEvict T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  have f30: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f28 f29 f30 by metis
next 
Sledgehammering... 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
Done 
Done 
Sledgehammering... 
cvc5 found a proof... 
cvc5: Try this: apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i23 i72) 
Done 
Sledgehammering... 
Sledgehammering... 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
No proof found 
now heaviest utility invoked
 
Sledgehammering... 
125.102s elapsed time, 36.859s cpu time, 0.625s GC time 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
Done 
Sledgehammering... 
Done 
Sledgehammering... 
Done 
spass found a proof... 
spass: Try this: apply (metis HSTATE_invariant_ModifiedSnpInv i107)

Isar proof:
proof -
  have "HSTATE ModifiedM T ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume "HSTATE ModifiedM T"
    then have "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
      by (metis i107) }
  moreover
  { assume "¬ HSTATE ModifiedM T"
    then have "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
      by (metis HSTATE_invariant_ModifiedSnpInv) }
  ultimately show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next 
Done 
e found a proof... 
e: Try this: apply (metis CSTATE_inequality_invariant MESI_State.distinct(147,5) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option" where
    f1: "∀X1032. zz X1032 = Some (nextSnoop T 0)"
    by moura
  have f2: "∀t m ma. m = ma ∨ ¬ CSTATE m ( t [ 0 s= ma]) 0"
    by (metis CSTATE_inequality_invariant SharedSnpInv'_CSTATE_invariant5)
  then have "¬ CSTATE IMAD ( buffer1_update zz T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    by (metis MESI_State.distinct(147))
  then have "¬ CSTATE Modified ( buffer1_update zz T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ ¬ CSTATE IMAD ( buffer1_update zz T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    using f2 by (metis MESI_State.distinct(5))
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    using f1 by metis
next 
zipperposition found a proof... 
zipperposition: Try this:
  apply (metis HOST_State.distinct(177) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv SharedSnpInv_C_msg_not_half2
    i384 i699 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X5. zz B_X X5 = Some B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X6. zza B_X X6 = B_X"
    by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f4: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  have f5: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f6: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE IB T"
    using i699 by moura
  have f7: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have f8: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f2 f4 by metis
  have "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 f2 f1 f7 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE Shared T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next 
Done 
133.617s elapsed time, 38.312s cpu time, 0.656s GC time 
387.932s elapsed time, 100.906s cpu time, 2.000s GC time 
proof (intro conjI)
  show goal_1: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ SWMR ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
    proof (intro impconjI)
   show goal1_1: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ SWMR ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal1_2: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal1_3: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11) i23) done
   show goal1_4: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE MESI_State.distinct(11,143) i106) done
   show goal1_5: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     sorry (*failed to find proof*)
   show goal1_6: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) InvalidLoad'_CSTATE_otherside InvalidLoad'_HSTATE MESI_State.distinct(11)
    SMADSnpInv_C_msg_not_half i22) done
   show goal1_7: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_state_def InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside
    InvalidLoad'_HSTATE InvalidLoad'_nextReqIs_otherside i22 i47) done
   show goal1_8: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant C_msg_state_def InvalidLoad'_CSTATE_otherside
    InvalidLoad'_nextReqIs_otherside MESI_State.distinct(11) SMADSnpInv_C_msg_not_half i47) done
   show goal1_9: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f2: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f3: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f4: "dthdatas1 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f5: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f6: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f7: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f8: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f9: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    using f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextLoad T 0"
    by metis
  then show "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD]) 0)"
    by metis
next done
   show goal1_10: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     sorry (*failed to find proof*)
   show goal1_11: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     sorry (*failed to find proof*)
   show goal1_12: "CSTATE Invalid T 0 ∧ nextLoad T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdShared] [ 0 s= ISAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj1 InvalidLoad'_CSTATE_otherside InvalidLoad'_CSTATE_sameside InvalidLoad'_HSTATE
    MESI_State.distinct(11) i23) done
qed
  show goal_2: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ SWMR (T [ -=i 0]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) (T [ -=i 0]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) (T [ -=i 0]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) (T [ -=i 0]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD (T [ -=i 0])"
    proof (intro impconjI)
   show goal2_1: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ SWMR (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_various_forms1 SWMR_def devcache1_ISDIData_invariant_aux1 devcache2_copy_perform1_invariant
    i0) done
   show goal2_2: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(3,97)) done
   show goal2_3: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_remove_op i23 remove_instr_HSTATE) done
   show goal2_4: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,11,3) i106
    remove_instr_HSTATE) done
   show goal2_5: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant CSTATE_remove_op MESI_State.distinct(101,3)) done
   show goal2_6: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) done
   show goal2_7: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_remove_op i22 remove_instr_HSTATE) done
   show goal2_8: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) (T [ -=i 0])"
     sorry (*failed to find proof*)
   show goal2_9: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) i107 remove_instr_HSTATE) done
   show goal2_10: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) i107 remove_instr_HSTATE) done
   show goal2_11: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) i107 remove_instr_HSTATE) done
   show goal2_12: "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD (T [ -=i 0])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) HSTATE_general_rule_10_0 i23 nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f2: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have f3: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f4: "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. ¬ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∨ CSTATE veriT_vr335 veriT_vr336 veriT_vr337)"
    by auto
  then have f5: "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f1 f2 f3 by metis
  have f6: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T"
    by auto
  have f7: "((∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T) ∨ (∀veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) = HSTATE veriT_vr224 veriT_vr225)"
    by auto
  have f8: "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∧ ¬ HSTATE veriT_vr224 veriT_vr225) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have "(∃veriT_vr224 veriT_vr225. HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ≠ HSTATE veriT_vr224 veriT_vr225) ∨ (∀veriT_vr224 veriT_vr225. ¬ HSTATE veriT_vr224 (veriT_vr225 [ -=i 0]) ∨ HSTATE veriT_vr224 veriT_vr225)"
    by auto
  then have f9: "(∃h t. HSTATE h (t [ -=i 0]) ≠ HSTATE h t) ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f6 f7 f8 by metis
  have f10: "¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    using f5 by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have f11: "¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    using f9 by (metis HSTATE_general_rule_10_0)
  have f12: "HSTATE SD (T [ -=i 0]) ∧ ¬ HSTATE SD T ∨ ¬ HSTATE SD (T [ -=i 0]) ∨ HSTATE SD T"
    by auto
  have f13: "CSTATE Modified (T [ -=i 0]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified (T [ -=i 0]) 1 ∨ CSTATE Modified T 1"
    by auto
  have f14: "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
    by auto
  have f15: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE Modified (T [ -=i 0]) 1"
    by auto
  have f16: "(CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∨ CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])"
    by auto
  have "(¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
    by auto
  then have f17: "CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1"
    using f11 f12 f10 f13 f14 f15 f16 by (metis i23)
  have f18: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0) ∨ CSTATE Modified (T [ -=i 0]) 0 ∧ ¬ CSTATE Modified T 0"
    by auto
  have f19: "((∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 ≠ CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0) ∨ (∀veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 veriT_vr336 veriT_vr337 = CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337)"
    by auto
  have "(∃veriT_vr335 veriT_vr336 veriT_vr337. CSTATE veriT_vr335 (veriT_vr336 [ -=i 0]) veriT_vr337 ∧ ¬ CSTATE veriT_vr335 veriT_vr336 veriT_vr337) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by auto
  then have "(∃m t n. CSTATE m t n ≠ CSTATE m (t [ -=i 0]) n) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    using f18 f19 f4 by metis
  then have f20: "¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by (metis nextEvict_IIAGO_WritePullDrop_CSTATE_invariant)
  have "CSTATE Modified (T [ -=i 0]) 0 ∧ ¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified (T [ -=i 0]) 0 ∨ CSTATE Modified T 0"
    by auto
  then have "CSTATE Modified (T [ -=i 0]) 0 ⟶ CSTATE Modified T 0"
    using f20 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified (T [ -=i 0]) 0"
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE Modified (T [ -=i 0]) 0"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 0"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 0"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have "¬ HSTATE SD T"
      by (metis i23)
    then have ff2: "¬ HSTATE SD (T [ -=i 0])"
      using f11 f12 by metis
    have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ HSTATE SD (T [ -=i 0])"
      by auto
    then have ff3: "¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])"
      using ff2 by metis
    have "(CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0) ∨ CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])"
      by auto
    then have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
      using ff3 by metis }
  ultimately have "(¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0"
    by metis
  then have f21: "¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0 ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f17 by metis
  have f22: "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ≠ ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextLoad T 0) ∨ ((¬ CSTATE IMAD (T [ -=i 0]) 0 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 0 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ ((¬ CSTATE IMAD (T [ -=i 0]) 1 ∨ ¬ nextReqIs RdOwn (T [ -=i 0]) 1 ∨ ¬ HSTATE SD (T [ -=i 0])) ∨ ¬ CSTATE Modified (T [ -=i 0]) 0)) ∨ (CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0)) = ((CSTATE Shared T 0 ∧ nextLoad T 0) ∧ ((CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 1 ∨ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0])) ∧ CSTATE Modified (T [ -=i 0]) 0))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextLoad T 0 ⟶ (CSTATE IMAD (T [ -=i 0]) 0 ∧ nextReqIs RdOwn (T [ -=i 0]) 0 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 1) ∧ (CSTATE IMAD (T [ -=i 0]) 1 ∧ nextReqIs RdOwn (T [ -=i 0]) 1 ∧ HSTATE SD (T [ -=i 0]) ⟶ ¬ CSTATE Modified (T [ -=i 0]) 0)"
    using f21 f22 by metis
next done
qed
  show goal_3: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ SWMR ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
    proof (intro impconjI)
   show goal3_1: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ SWMR ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal3_2: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,187)) done
   show goal3_3: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(15) i23) done
   show goal3_4: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside
    InvalidStore'_HSTATE MESI_State.distinct(11,143,15) i106) done
   show goal3_5: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant InvalidStore'_CSTATE_sameside MESI_State.distinct(15,261)) done
   show goal3_6: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) InvalidStore'_CSTATE_otherside InvalidStore'_HSTATE MESI_State.distinct(15)
    SMADSnpInv_C_msg_not_half i22) done
   show goal3_7: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj2 C_msg_not_def InvalidStore'_CSTATE_sameside InvalidStore'_nextReqIs_invariant1
    MESI_State.distinct(15) i26) done
   show goal3_8: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj1 C_msg_not_def C_msg_state_def InvalidStore'_CSTATE_otherside
    InvalidStore'_nextReqIs_invariant1 MESI_State.distinct(11) i26 i47) done
   show goal3_9: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_different2 C_msg_state_def C_state_not_def InvalidStore'_nextReqIs_invariant_not_RdOwn
    InvalidX_HSTATE1 MESI_State.distinct(263,283) ReqType.distinct(1) i101 i31 i417 i47 i488 i68
    nextHTDDataPending_various_forms2 nextReqIs_not_various_forms1 nextReqIs_otherside_rule_2_0
    reqs2_empty_not_nextReqIs_general_invariant)

Isar proof:
proof -
  have f1: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 = HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]))"
    by auto
  have f3: "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∧ ¬ HSTATE veriT_vr242 veriT_vr243) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. HSTATE veriT_vr242 veriT_vr243 ≠ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245])) ∨ (∀veriT_vr242 veriT_vr243 veriT_vr244 veriT_vr245. ¬ HSTATE veriT_vr242 ( veriT_vr243 [ 0 +=rdreq veriT_vr244] [ 0 s= veriT_vr245]) ∨ HSTATE veriT_vr242 veriT_vr243)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 = nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25)"
    by auto
  have f7: "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∧ ¬ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr23 veriT_vr24 veriT_vr25. RdOwn ≠ veriT_vr23 ∧ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25 ≠ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25) ∨ (∀veriT_vr23 veriT_vr24 veriT_vr25. RdOwn = veriT_vr23 ∨ ¬ nextReqIs veriT_vr23 ( veriT_vr24 [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) veriT_vr25 ∨ nextReqIs veriT_vr23 veriT_vr24 veriT_vr25)"
    by auto
  then have f8: "(∃r t n. RdOwn ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) n) ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "RdOwn ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(1))
  have f11: "RdOwn = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis InvalidStore'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ [] = reqs1 T ∧ nextReqIs RdShared T 0"
    by auto
  have f13: "((∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  have f14: "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr1048 veriT_vr1049. [] = reqs1 veriT_vr1048 ∧ nextReqIs veriT_vr1049 veriT_vr1048 0) ∨ (∀veriT_vr1048 veriT_vr1049. [] ≠ reqs1 veriT_vr1048 ∨ ¬ nextReqIs veriT_vr1049 veriT_vr1048 0)"
    by auto
  then have f15: "[] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
    using f12 f13 f14 by (metis nextReqIs_not_various_forms1)
  have f16: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1"
    by auto
  have f17: "((∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 = nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  have f18: "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∧ ¬ nextReqIs veriT_vr334 veriT_vr335 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ≠ nextReqIs veriT_vr334 veriT_vr335 1) ∨ (∀veriT_vr334 veriT_vr335 veriT_vr336 veriT_vr337. ¬ nextReqIs veriT_vr334 ( veriT_vr335 [ 0 +=rdreq veriT_vr336] [ 0 s= veriT_vr337]) 1 ∨ nextReqIs veriT_vr334 veriT_vr335 1)"
    by auto
  then have "(∃r t ra m. nextReqIs r ( t [ 0 +=rdreq ra] [ 0 s= m]) 1 ≠ nextReqIs r t 1) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    using f16 f17 f18 by metis
  then have f19: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
    by (metis nextReqIs_otherside_rule_2_0)
  have f20: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1"
    by auto
  have f21: "((∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 = ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1)))"
    by auto
  have f22: "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∧ CSTATE veriT_vr507 veriT_vr509 1 ∧ nextReqIs RdShared veriT_vr509 1) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr507 veriT_vr508 veriT_vr509. C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ≠ ((CSTATE veriT_vr507 veriT_vr509 0 ⟶ ¬ nextReqIs RdShared veriT_vr509 0) ∧ (CSTATE veriT_vr507 veriT_vr509 1 ⟶ ¬ nextReqIs RdShared veriT_vr509 1))) ∨ (∀veriT_vr507 veriT_vr508 veriT_vr509. ¬ C_state_not veriT_vr507 veriT_vr508 veriT_vr509 ∨ ¬ CSTATE veriT_vr507 veriT_vr509 1 ∨ ¬ nextReqIs RdShared veriT_vr509 1)"
    by auto
  then have f23: "(∃m r t. C_state_not m r t ≠ ((CSTATE m t 0 ⟶ ¬ nextReqIs RdShared t 0) ∧ (CSTATE m t 1 ⟶ ¬ nextReqIs RdShared t 1))) ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f20 f21 f22 by metis
  have f24: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1"
    by auto
  have f25: "((∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 = ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1)))"
    by auto
  have f26: "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∧ nextReqIs veriT_vr501 veriT_vr503 1 ∧ ¬ CSTATE veriT_vr502 veriT_vr503 1) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    by auto
  have "(∃veriT_vr501 veriT_vr502 veriT_vr503. C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ≠ ((nextReqIs veriT_vr501 veriT_vr503 0 ⟶ CSTATE veriT_vr502 veriT_vr503 0) ∧ (nextReqIs veriT_vr501 veriT_vr503 1 ⟶ CSTATE veriT_vr502 veriT_vr503 1))) ∨ (∀veriT_vr501 veriT_vr502 veriT_vr503. ¬ C_msg_state veriT_vr501 veriT_vr502 veriT_vr503 ∨ ¬ nextReqIs veriT_vr501 veriT_vr503 1 ∨ CSTATE veriT_vr502 veriT_vr503 1)"
    by auto
  then have f27: "(∃r m t. C_msg_state r m t ≠ ((nextReqIs r t 0 ⟶ CSTATE m t 0) ∧ (nextReqIs r t 1 ⟶ CSTATE m t 1))) ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f24 f25 f26 by metis
  have f28: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ [] = reqs2 T ∧ nextReqIs RdShared T 1"
    by auto
  have f29: "((∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  have f30: "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    by auto
  have "(∃veriT_vr976 veriT_vr977. [] = reqs2 veriT_vr976 ∧ nextReqIs veriT_vr977 veriT_vr976 1) ∨ (∀veriT_vr976 veriT_vr977. [] ≠ reqs2 veriT_vr976 ∨ ¬ nextReqIs veriT_vr977 veriT_vr976 1)"
    by auto
  then have f31: "[] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
    using f28 f29 f30 by (metis reqs2_empty_not_nextReqIs_general_invariant)
  have f32: "¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
    using f23 by (metis C_state_not_def)
  have f33: "¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
    using f27 by (metis C_msg_state_def)
  have f34: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ nextHTDDataPending T 1 ∧ [] = htddatas2 T"
    by auto
  have f35: "((∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∨ (∀veriT_vr1055. nextHTDDataPending veriT_vr1055 1 = ([] ≠ htddatas2 veriT_vr1055))"
    by auto
  have f36: "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ∧ [] = htddatas2 veriT_vr1055) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by auto
  have "(∃veriT_vr1055. nextHTDDataPending veriT_vr1055 1 ≠ ([] ≠ htddatas2 veriT_vr1055)) ∨ (∀veriT_vr1055. ¬ nextHTDDataPending veriT_vr1055 1 ∨ [] ≠ htddatas2 veriT_vr1055)"
    by auto
  then have "(∃t. nextHTDDataPending t 1 ≠ ([] ≠ htddatas2 t)) ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    using f34 f35 f36 by metis
  then have f37: "¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
    by (metis nextHTDDataPending_various_forms2)
  have f38: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1"
    by auto
  have f39: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have f40: "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by auto
  have f41: "(∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. ¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185 ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    using f38 f39 f40 by metis
  then have f42: "¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
    by (metis CSTATE_different2)
  have f43: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1"
    by auto
  have f44: "((∃veriT_vr183 veriT_vr184 veriT_vr185. (CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185) ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1) ∨ (∀veriT_vr183 veriT_vr184 veriT_vr185. (¬ CSTATE veriT_vr183 veriT_vr184 1 ∨ veriT_vr183 = veriT_vr185) ∨ ¬ CSTATE veriT_vr185 veriT_vr184 1)"
    by auto
  have "(∃veriT_vr183 veriT_vr184 veriT_vr185. CSTATE veriT_vr183 veriT_vr184 1 ∧ veriT_vr183 ≠ veriT_vr185 ∧ CSTATE veriT_vr185 veriT_vr184 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "(∃m t ma. (CSTATE m t 1 ∧ m ≠ ma) ∧ CSTATE ma t 1) ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    using f43 f44 f41 by metis
  then have f45: "¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by (metis CSTATE_different2)
  have "CSTATE ISAD T 1 ∧ ISAD ≠ SMA ∧ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = SMA ∨ ¬ CSTATE SMA T 1"
    by auto
  then have "¬ CSTATE SMA T 1 ∨ ¬ CSTATE ISAD T 1"
    using f45 by (metis MESI_State.distinct(283))
  moreover
  { assume aa1: "¬ CSTATE SMA T 1"
    have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
      by auto
    then have "CSTATE IMA T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      using aa1 by metis
    moreover
    { assume aaa1: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1"
      have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
        by auto
      then have fff2: "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1"
        using aaa1 by metis
      have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by auto
      then have "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ CSTATE MIA T 1 ∨ CSTATE Modified T 1 ∨ ¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        using fff2 by metis
      moreover
      { assume "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        then have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
          by (metis i417)
        then have "HSTATE ModifiedM T ⟶ (¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          by metis
        moreover
        { assume aaaaa1: "(¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T) ∧ HSTATE ModifiedM T"
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0"
            using aaaaa1 by metis
          have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
            by auto
          then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
            using fffff2 by metis }
        moreover
        { assume aaaaa1: "¬ HSTATE ModifiedM T"
          have "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ HSTATE ModifiedM T"
            by auto
          then have fffff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            using aaaaa1 f9 by metis
          have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
            by auto
          then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
            using fffff2 by metis }
        ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
          by metis }
      moreover
      { assume "CSTATE Modified T 1"
        then have "[] = reqs2 T"
          by (metis i488) }
      moreover
      { assume "CSTATE MIA T 1"
        then have ffff1: "(¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1) ∧ CSTATE MIA T 1"
          using f32 by metis
        have "C_state_not MIA RdShared T ∧ CSTATE MIA T 1 ∧ nextReqIs RdShared T 1 ∨ ¬ C_state_not MIA RdShared T ∨ ¬ CSTATE MIA T 1 ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by (metis i31) }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T ∨ nextHTDDataPending T 1"
        by metis
      moreover
      { assume "nextHTDDataPending T 1"
        then have ffff1: "(¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T) ∧ nextHTDDataPending T 1"
          using f37 by metis
        have "nextHTDDataPending T 1 ∧ [] = htddatas2 T ∨ ¬ nextHTDDataPending T 1 ∨ [] ≠ htddatas2 T"
          by auto
        then have "[] ≠ htddatas2 T"
          using ffff1 by metis
        then have "[] = reqs2 T"
          by (metis i101) }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ [] = reqs2 T"
        by metis
      moreover
      { assume "[] = reqs2 T"
        then have ffff1: "([] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1) ∧ [] = reqs2 T"
          using f31 by metis
        have "[] = reqs2 T ∧ nextReqIs RdShared T 1 ∨ [] ≠ reqs2 T ∨ ¬ nextReqIs RdShared T 1"
          by auto
        then have "¬ nextReqIs RdShared T 1"
          using ffff1 by metis }
      ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
        by metis }
    moreover
    { assume "CSTATE IMA T 1"
      then have fff1: "(¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1) ∧ CSTATE IMA T 1"
        using f42 by metis
      have "CSTATE ISAD T 1 ∧ ISAD ≠ IMA ∧ CSTATE IMA T 1 ∨ ¬ CSTATE ISAD T 1 ∨ ISAD = IMA ∨ ¬ CSTATE IMA T 1"
        by auto
      then have "¬ CSTATE ISAD T 1"
        using fff1 by (metis MESI_State.distinct(263)) }
    ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by metis }
  ultimately have "nextReqIs RdShared T 1 ∧ CSTATE ISAD T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ CSTATE ISAD T 1"
    then have ff1: "(¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1) ∧ ¬ CSTATE ISAD T 1"
      using f33 by metis
    have "C_msg_state RdShared ISAD T ∧ nextReqIs RdShared T 1 ∧ ¬ CSTATE ISAD T 1 ∨ ¬ C_msg_state RdShared ISAD T ∨ ¬ nextReqIs RdShared T 1 ∨ CSTATE ISAD T 1"
      by auto
    then have "¬ nextReqIs RdShared T 1"
      using ff1 by (metis i47) }
  ultimately have "nextReqIs RdShared T 1 ⟶ (¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    by metis
  moreover
  { assume "¬ nextReqIs RdShared T 1"
    then have ff1: "(¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1) ∧ ¬ nextReqIs RdShared T 1"
      using f19 by metis
    have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∧ ¬ nextReqIs RdShared T 1 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ nextReqIs RdShared T 1"
      by auto
    then have ff2: "¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff1 by metis
    have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      using ff2 by metis }
  ultimately have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
    have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      by auto
    then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
      using aa1 by metis
    then have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ ¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis
    moreover
    { assume aaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1"
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have fff2: "HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using aaa1 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        by auto
      then have "nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0"
        using fff2 by metis
      then have "nextReqIs RdShared T 0"
        using f11 f10 by metis
      then have fff3: "([] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0) ∧ nextReqIs RdShared T 0"
        using f15 by metis
      have "[] = reqs1 T ∧ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T ∨ ¬ nextReqIs RdShared T 0"
        by auto
      then have "[] ≠ reqs1 T"
        using fff3 by metis
      then have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
        by (metis i68) }
    ultimately have "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
      by metis }
  ultimately have f46: "¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by metis
  have f47: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = (CSTATE Invalid T 0 ∧ nextStore T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  have f48: "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ≠ ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ ((¬ CSTATE Invalid T 0 ∨ ¬ nextStore T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) ∨ (CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    by auto
  have "((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)) = ((CSTATE Invalid T 0 ∧ nextStore T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0))"
    by auto
  then show "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD]) 0)"
    using f46 f47 f48 by metis
next done
   show goal3_10: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     sorry (*failed to find proof*)
   show goal3_11: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     sorry (*failed to find proof*)
   show goal3_12: "CSTATE Invalid T 0 ∧ nextStore T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdOwn] [ 0 s= IMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj1 InvalidStore'_CSTATE_otherside InvalidStore'_CSTATE_sameside InvalidStore'_HSTATE
    InvalidStore'_nextReqIs_otherside i23 i824) done
qed
  show goal_4: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ SWMR ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
    proof (intro impconjI)
   show goal4_1: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ SWMR ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(125,35) SharedStore'_CSTATE_sameside) done
   show goal4_2: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     sorry (*failed to find proof*)
   show goal4_3: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) done
   show goal4_4: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(101,11,35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i106) done
   show goal4_5: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(281,35) SharedStore'_CSTATE_sameside) done
   show goal4_6: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) MESI_State.distinct(35) SMADSnpInv_C_msg_not_half SharedStore'_CSTATE_otherside
    SharedStore'_HSTATE i22) done
   show goal4_7: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_disj2 MESI_State.distinct(35) SharedStore'_CSTATE_otherside SharedStore'_CSTATE_sameside
    SharedStore'_HSTATE i22) done
   show goal4_8: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedStore'_HSTATE i107) done
   show goal4_9: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedStore'_HSTATE i107) done
   show goal4_10: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedStore'_HSTATE i107) done
   show goal4_11: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedStore'_HSTATE i107) done
   show goal4_12: "CSTATE Shared T 0 ∧ nextStore T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq RdOwn] [ 0 s= SMAD])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(35) SharedStore'_CSTATE_otherside
    SharedStore'_CSTATE_sameside SharedStore'_HSTATE i23) done
qed
  show goal_5: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
    proof (intro impconjI)
   show goal5_1: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_various_forms1 MESI_State.distinct(137,47) SharedSnpInv'_CSTATE_invariant5) done
   show goal5_2: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     sorry (*failed to find proof*)
   show goal5_3: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     sorry (*failed to find proof*)
   show goal5_4: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     sorry (*failed to find proof*)
   show goal5_5: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(293,47) SharedSnpInv'_CSTATE_invariant5) done
   show goal5_6: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_otherside_rule_10 InvalidX_HSTATE1 MESI_State.distinct(47) SharedSnpInv_C_msg_not_half
    i22)

Isar proof:
proof -
  have f1: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f2: "((∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  have f3: "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(∃veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. (veriT_vr294 ≠ veriT_vr295 ∧ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∧ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0) ∨ (∀veriT_vr294 veriT_vr295 veriT_vr296 veriT_vr297. veriT_vr294 = veriT_vr295 ∨ ¬ nextReqIs veriT_vr296 ( veriT_vr297 [ 0 s= veriT_vr294]) 0 ∨ ¬ CSTATE veriT_vr295 ( veriT_vr297 [ 0 s= veriT_vr294]) 0)"
    by auto
  then have f4: "(∃m ma r t. (m ≠ ma ∧ nextReqIs r ( t [ 0 s= m]) 0) ∧ CSTATE ma ( t [ 0 s= m]) 0) ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T"
    by auto
  have f6: "((∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 = HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]))"
    by auto
  have f7: "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∧ ¬ HSTATE veriT_vr166 veriT_vr167) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    by auto
  have "(∃veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. HSTATE veriT_vr166 veriT_vr167 ≠ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169])) ∨ (∀veriT_vr166 veriT_vr167 veriT_vr168 veriT_vr169. ¬ HSTATE veriT_vr166 ( veriT_vr167 [ 0 +=rdreq veriT_vr168] [ 0 s= veriT_vr169]) ∨ HSTATE veriT_vr166 veriT_vr167)"
    by auto
  then have f8: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f5 f6 f7 by metis
  have "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f9: "SIAC ≠ Modified ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by (metis MESI_State.distinct(47))
  have f10: "SIAC = Modified ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f4 by (metis SharedSnpInv_C_msg_not_half)
  have f11: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
    using f8 by (metis InvalidX_HSTATE1)
  have f12: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have f13: "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    by auto
  then have f14: "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    using f10 f9 f12 f13 by metis
  have f15: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1"
    by auto
  have f16: "((∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 = CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1)"
    by auto
  have f17: "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∧ ¬ CSTATE veriT_vr218 veriT_vr219 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  have "(∃veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. CSTATE veriT_vr218 veriT_vr219 1 ≠ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1) ∨ (∀veriT_vr218 veriT_vr219 veriT_vr220 veriT_vr221. ¬ CSTATE veriT_vr218 ( veriT_vr219 [ 0 +=rdreq veriT_vr220] [ 0 s= veriT_vr221]) 1 ∨ CSTATE veriT_vr218 veriT_vr219 1)"
    by auto
  then have "(∃m t r ma. CSTATE m t 1 ≠ CSTATE m ( t [ 0 +=rdreq r] [ 0 s= ma]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    using f15 f16 f17 by metis
  then have f18: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by (metis CSTATE_otherside_rule_10)
  have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE Modified T 1 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ CSTATE Modified T 1"
    by auto
  then have "CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ CSTATE Modified T 1"
    using f18 by metis
  moreover
  { assume aa1: "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using aa1 by metis }
  moreover
  { assume aa1: "CSTATE Modified T 1"
    have "(CSTATE Modified T 0 ∨ CSTATE Modified T 1) ∨ ¬ CSTATE Modified T 1"
      by auto
    then have "CSTATE Modified T 0 ∨ CSTATE Modified T 1"
      using aa1 by metis
    then have ff2: "¬ HSTATE SharedM T"
      by (metis i22)
    have "HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ ¬ HSTATE SharedM T ∨ ¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ HSTATE SharedM T"
      by auto
    then have ff3: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      using ff2 f11 by metis
    have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
      by auto
    then have ff4: "¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff3 by metis
    have "(HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      by auto
    then have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
      using ff4 by metis }
  ultimately have "(¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    by metis
  then have f19: "¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f14 by metis
  have f20: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = (CSTATE Shared T 0 ∧ nextEvict T 0 ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  have f21: "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ≠ ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ ((¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ ((¬ HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) ∨ (CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    by auto
  have "((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)) = ((CSTATE Shared T 0 ∧ nextEvict T 0) ∧ ((HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1))"
    by auto
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∧ (HSTATE SharedM ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1)"
    using f19 f20 f21 by metis
next done
   show goal5_7: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     sorry (*failed to find proof*)
   show goal5_8: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) HSTATE_X_Evict_invariant1 i107) done
   show goal5_9: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) HSTATE_X_Evict_invariant1 i107) done
   show goal5_10: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) HSTATE_X_Evict_invariant1 i107) done
   show goal5_11: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) HSTATE_X_Evict_invariant1 i107) done
   show goal5_12: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(15,359,47) SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv'_MAD_CSTATE_invariant4)

Isar proof:
proof -
  have f1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f3: "∀m t ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ 0 s= ma]) 1"
    using SharedSnpInv'_MAD_CSTATE_invariant4 by moura
  have f4: "Modified ≠ IMAD"
    using MESI_State.distinct(15) by moura
  have f5: "Modified ≠ SIAC"
    using MESI_State.distinct(47) by moura
  have "IMAD ≠ SIAC"
    using MESI_State.distinct(359) by moura
  then have "¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    using f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∨ ¬ CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ∨ ¬ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0 ∧ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1) ∧ (CSTATE IMAD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ nextReqIs RdOwn ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 1 ∧ HSTATE SD ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvictNoData] [ 0 s= SIAC]) 0)"
    by metis
next done
qed
  show goal_6: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    proof (intro impconjI)
   show goal6_1: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal6_2: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis CSTATE_disj1 MESI_State.distinct(215,43) SharedSnpInv'_CSTATE_invariant5)

Isar proof:
proof -
  { have ff1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
      using CSTATE_disj1 by moura
    have ff2: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
      using SharedSnpInv'_CSTATE_invariant5 by moura
    have ff3: "Modified ≠ SIA"
      using MESI_State.distinct(43) by moura
    have "ISD ≠ SIA"
      using MESI_State.distinct(215) by moura
    then have "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
      using ff3 ff2 ff1 by metis }
  then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by moura
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (CSTATE ISD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ nextHTDDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0)"
    by metis
next done
   show goal6_3: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis CSTATE_disj1 CSTATE_starting_transaction_otherside_invariant1 MESI_State.distinct(43)
    SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i23)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  then have "HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    using f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next done
   show goal6_4: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis CSTATE_disj1 CSTATE_inequality_invariant CSTATE_starting_transaction_otherside_invariant1
    MESI_State.distinct(101,11,43) SharedSnpInv'_CSTATE_invariant5 hstate_invariants(24,4) i106)

Isar proof:
proof -
  have f1: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f2: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ ma = m"
    using CSTATE_disj1 by moura
  have f3: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f4: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f5: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have f6: "∀m t n r ma. CSTATE m t 1 ∨ ¬ CSTATE m ( t [ n +=rdreq r] [ 0 s= ma]) 1"
    using CSTATE_starting_transaction_otherside_invariant1 by moura
  have f7: "CSTATE ISAD T 1 ∨ CSTATE ISAD T 0 ∨ ¬ HSTATE SAD T"
    using i106 by moura
  have f8: "Modified ≠ ISAD"
    using MESI_State.distinct(11) by moura
  have f9: "Modified ≠ SIA"
    using MESI_State.distinct(43) by moura
  have "Shared ≠ ISAD"
    using MESI_State.distinct(101) by moura
  then have "HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ (∃m. m ≠ Shared ∧ CSTATE m T 0)"
    using f9 f8 f7 f6 f5 f4 f3 f2 by metis
  moreover
  { assume "¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∧ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume aa1: "∃m. m ≠ Shared ∧ CSTATE m T 0"
    { have "¬ CSTATE Shared T 0"
        using aa1 f1 by metis }
    then have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1) ∧ (¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ∨ ¬ HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∨ ¬ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∨ ¬ CSTATE Shared T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 0) ∧ (HSTATE SAD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) ∧ nextDTHDataPending ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1 ⟶ ¬ CSTATE Modified ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA]) 1)"
    by metis
next done
   show goal6_5: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal6_6: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) MESI_State.distinct(43) SMADSnpInv_C_msg_not_half SharedEvictData'_CSTATE_otherside
    SharedEvictData'_HSTATE i22) done
   show goal6_7: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i22) done
   show goal6_8: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedEvictData'_HSTATE i107) done
   show goal6_9: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedEvictData'_HSTATE i107) done
   show goal6_10: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedEvictData'_HSTATE i107) done
   show goal6_11: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) SharedEvictData'_HSTATE i107) done
   show goal6_12: "CSTATE Shared T 0 ∧ nextEvict T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq CleanEvict] [ 0 s= SIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(43) SharedEvictData'_CSTATE_otherside
    SharedEvictData'_CSTATE_sameside SharedEvictData'_HSTATE i23) done
qed
  show goal_7: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
    proof (intro impconjI)
   show goal7_1: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ SWMR ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal7_2: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal7_3: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) ModifiedEvict'_HSTATE i23) done
   show goal7_4: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside
    ModifiedEvict'_CSTATE_sameside i72) done
   show goal7_5: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) C_not_C_msg_def ModifiedEvict'_CSTATE_otherside i49 i72 nextGOPending_DeviceModifiedEvict) done
   show goal7_6: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) ModifiedEvict'_HSTATE i22) done
   show goal7_7: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i22 i72) done
   show goal7_8: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) MESI_State.distinct(27) ModifiedEvict'_CSTATE_otherside SMADSnpInv_C_msg_not_half i72) done
   show goal7_9: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis dthdatas1_starting_transaction_otherside_invariant1 dthdatas2_starting_transaction_otherside_invariant2
    hstate_invariants(24,4) i189 i73 i897 nextDTHDataPending_def)

Isar proof:
proof -
  have f1: "¬ CSTATE Modified T 0 ∨ ¬ CSTATE Modified T 1"
    using i73 by moura
  have f2: "∀h t n m. HSTATE h t ∨ ¬ HSTATE h ( t [ n s= m])"
    using hstate_invariants(24) by moura
  have f3: "∀h t n r. HSTATE h t ∨ ¬ HSTATE h (t [ n +=rdreq r])"
    using hstate_invariants(4) by moura
  have f4: "dthdatas1 T = [] ∨ ¬ CSTATE Modified T 0"
    using i897 by moura
  have f5: "dthdatas2 T = [] ∨ ¬ HSTATE ModifiedM T"
    using i189 by moura
  have f6: "∀n t. (if n = 0 then dthdatas1 t ≠ [] else if n = 1 then dthdatas2 t ≠ [] else False) ∨ ¬ nextDTHDataPending t n"
    using nextDTHDataPending_def by moura
  have f7: "∀t n r na m. dthdatas2 ( t [ n +=rdreq r] [ na s= m]) = dthdatas2 t"
    using dthdatas2_starting_transaction_otherside_invariant2 by moura
  have f8: "∀t n r na m. dthdatas1 ( t [ n +=rdreq r] [ na s= m]) = dthdatas1 t"
    using dthdatas1_starting_transaction_otherside_invariant1 by moura
  have f9: "∀b ba. b ∨ ¬ (if True then b else ba)"
    using if_True by moura
  have f10: "∀b ba. (if True then b else ba) ∨ ¬ b"
    using if_True by moura
  have "∀b ba. b ∨ ¬ (if False then ba else b)"
    using if_False by moura
  then have "CSTATE Modified T 0 ∧ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    using f10 f9 f8 f7 f6 f5 f4 f3 f2 f1 by metis
  moreover
  { assume "¬ CSTATE Modified T 0"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  moreover
  { assume "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
    then have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0"
    by metis
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextDTHDataPending ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
next done
   show goal7_10: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_different1 InvalidX_HSTATE1 MESI_State.distinct(11)
    ModifiedEvict'_nextReqIs_invariant_not_RdOwn ReqType.distinct(11) i339 i417 i419 i456 i463 i487 i594 i72 i841
    nextReqIs_nonempty_reqs1 nextSnpRespIs_general_rule_9_0 nextStore_nextEvict_exclusive)

Isar proof:
proof -
  have f1: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T"
    by auto
  have f2: "((∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 = HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]))"
    by auto
  have f3: "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∧ ¬ HSTATE veriT_vr262 veriT_vr263) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    by auto
  have "(∃veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. HSTATE veriT_vr262 veriT_vr263 ≠ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265])) ∨ (∀veriT_vr262 veriT_vr263 veriT_vr264 veriT_vr265. ¬ HSTATE veriT_vr262 ( veriT_vr263 [ 0 +=rdreq veriT_vr264] [ 0 s= veriT_vr265]) ∨ HSTATE veriT_vr262 veriT_vr263)"
    by auto
  then have f4: "(∃h t r m. HSTATE h t ≠ HSTATE h ( t [ 0 +=rdreq r] [ 0 s= m])) ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f1 f2 f3 by metis
  have f5: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0"
    by auto
  have f6: "((∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 = nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23)"
    by auto
  have f7: "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∧ ¬ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  have "(∃veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict ≠ veriT_vr21 ∧ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23 ≠ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23) ∨ (∀veriT_vr21 veriT_vr22 veriT_vr23. DirtyEvict = veriT_vr21 ∨ ¬ nextReqIs veriT_vr21 ( veriT_vr22 [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) veriT_vr23 ∨ nextReqIs veriT_vr21 veriT_vr22 veriT_vr23)"
    by auto
  then have f8: "(∃r t n. DirtyEvict ≠ r ∧ nextReqIs r t n ≠ nextReqIs r ( t [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) n) ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f5 f6 f7 by metis
  have f9: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
    using f4 by (metis InvalidX_HSTATE1)
  have "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by auto
  then have f10: "DirtyEvict ≠ RdShared ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextReqIs RdShared T 0 ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    by (metis ReqType.distinct(11))
  have f11: "DirtyEvict = RdShared ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextReqIs RdShared T 0"
    using f8 by (metis ModifiedEvict'_nextReqIs_invariant_not_RdOwn)
  have f12: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ nextReqIs RdShared T 0 ∧ [] = reqs1 T"
    by auto
  have f13: "((∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  have f14: "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    by auto
  have "(∃veriT_vr1042 veriT_vr1043. nextReqIs veriT_vr1042 veriT_vr1043 0 ∧ [] = reqs1 veriT_vr1043) ∨ (∀veriT_vr1042 veriT_vr1043. ¬ nextReqIs veriT_vr1042 veriT_vr1043 0 ∨ [] ≠ reqs1 veriT_vr1043)"
    by auto
  then have f15: "¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
    using f12 f13 f14 by (metis nextReqIs_nonempty_reqs1)
  have f16: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0"
    by auto
  have f17: "((∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 = nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  have f18: "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∧ ¬ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by auto
  have "(∃veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ≠ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283) ∨ (∀veriT_vr279 veriT_vr280 veriT_vr281 veriT_vr282 veriT_vr283. ¬ nextSnpRespIs veriT_vr279 ( veriT_vr280 [ 0 +=rdreq veriT_vr281] [ 0 s= veriT_vr282]) veriT_vr283 ∨ nextSnpRespIs veriT_vr279 veriT_vr280 veriT_vr283)"
    by auto
  then have "(∃s t r m n. nextSnpRespIs s ( t [ 0 +=rdreq r] [ 0 s= m]) n ≠ nextSnpRespIs s t n) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    using f16 f17 f18 by metis
  then have f19: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
    by (metis nextSnpRespIs_general_rule_9_0)
  have f20: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ nextEvict T 0 ∧ nextStore T 0"
    by auto
  have f21: "((∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  have f22: "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    by auto
  have "(∃veriT_vr562 veriT_vr563. nextEvict veriT_vr562 veriT_vr563 ∧ nextStore veriT_vr562 veriT_vr563) ∨ (∀veriT_vr562 veriT_vr563. ¬ nextEvict veriT_vr562 veriT_vr563 ∨ ¬ nextStore veriT_vr562 veriT_vr563)"
    by auto
  then have f23: "¬ nextEvict T 0 ∨ ¬ nextStore T 0"
    using f20 f21 f22 by (metis nextStore_nextEvict_exclusive)
  have f24: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0"
    by auto
  have f25: "((∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. (¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199) ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  have f26: "(∃veriT_vr197 veriT_vr198 veriT_vr199. CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199 ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  have "(∃veriT_vr197 veriT_vr198 veriT_vr199. (CSTATE veriT_vr197 veriT_vr198 0 ∧ veriT_vr197 ≠ veriT_vr199) ∧ CSTATE veriT_vr199 veriT_vr198 0) ∨ (∀veriT_vr197 veriT_vr198 veriT_vr199. ¬ CSTATE veriT_vr197 veriT_vr198 0 ∨ veriT_vr197 = veriT_vr199 ∨ ¬ CSTATE veriT_vr199 veriT_vr198 0)"
    by auto
  then have "(∃m t ma. (CSTATE m t 0 ∧ m ≠ ma) ∧ CSTATE ma t 0) ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    using f24 f25 f26 by metis
  then have f27: "¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by (metis CSTATE_different1)
  have "CSTATE Modified T 0 ∧ Modified ≠ ISAD ∧ CSTATE ISAD T 0 ∨ ¬ CSTATE Modified T 0 ∨ Modified = ISAD ∨ ¬ CSTATE ISAD T 0"
    by auto
  then have "CSTATE ISAD T 0 ⟶ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f27 by (metis MESI_State.distinct(11))
  moreover
  { assume aa1: "¬ CSTATE ISAD T 0"
    have "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE ISAD T 0 ∨ CSTATE IMAD T 0 ∨ CSTATE IIA T 0"
      by auto
    then have "CSTATE IMAD T 0 ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0 ∨ CSTATE ISDI T 0 ∨ CSTATE Invalid T 0 ∨ CSTATE IIA T 0"
      using aa1 by metis
    moreover
    { assume aaa1: "CSTATE IIA T 0"
      have "CSTATE IIA T 0 ∧ HSTATE ModifiedM T ∨ ¬ CSTATE IIA T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "CSTATE IIA T 0 ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i419) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    moreover
    { assume aaa1: "CSTATE Invalid T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE Invalid T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume aaa1: "CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∨ ¬ CSTATE ISDI T 0"
        by auto
      then have "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
        using aaa1 by metis }
    moreover
    { assume "¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∧ ¬ CSTATE ISAD T 0 ∧ ¬ CSTATE IMAD T 0 ∧ ¬ CSTATE IIA T 0"
      then have fff1: "¬ nextSnpRespIs RspIFwdM T 0 ∧ ¬ nextSnpRespIs RspIHitSE T 0"
        by (metis i456)
      have "(nextSnpRespIs RspIFwdM T 0 ∨ nextSnpRespIs RspIHitSE T 0) ∨ ¬ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have "¬ nextSnpRespIs RspIFwdM T 0"
        using fff1 by metis
      then have fff2: "(¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0) ∧ ¬ nextSnpRespIs RspIFwdM T 0"
        using f19 by metis
      have "nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∧ ¬ nextSnpRespIs RspIFwdM T 0 ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ∨ nextSnpRespIs RspIFwdM T 0"
        by auto
      then have fff3: "¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    moreover
    { assume "CSTATE IMAD T 0"
      then have "nextStore T 0"
        by (metis i339)
      then have fff1: "(¬ nextEvict T 0 ∨ ¬ nextStore T 0) ∧ nextStore T 0"
        using f23 by metis
      have "nextEvict T 0 ∧ nextStore T 0 ∨ ¬ nextEvict T 0 ∨ ¬ nextStore T 0"
        by auto
      then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        using fff1 by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      by metis
    moreover
    { assume aaa1: "CSTATE Invalid T 0 ∨ CSTATE ISDI T 0"
      have "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T ∨ ¬ CSTATE Invalid T 0 ∧ ¬ CSTATE ISDI T 0 ∨ ¬ HSTATE ModifiedM T"
        by auto
      then have "HSTATE ModifiedM T ⟶ (CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        using aaa1 by metis
      moreover
      { assume "(CSTATE Invalid T 0 ∨ CSTATE ISDI T 0) ∧ HSTATE ModifiedM T"
        then have "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by (metis i417) }
      ultimately have "HSTATE ModifiedM T ⟶ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        by metis }
    ultimately have "HSTATE ModifiedM T ⟶ (¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∨ (¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      by metis
    moreover
    { assume "CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
      then have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        by metis
      moreover
      { assume aaaa1: "(CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1) ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1)"
        have "¬ CSTATE Modified T 1 ∧ ¬ CSTATE MIA T 1 ∧ (¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∧ (¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ CSTATE Modified T 1 ∨ CSTATE MIA T 1 ∨ (CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1 ∨ (CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1 ∨ (CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
          by auto
        then have "CSTATE MIA T 1 ∨ CSTATE Modified T 1"
          using aaaa1 by metis
        moreover
        { assume "CSTATE Modified T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i72) }
        moreover
        { assume "CSTATE MIA T 1"
          then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
            by (metis i594) }
        ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by metis }
      moreover
      { assume aaaa1: "(CSTATE IMAD T 1 ∨ CSTATE SMAD T 1) ∧ nextHTDDataPending T 1 ∧ nextGOPending T 1"
        have "(¬ CSTATE IMAD T 1 ∧ ¬ CSTATE SMAD T 1 ∨ ¬ nextHTDDataPending T 1 ∨ ¬ nextGOPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMD T 1 ∨ CSTATE SMD T 1) ∧ nextHTDDataPending T 1"
        have "(¬ CSTATE IMD T 1 ∧ ¬ CSTATE SMD T 1 ∨ ¬ nextHTDDataPending T 1) ∨ nextHTDDataPending T 1"
          by auto
        then have "nextHTDDataPending T 1"
          using aaaa1 by metis }
      moreover
      { assume aaaa1: "(CSTATE IMA T 1 ∨ CSTATE SMA T 1) ∧ nextGOPending T 1"
        have "(¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ ¬ nextGOPending T 1) ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have ffff2: "CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          using aaaa1 by metis
        have "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∨ CSTATE IMA T 1 ∨ CSTATE SMA T 1"
          by auto
        then have "CSTATE SMA T 1 ∨ CSTATE IMA T 1"
          using ffff2 by metis
        moreover
        { assume aaaaa1: "CSTATE IMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE IMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        moreover
        { assume aaaaa1: "CSTATE SMA T 1"
          have "(CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1) ∨ ¬ CSTATE SMA T 1"
            by auto
          then have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
            using aaaaa1 by metis }
        ultimately have "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ [] ≠ htddatas2 T ∧ ¬ CSTATE ISDI T 1"
          by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i841) }
      ultimately have "nextHTDDataPending T 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "nextHTDDataPending T 1"
        have "(CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1) ∨ ¬ nextHTDDataPending T 1"
          by auto
        then have "CSTATE ISAD T 1 ∧ nextGOPending T 1 ∨ CSTATE ISA T 1 ∨ nextHTDDataPending T 1 ∨ CSTATE Shared T 1"
          using aaaa1 by metis
        then have ffff2: "¬ CSTATE Modified T 0 ∧ ([] = dthdatas2 T ∨ nextSnpRespIs RspSFwdM T 1 ∨ HSTATE SD T)"
          by (metis i463)
        have "(CSTATE Modified T 0 ∨ [] ≠ dthdatas2 T ∧ ¬ nextSnpRespIs RspSFwdM T 1 ∧ ¬ HSTATE SD T) ∨ ¬ CSTATE Modified T 0"
          by auto
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          using ffff2 by metis }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    moreover
    { assume aaa1: "¬ HSTATE ModifiedM T"
      have "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ ¬ HSTATE ModifiedM T ∨ ¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ HSTATE ModifiedM T"
        by auto
      then have fff2: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        using aaa1 f9 by metis
      have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
        by auto
      then have fff3: "¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        using fff2 by metis
      have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        by auto
      then have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
        using fff3 by metis }
    ultimately have "((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis
    moreover
    { assume "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
      then have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ ¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis
      moreover
      { assume aaaa1: "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1"
        have "(HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have ffff2: "HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using aaaa1 by metis
        have "(¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          by auto
        then have "nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0"
          using ffff2 by metis
        then have "nextReqIs RdShared T 0"
          using f11 f10 by metis
        then have ffff3: "(¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T) ∧ nextReqIs RdShared T 0"
          using f15 by metis
        have "nextReqIs RdShared T 0 ∧ [] = reqs1 T ∨ ¬ nextReqIs RdShared T 0 ∨ [] ≠ reqs1 T"
          by auto
        then have "[] ≠ reqs1 T"
          using ffff3 by metis
        then have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
          by (metis i487) }
      ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
        by metis }
    ultimately have "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
      by metis }
  ultimately have f28: "¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0 ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by metis
  have f29: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = (CSTATE Modified T 0 ∧ nextEvict T 0 ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  have f30: "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ≠ ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ ((¬ CSTATE Modified T 0 ∨ ¬ nextEvict T 0) ∨ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ ((¬ HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∨ ¬ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∨ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) ∨ (CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    by auto
  have "((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)) = ((CSTATE Modified T 0 ∧ nextEvict T 0) ∧ ((HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ∨ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0))"
    by auto
  then show "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1) ∧ (HSTATE ModifiedM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) ∧ nextReqIs RdShared ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA]) 0)"
    using f28 f29 f30 by metis
next done
   show goal7_11: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     sorry (*failed to find proof*)
   show goal7_12: "CSTATE Modified T 0 ∧ nextEvict T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T [ 0 +=rdreq DirtyEvict] [ 0 s= MIA])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) ModifiedEvict'_CSTATE_otherside ModifiedEvict'_HSTATE i23 i72) done
qed
  show goal_8: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ SWMR ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    proof (intro impconjI)
   show goal8_1: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ SWMR ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal8_2: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ C_msg_P_oppo ISD nextHTDDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     cvc5: Try this: apply  simp (0 ms) done
   show goal8_3: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_same SD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis CSTATE_inequality_invariant MESI_State.distinct(5) SMADSnpInv_CSTATE SharedSnpInv'_CSTATE_invariant5
    SharedSnpInv_HSTATE SharedSnpInv_nextSnoopIs_otherside i23 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀X1 X4. zza X1 X4 = Some X1"
    by moura
  have f3: "¬ CSTATE Modified T 1 ∨ ¬ HSTATE SD T"
    using i23 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f4: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( t ⦇buffer1 := Some ma⦈ [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using SMADSnpInv_CSTATE by moura
  then have f5: "∀m t ma s ta. CSTATE m t 1 ∨ ¬ CSTATE m ( buffer1_update (zza ma) t [0 +=snpresp s ta] [0 -=snp ] [ 0 s= Invalid]) 1"
    using f2 by metis
  have f6: "∀m t n ma. ¬ CSTATE m t n ∨ ¬ CSTATE ma t n ∨ m = ma"
    using CSTATE_inequality_invariant by moura
  have f7: "∀m t. CSTATE m ( t [ 0 s= m]) 0"
    using SharedSnpInv'_CSTATE_invariant5 by moura
  have "Modified ≠ Invalid"
    using MESI_State.distinct(5) by moura
  then have f8: "HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    using f7 f6 f5 f4 f3 by metis
  have f9: "∀X0. zz (Some X0) = zza X0"
    by moura
  { assume aa1: "¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
    { have "¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using aa1 f9 by metis
      then have "¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f9 by metis
      then have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next done
   show goal8_4: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_same SAD nextDTHDataPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis HOST_State.distinct(149) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv
    SharedSnpInv_nextSnoopIs_otherside i384 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀X1 X4. zz X1 X4 = Some X1"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X6. zza B_X X6 = B_X"
    by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ hb = ha ∨ ¬ HSTATE hb t ∨ hb = hc ∨ hb = h"
    using HSTATE_invariant3 by moura
  have f4: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  have f5: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f6: "SAD ≠ MA"
    using HOST_State.distinct(149) by moura
  have f7: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f2 f4 by metis
  have "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "HSTATE SAD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ (∃h. MA ≠ h ∧ HSTATE h T)"
    using f7 f2 f1 f6 by metis
  moreover
  { assume "∃h. MA ≠ h ∧ HSTATE h T"
    then have "¬ HSTATE MA T"
      using f3 by metis
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f5 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    moreover
    { assume "¬ nextSnoopIs SnpInv T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  moreover
  { assume aa1: "¬ HSTATE SAD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next done
   show goal8_5: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ C_msg_P_oppo ISAD nextGOPending (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (smt (verit) CSTATE_inequality_invariant MESI_State.distinct(143,5) SharedSnpInv'_CSTATE_invariant5) done
   show goal8_6: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_same SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next done
   show goal8_7: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_oppo SharedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i384 i600 i653 i657 i659
    nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have f3: "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  have f4: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f5: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE IMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i657 by moura
  have f6: "¬ nextHTDDataPending T 1 ∨ ¬ CSTATE SMAD T 1 ∨ ¬ HSTATE SharedM T"
    using i659 by moura
  have f7: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ CSTATE SMAD T 1 ∨ CSTATE IMAD T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f8: "CSTATE IMA T 1 ∨ CSTATE SMA T 1 ∨ nextHTDDataPending T 1 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ HSTATE MA T"
    using i600 by moura
  have f9: "¬ CSTATE IMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  have "¬ CSTATE SMA T 1 ∨ ¬ HSTATE SharedM T"
    using i653 by moura
  then have "HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1 ∨ ¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    using f9 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ CSTATE SMAD T 1 ∧ ¬ CSTATE IMAD T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f7 by metis }
  moreover
  { assume "¬ CSTATE IMA T 1 ∧ ¬ CSTATE SMA T 1 ∧ ¬ nextHTDDataPending T 1"
    then have "¬ HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0"
      using f8 by metis }
  moreover
  { assume aa1: "¬ HSTATE SharedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE SharedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "nextSnoopIs SnpInv T 0 ∧ HSTATE MA T ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ HSTATE MA T"
    then have "¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      using f4 by metis
    moreover
    { assume "¬ CSTATE Shared T 0"
      then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
        by moura }
    ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by metis }
  ultimately have "nextSnoopIs SnpInv T 0 ⟶ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE SharedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next done
   show goal8_8: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ CSTATE Modified T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next done
   show goal8_9: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextDTHDataPending T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextDTHDataPending ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next done
   show goal8_10: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_oppo ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next done
   show goal8_11: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ H_msg_P_same ModifiedM (nextReqIs RdShared) (λT i. ¬ nextSnpRespIs RspIFwdM T i) ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis SharedSnpInv_C_msg_not_half2 SharedSnpInv_HSTATE i107 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message option ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X6. zz B_X X6 = B_X"
    by moura
  obtain zza :: "Message ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X5. zza B_X X5 = Some B_X"
    by moura
  have f3: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE ModifiedM T"
    using i107 by moura
  have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := Some m⦈ [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using SharedSnpInv_HSTATE by moura
  then have "∀h t m ta. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza m) t [0 +=snpresp RspIHitSE ta] [0 -=snp ] [ 0 s= Invalid])"
    using f2 by metis
  then have "HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ HSTATE ModifiedM T"
    by metis
  moreover
  { assume aa1: "HSTATE ModifiedM T"
    { have "¬ CSTATE Shared T 0"
        using aa1 f3 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE ModifiedM ( buffer1_update (zza (nextSnoop T 0)) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "∀X0. zz (Some X0) = zza X0"
        by moura
      then have "¬ HSTATE ModifiedM ( buffer1_update (zz (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 by metis
      then have "¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using f1 by metis }
    then have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∧ (HSTATE ModifiedM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∧ nextReqIs RdShared ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ⟶ ¬ nextSnpRespIs RspIFwdM ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1)"
    by metis
next done
   show goal8_12: "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ C_H_state IMAD (nextReqIs RdOwn) Modified SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
     apply  (insert assms , unfold SWMR_def C_msg_P_same_def C_msg_P_oppo_def H_msg_P_same_def C_H_state_def C_msg_not_def H_msg_P_oppo_def C_msg_P_host_def C_state_not_def H_C_state_msg_same_def H_C_state_msg_oppo_def C_msg_state_def C_not_C_msg_def) Try this:
  apply (metis HOST_State.distinct(177) HSTATE_invariant3 HSTATE_invariant_ModifiedSnpInv SharedSnpInv_C_msg_not_half2
    i384 i699 nextSnoopIs_otherside_rule_1_0)

Isar proof:
proof -
  obtain zz :: "Message ⇒ Message option ⇒ Message option" where
    f1: "∀B_X X5. zz B_X X5 = Some B_X"
    by moura
  obtain zza :: "Message option ⇒ Message option ⇒ Message option" where
    f2: "∀B_X X6. zza B_X X6 = B_X"
    by moura
  have f3: "∀h t ha hb hc. ¬ HSTATE h t ∨ ha = h ∨ ¬ HSTATE ha t ∨ ha = hb ∨ ha = hc"
    using HSTATE_invariant3 by moura
  have f4: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( t ⦇buffer1 := z⦈ [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using HSTATE_invariant_ModifiedSnpInv by moura
  have f5: "HSTATE MA T ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using i384 by moura
  have f6: "¬ CSTATE Shared T 0 ∨ ¬ HSTATE IB T"
    using i699 by moura
  have f7: "SD ≠ MA"
    using HOST_State.distinct(177) by moura
  have f8: "∀h t z n s ta m. HSTATE h t ∨ ¬ HSTATE h ( buffer1_update (zza z) t [n +=snpresp s ta] [n -=snp ] [ n s= m])"
    using f2 f4 by metis
  have "∀X0. zza (Some X0) = zz X0"
    by moura
  then have "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    using f8 f2 f1 f7 f6 f5 f3 by metis
  moreover
  { assume "¬ CSTATE Shared T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume "¬ nextSnoopIs SnpInv T 0"
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  moreover
  { assume aa1: "¬ HSTATE SD ( buffer1_update (zza (Some (nextSnoop T 0))) T [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
    { have "¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid])"
        using aa1 f2 by metis }
    then have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
      by moura }
  ultimately have "(¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∨ ¬ CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∨ ¬ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ∨ ¬ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0) ∨ ¬ CXL_SPG_used T 0 ∨ ¬ nextSnoopIs SnpInv T 0 ∨ ¬ CSTATE Shared T 0"
    by metis
  then show "CXL_SPG_used T 0 ∧ CSTATE Shared T 0 ∧ nextSnoopIs SnpInv T 0 ⟶ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1) ∧ (CSTATE IMAD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ nextReqIs RdOwn ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 1 ∧ HSTATE SD ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) ⟶ ¬ CSTATE Modified ( T ⦇buffer1 := Some (nextSnoop T 0)⦈ [0 +=snpresp RspIHitSE getTid (getSnoopOrMakeup (getSnoops 0 T))] [0 -=snp ] [ 0 s= Invalid]) 0)"
    by metis
next done
qed
qed